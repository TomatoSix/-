# 什么是MVVM？
Model-View-ViewModel(MVVM)是一种软件架构设计模式
(1)View层
视图层，即用户界面，由HTML和CSS构建
(2)Model层
指数据模型，即后端提供的API接口，指后端进行的各种业务逻辑处理和数据操控
(3)ViewModel层
视图数据层，View和Model层的桥梁
数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。

# 什么是SPA单页面应用？
SPA( single-page application)
概念：
仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML内容的变换，UI与用户的交互，避免页面的重新载。

优点：
(1)用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
(2)基于上面一点，SPA 相对对服务器压力小；
(3)前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

缺点：
(1)初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
(2)前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
(3)SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

# Vue的生命周期
8个分别为
beforeCreate  vue实例的挂载元素el和数据对象data都为undefined;methods,还未初始化
created       vue实例的数据对象data有了，el为undefined,还未初始化


beforeMount   vue实例的挂载元素el和data都初始化了，但挂在之前为虚拟的dom节点，data.message还未
              替换, 模板尚未挂载到页面中
mounted       vue被新创建的vm.$el替换，表示整个Vue实例已经初始化完毕，data.message成功渲染


beforeUpdate  当data变化时，会触发beforeUpdate和updated方法，data数据是最新的，但是页面尚未和
              最新的数据保持同步
updated       执行时，页面和data数据已经保持同步


activated     keep-alive 专属，组件被激活时调用
deactivated   keep-alive 专属，组件被销毁时调用


beforeDestroy 当执行beforeDestroy的时候，实例身上所有的data和所有的methods以及过滤器、
              指令都处于可用状态，此时还未真正执行销毁的过程
destroyed     对data的改变不会再触发周期函数，此时vue实例已经解除了事件监听和DOM的绑定，但是dom结构
              依然存在

# 1.v-show和v-if的区别？
相同点： 当条件不成立时，其所对应的标签元素都不可见

不同点：
v-if   真正的条件渲染，在切换过程中条件块内的事件监听器和子组件会适当的创建和销毁
       适用于不需要频繁切换条件的场景
v-show 仅在初始化时加载一次，操作的是样式(display),切换当前样式的显示与隐藏，
       适用于需要频繁切换条件的场景

# computed和watch的区别？
计算属性computed：
    1. 支持缓存，只有依赖数据发生改变，才会重新进行计算不支持异步，当computed内有异步操作时无效，无法监听数据的变化computed 属性值会默认走缓存
    2. 计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值。如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed。如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。
    3. 每个计算属性都包含一个getter和一个setter方法
    例如
    const app = new Vue({
      el: '#app',
      data: {
        firstName: 'Kobe',
        lastName: 'Bryant'
      },
      // computed简写形式,只设置get方法，为只读属性
      computed: {
        fullName: function() {
          return this.firstName + ' ' + this.lastName
        }
      }

      //  计算属性的get和set方法 
      computed: {
        fullName: {
          set: function(newValue) {
            const names = newValue.split(' ')
            this.firstName = name[0]
            this.lastName = name[1]
          },
          get: function() {
            return this.firstName + ' ' + this.lastName
          }
        }
      }
    })    

侦听属性watch：
    不支持缓存，数据变，直接会触发相应的操作；watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；当一个属性发生变化时，需要执行对应的操作；一对多；监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：

# class与style的动态绑定







# v-on 的修饰符使用
@click.stop  阻止冒泡  调用event.stopPropagation()
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>
@click.prevent  阻止默认事件   调用event.preventDefault()
<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>
<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>
@click.native  监听组件根元素的原生事件
@click.once  只触发一次回调
@keyUp.enter  键修饰符，监听回车

# 事件处理方法
<body>
  <div id="app">
    <button @click="say()">方法</button>
    <!-- 没有参数()可以直接省略，有括号必须传入参数，否则为undefined -->
    <button @click="say1">方法1</button>
    <button @click="say2('hi')">方法2</button>
    <!-- 通过$event访问原始的DOM事件 -->
    <button @click="say3(message, $event)">方法3</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script>
    const app = new Vue({
      el: "#app",
      data: {
        message: "你好啊"
      },
      methods: {
        say(event){
          console.log(event);  //undefined
        },
        say1: function(event){
          // 会自动传入一个event
          console.log(event);  //MouseEvent
          console.log(this.message);   //你好啊
        },
        say2: function(a) {
          console.log(a);  //hi
        },
        say3: function(b,event) {
          console.log(b,event);  //你好啊   MouseEvent
        }
      },
    })      
  </script>
</body>



# 为什么vue组件中data必须是一个函数？
   对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。

# v-model的原理
v-model 指令在表单 <input>、<textarea> 及 <select> 元素上创建双向数据绑定。
1. text 和 textarea 元素使用 value property 和 input 事件；
2. checkbox 和 radio 使用 checked property 和 change 事件；
3. select 字段将 value 作为 prop 并将 change 作为事件。
<body>
  <div id="app">
    <!-- v-model实现双向绑定 -->
    <!-- <input type="text" v-model="message"> -->

    <!-- 实现双向绑定方法二 -->
    <!-- <input type="text" :value="message" @input="valueChange"> -->
    <input type="text" :value="message" @input="message = $event.target.value">

    <h2>{{message}}</h2>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script>
    const app = new Vue({
      el: '#app',
      data: {
        message: '你好啊'
      },
      methods: {
        // 会默认传入一个event参数
        valueChange(event) {
          this.message = event.target.value
        }
      },
    })
  </script>  
</body>


# Vue组件的通信方式
常见使用场景可以分为三类：
父子组件通信、兄弟组件通信、跨级通信

常见的几种通信方式
(1) props / $emit                     适用于父子组件通信
(2) ref="组件名" this.$refs.组件名     适用于父子组件通信
(3) $parent / $children               适用于父子组件通信
(4) EventBus 事件总线 $emit / $son     适用于父子、隔代、兄弟组件通信
(5) vuex                              适用于父子、隔代、兄弟组件通信
(6) provide / inject                  适用于隔代组件通信
(7) $attrs / $listeners               适用于隔代组件通信
 
### vuex

# vuex的使用
Vuex：专为 Vue.js 应用程序开发的状态管理模式
格式：
const store = new Vuex.Store({
  state:{},
  getters:{},
  mutations:{},
  actions:{}
})
主要模块为
state:用于设置默认的初始状态  
getters:相当于Vue中的计算属性computed，getter 的返回值会根据它的依赖被缓存起来，
        且只有当它的依赖值发生了改变才会被重新计算

        接收两个参数分别为(state,getters)
mutations: 包括两个部分为 
            1 字符串的事件类型(type)  
            2 一个回调函数(handler)参数为(state,payload)

            state状态更新的唯一方式：
            在组件中使用this.$store.commit('mutations中的方法名'，payload) 提交mutation
            且必须为同步函数
actions: 用于提交mutation,而不是直接变更状态，可以包含任意异步操作
            组件中使用this.$store.dispatch('actions中的方法名'，data)
            mutations中使用this.$store.commit('mutations中的方法名'，data)
modules: 允许将单一的store拆分成多个store且同时保存在单一的状态树中


### vue-router
#  vue-router中常用的hash和history路由模式实现原理
（1）hash 模式的实现原理
（2）history 模式的实现原理

# 对keep-alive的了解
是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染

1.一般结合路由和动态组件一起使用，用于缓存组件；
2.提供 include 和 exclude 属性，两者都支持字符串或正则表达式
  include 表示只有名称匹配的组件会被缓存，
  exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
3.对应两个钩子函数 activated 和 deactivated 
  当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。

# Vue不能检测的数组变动
1.利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue
  解决方法： Vue.set(vm.items, indexOfItem, newValue)
2.修改数组的长度时，例如：vm.items.length = newLength
  解决方法： vm.items.splice(newLength)

# assets和static的区别？
assets中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。

static中的文件则不会被打包。

# $nextTick是什么？
在DOM更新完毕之后执行一个回调
<template>
  <div :class="$style.behavior">
    <TopView :cparams="params" ref="bb"></TopView>
  </div>
</template>
export default {
  created() {
    console.log('bbbbbbbbbbbbbbbbb', this.$refs.bb);
    this.$nextTick(() => {
    // 响应式发生修改页面渲染完成之后触发
    //在DOM更新完毕之后执行一个回调
    console.log('bbbbbbbbbbbbbbbbb', this.$refs.bb);
    });
    setTimeout(this.setOptions, 500);
  }
}

结果为
bbbbbbbbbbbbbbbbb  undefined
bbbbbbbbbbbbbbbbb  打印出当前组件
可用于加载中，模拟延迟效果