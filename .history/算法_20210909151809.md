# 二分查找
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left = 0, right = nums.length-1
    while (left <= right) {
        let midIndex = Math.floor((right - left)/2) + left
        let mid = nums[midIndex]
        if (mid === target) {
            return midIndex
        } else if(mid < target) {
            left = midIndex + 1
        } else {
            right = midIndex -1
        }
    }
    return -1
};
```

// 最小路径和
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    if (grid.length === 0 || grid[0].length === 0) return 0
    let rows=grid.length, columns=grid[0].length
    // 定义二维数组
    const dp = new Array(rows)
    for (let i=0; i<rows; i++) {
        dp[i] = new Array(columns)
    }
    dp[0][0] = grid[0][0]
    for (let i=1; i<rows; i++) {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for (let j=1; j<columns; j++) {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }

    for (let i=1; i<rows; i++) {
        for (let j=1; j<columns; j++) {
            dp[i][j] = Math.min(dp[i][j-1], dp[i-1][j]) + grid[i][j]
        }
    }

    return dp[rows-1][columns-1]
};
```

# 排序
https://juejin.cn/post/6856546833025237006#heading-9
## 分类
* 按排序依据的原则
插入排序： 直接插入排序、希尔排序
交换排序： 冒泡排序、快速排序
选择排序:  直接选择排序、堆排序
归并排序： 2-录归并排序
基数排序

* 根据排序的稳定性：关键字相同的记录在排序过程中是否保持前后次序不变
不变则为稳定排序，变化则为不稳定排序

稳定排序： 直接插入排序、冒泡排序、归并排序、计数排序
不稳定排序：希尔排序、直接选择排序、堆排序、快速排序

* 时间复杂度

1. 冒泡排序-稳定
```javascript
let bubbleSort = function(arr, flag = 0) {
  let len = arr.length

  // 最外层for循环表示循环次数，需循环len - 1次
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {
      //比较相邻两者之间的关系大小
      if (arr[j] > arr[j+1]) {
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
      }
    }
  }
  return flag ? arr.reverse() : arr
}
let arr = [2,10,8,3,0,5]
console.log(bubbleSort(arr, 1)) //flag 0-正序 1-倒序
```

2. 快速排序- 不稳定
基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
```javascript
let quickSort = function(arr) {
  // 递归出口就是数组长度为1
  if (arr.length <= 1) return arr
  // 获取中间值的索引，使用Math.floor向下取整
  let index = Math.floor(arr.length / 2)
  // 使用splice截取中间值
  let pivot = arr.splice(index,1)[0], left = [], right = []
  for (let i = 0; i < arr.length; i++) {
    // 如果中间值更大，则将arr[i] push左边数组
    if (pivot > arr[i]) {
      left.push(arr[i])
    } else {
      // 否则，将arr[i] push右边数组
      right.push(arr[i])
    }
  }
  return quickSort(left).concat([pivot], quickSort(right))
}
```

3. 直接插入排序-稳定
基本原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
```javascript
let insertSort = function(arr) {
  // 取数组长度
  let len = arr.length

  for (let i = 0; i < len; i++) {
    // cur 表示当前要插入比较的元素
    let preIndex = i -1, cur = arr[[i]
    // 若前面的数字比当前值cur大，则前面的数字向后移动一位，继续向前一位与当前值比较
    // preIndex >= 0 是为了保证第一个元素认为被排序
    while (preIndex >= 0 && arr[preIndex] > cur) {
      arr[preIndex + 1] = arr[preIndex]
      preIndex--
    }
    // 如果小，则放入当前数字的后面
    arr[preIndex + 1] = cur
  }
  return arr
}
```

4. 归并排序

5. 计数排序

6. 希尔排序

7. 直接选择排序
基本原理：每一次从待排序的数组元素中选择最大的一个元素作为首元素，直到排完为止
```javascript
let selectSort = function (arr, flag = 0) {    
  let len = arr.length,  temp = 0;    
  // 一共需要排序len-1次, 即循环次数
  for (let i = 0; i < len - 1; i++) {        
    temp = i;  
    // 取出后续数字中最小数字的索引      
    for (let j = i + 1; j < len; j++) {            
      if (arr[j] < arr[temp]) {
        temp = j;        
      }             
    }        
    // 每一趟保证第i位为最小值, 此时的temp为后续最小数字的索引       
    if (temp !== i) {            
      [arr[i], arr[temp]] = [arr[temp], arr[i]]        
    }    
  }    
  return flag ? arr.reverse() : arr}

  let arr = [2, 9, 6, 7, 4, 3, 1, 7, 0, -1, -2]
  console.log(selectSort(arr, 1))

```

8. 堆排序






# 二叉树 
## 二叉树的深度
```javascript

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    return !root ? 0 : Math.max(maxDepth(root.left),maxDepth(root.right))+1
};
```
## 二叉树的遍历

DLR--前序遍历-中左右（根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面 ）

LDR--中序遍历-左中右（根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）

LRD--后序遍历-左右中（根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面）


### 二叉树的先序遍历

1. 非递归实现
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    const result = []
    const stack = []
    let current = root
    while (current || stack.length > 0){
        while (current){
            result.push(current.val)
            stack.push(current)
            current = current.left
        }
        current = stack.pop()
        current = current.right
    }
    return result
};

2. 递归实现
var preorderTraversal = function(root，array = []) {
    if (root){
      array.push(root.val)
      preorderTraversal(root.left, array)
      preorderTraversal(root.right, array)
    }
    return array
};


### 二叉树的后序遍历

1. 非递归实现
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if(root == null) return [];
    let stack = [], res = [];
    let visited = new Set();
    let p = root;
    while(stack.length || p) {
        while(p) {
            stack.push(p);
            p = p.left;
        }
        let node = stack[stack.length - 1];
        // 如果右孩子存在，而且右孩子未被访问
        if(node.right && !visited.has(node.right)) {
            p = node.right;
            visited.add(node.right);
        } else {
            res.push(node.val);
            stack.pop();
        }
    }
    return res;
};

2. 递归实现
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    let arr = [];
    let traverse = (root) => {
      if(root == null) return;
      traverse(root.left);
      traverse(root.right);
      arr.push(root.val);
    }
    traverse(root);
    return arr
};


# 链表

//反转链表
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let prev = null
    let curr  = head
    //如果curr为null,则其已经成为最后一个节点，链表已经反转完成
    while (curr){
        //先用next保存下一个节点
        let next = curr.next
        //将curr指向prev前面一个节点
        curr.next = prev
        //prev节点后移
        prev = curr
        //curr节点也后移
        curr = next
    }
    return prev
};



//合并两个排序的链表
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    if(!l1){
        return l2
    }
    if(!l2){
        return l1
    }
    let head
    if (l1.val < l2.val){
        head = l1
        head.next = mergeTwoLists(l1.next,l2)
    }else{
        head = l2
        head.next = mergeTwoLists(l1,l2.next)
    }
    return head
};


//删除链表中的节点
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */

var deleteNode = function(head, val) {
    if (head.val === val){
        return head.next
    }
    head.next = deleteNode(head.next,val)
    return head
};





# 数组

//找出数组中重复数字
/**
 * @param {number[]} nums
 * @return {number}
 */
var findRepeatNumber = function(nums) {
    let map = new Map()
    for (let i of nums){
        if (map.has(i)) return i;
        map.set(i,1)
    }
    return null
};


//最大子序和
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let pre = 0 ;
    let maxSum = nums[0];
    nums.forEach((x) =>{
        //如果之前的和加上当前元素值还没有当前元素值大，则丢弃
        pre = Math.max(pre+x,x)
        maxSum = Math.max(pre,maxSum)
    })
    return maxSum
};


//数组变整数加一
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    
    for (let i=digits.length-1; i>=0; i--){
        digits[i]++
        digits[i] = digits[i] % 10
        if (digits[i] != 0){
            return digits
        }      
    }
    digits.unshift(1)
    return digits  
};


//有序数组的平方
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function(nums) {
    let newNum = nums.map((x) =>{
        return x = x * x
    })
    newNum.sort((x,y) => x - y)
    return newNum
};




# 面试题
//翻转单词顺序
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    //将两个单词多余的空格减少到一个
    s = s.replace(/ +/g, ' ')
    return  s.split(' ').reverse().join(' ').trim()
};