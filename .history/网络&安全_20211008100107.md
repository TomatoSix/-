# HTTP与计算机网络
1. TCP/IP协议分层管理
2. 三次握手四次挥手机制及原因
3. HTTP方法
4. GET和POST的区别
5. HTTP建立持久连接的意义
6. HTTP报文的结构
7. HTTP状态码
8. Web服务器及其组成
9. HTTP报文首部
10. HTTP通用首部字段
11. HTTP请求首部字段、响应首部字段、实体首部字段
12. Cookie相关首部字段
13. HTTPS与HTTP区别及实现方式
14. Cookie与Session
15. 基于HTTP的功能追加协议（SPY、WebSocket、HTTP）
16. 常见的Web攻击分类
17. TCP与UDP区别
18. 存储机制localStorage、sessionStorage与Cookie存储技术
19. XSS攻击及防御
20. CSRF攻击及防御

# cookie localStorage sessionStorage token session
## cookie
https://github.com/mqyqingfeng/Blog/issues/157  
  概念： 一段一般不超过4kb的小型文本数据（通常用来判断两个请求是否来自同一个浏览器）  
  ### 存放位置：
  浏览器、本地文件  
  ### 分类
  1.会话性cookie （不包含到期日期）- 当Expires属性缺省或者值为session
      值保存在客户端内存中，并在用户关闭浏览器时失效  
  2.永久性cookie（包含有效期）  
      会保存在用户的硬盘中，直至过期或者清除cookie  
  ### 作用： 
  解决客户端与服务端会话状态的问题  
  1. 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）  
  2. 个性化设置（如用户自定义设置、主题等）  
  3. 浏览器行为跟踪(如跟踪分析用户行为等)  

  ### 如何设置cookie
  1. 客户端发送HTTP请求到服务器
  2. 当服务器收到HTTP请求时，在响应头里面添加一个Set-Cookie字段
  3. 浏览器收到响应后保存下cookie
  4. 之后对该服务器每一次请求中都通过cookie字段将cookie信息发送给服务器

  ### cookie的相关属性
  * Name/Value 
  * Expires/Max-Age
    Expires 用于设置cookie的过期时间-当该值缺省或者值为session时，表示为会话性cookie
    Max-Age 用于设置在cookie失效之前需要经过的秒数
            > 0 浏览器会将其持久化,即写到对应的cookie文件中
            = 0 则会立即删除这个cookie
            < 0 则表示该cookie只是一个会话性cookie
  
  * Domain  指定了cookie可以送达的主机名  
  * Path   指定了一个URL路径，这个路径必须出现在要请求的资源的路径中才可以发送Cookie首部  
  Domain和Path标识共同定义了Cookie的作用域：即cookie应该发送哪些URL

  * Secure  只应通过被HTTPS协议加密过的请求发送给服务端  
  * HttpOnly  防止客户端脚本通过document.cookie等方式访问Cookie,有助于避免XSS攻击  
  * SameSite  防止Cookie在跨站请求时不会被发送，从而阻止跨站请求伪造攻击(CSRF)  
            三种值：  
                Strict 仅允许一方请求携带cookie，即浏览器将只发送相同站点请求的cookie  
                Lax  允许部分第三方请求携带cookie  
                None 无论是否跨站都会发送cookie  
  * Size
  * Priority


  ### 缺点
  从大小，安全，增加请求大小。

  1. 容量缺陷-Cookie 的体积上限只有4KB，只能用来存储少量的信息。
  2. 降低性能-Cookie紧跟着域名，不管域名下的某个地址是否需要这个Cookie，请求都会带上完整的Cookie，请求数量增加，会造成巨大的浪费。
  3. 安全缺陷-Cookie是以纯文本的形式在浏览器和服务器中传递，很容易被非法用户获取，当HTTPOnly为false时，Cookie信息还可以直接通过JS脚本读取。
  4. 数据无法持久化储存

## localStorage
在自己电脑上
## sessionStorage
在自己电脑上
## token
## session




# 三次握手四次挥手机制及原因
https://juejin.cn/post/6844903958624878606

https://zhuanlan.zhihu.com/p/86426969

# HTTP
https://juejin.cn/post/6857287743966281736

HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范
## HTTP版本
0.9 HTTP第一版
1.0 作为正式的标准被建立
1.1 目前的主流版本
2   2015年发布
3   

## HTTP存在的位置
应用层

其他协议还有
FTP 文件传输协议
DNS 域名系统
SMTP 邮件发送协议 (Simple Mail Transfer Protocol)
DHCP
POP3
## HTTP方法
* GET: 通常用来获取资源，幂等
* HEAD: 获取报文首部，幂等
* POST: 创建和更新资源  
两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI，所以POST是「非幂等」的。
* PUT: 创建和更新资源  
第一次PUT方法执行之后，其在服务器上生成的资源，不能被后续的PUT方法更改，所以对同一URI进行多次PUT的副作用和一次PUT是相同的，因而它是「幂等」的。
* DELETE: 删除资源， 幂等
* CONNECT: 建立连接隧道，用于代理服务器
* OPTIONS: 列出可对资源实行的请求方法，用来跨域请求， 幂等
* TRACE: 追踪请求
* PATCH：对资源进行局部更新，非幂等操作

## GET和POST区别？
1. 从缓存的角度，GET请求会被浏览器主动缓存下来，留下历史记录，而POST不会
2. 从编码的角度，GET只能进行URL编码，而POST没有限制
3. 从参数的角度，GET放在URL中，POST放在请求体中，更适合传输敏感信息
4. 从幂等性角度，GET是幂等的，而POST不是
5. 从TCP角度，GET请求会把请求报文一次性发出去，而POST会分为两个TCP数据包，首先发header部分，如果服务器响应100，然后发body部分

* 什么是幂等？
如果一个方法重复执行多次，产生的效果是一样的，那么这个方法就是幂等的。「它本质上意味着成功执行请求的结果与其执行次数无关。」
## HTTP状态码
1** 表示目前是协议处理的中间状态，还需要后续操作
2** 表示成功状态
3** 重定向状态
4** 客户端错误
5** 服务器端发生错误

101 Switching Protocols  在HTTP升级为WebSocket时，如果服务器同意变更，则返回101

200 OK   请求成功状态
204 No Content    成功状态，返回的数据中没有响应体
206 Partial Content   部分内容成功，它的使用场景为HTTP分块下载和断点续传

301 Moved Permanently 永久重定向
302 Found 临时重定向，它表示请求的资源临时被移动到了别的URI上
303 See Other 临时重定向  请求的资源临时被移动到了别的URI上，明确表示客户端应该使用GET方法获取资源
304 Not Modified 协商缓存
307 Temprary Redirect：临时重定向，但是比302更加明确，重定向的请求方法和实体都不允许变动

400 Bad Request：请求报文中存在语法错误，但是没有具体指出是哪里。
401 Unauthorized：需要有通过HTTP认证的认证信息或者表示用户认证失败。
403 Forbidden：请求资源被拒绝，原因是：比如法律禁止、信息敏感。
404 Not Found：请求资源未找到，表示没在服务器上找到相应的资源。

500 Internal Server Error 服务器内部错误
501 Not Implemented  表示客户端请求的功能还不支持
502 Bad Gateway  
503 Service Unavailabel  服务器处于超负荷状态或进行停机维护





## HTTP特点
* 灵活可扩展 
* 可靠传输
* 请求-应答
* 无状态

## HTTP缺点
* 无状态
* 明文传输
* 无法验证通信双方
* 无法保证数据的完整性
* 队头阻塞问题
## HTTP首部字段

1. 通用首部字段 
* Cache-control
* Date
* Connection
* Transfer-Encoding

2. 实体首部字段
* last-Modified
* Expires
* Allow

3. 请求首部字段
* Host 请求的资源所处的互联网主机名和端口号
* Accept 客户端或者代理能够处理的媒体类型(文本文件/图片文件/视频文件)
* Authorization 用户代理的认证信息
* User-Agent 获取客户端程序信息

4. 响应首部字段
* ETag
* Serve
* Location


## HTTP2
* 头部压缩
* 多路复用 二进制分帧解决HTTP队头阻塞问题

# HTTPS
https://juejin.cn/post/6889068972542459917#heading-2
在HTTP和TCP之间建立了一个中间层(安全层) 
HTTPS = HTTP + SSL/TLS   SSL 安全套接层  TLS 传输层安全
## HTTPS优点
* 数据隐私性，内容经过对称加密 - 混合加密机制
* 数据完整性，内容经过完整性校验 - 数字签名
* 身份认证，第三方无法伪装客户端/服务器的身份 -数字证书

## HTTPS具体的解决方式
1. 解决内容被窃听
* 对称秘钥加密
加密解密用的都是相同的秘钥
* 非对称秘钥加密
概念：使用一对非对称的秘钥，一把是私钥（只能自己才能有），一把是公钥（可以发布给任何人），用私钥加密的数据包只有公钥能解，用公钥加密的数据包只有私钥能解

过程：发送密文的一方用对方打得公钥对信息进行加密，对方收到被加密的信息后再用自己的私钥进行解密

* 混合加密机制(HTTPS采用的方式)
概念：结合两种加密方式的优点，在交换秘钥环节使用非对称加密方式，之后的建立通信交换报文阶段使用对称加密方式

流程：发送密文的一方使用对方的公钥加密处理对称的秘钥，对方接收到之后使用自己的私钥解密得到对称的秘钥


2. 解决内容被篡改(数字签名)-校验数据的完整性
* 数字签名
第一步：将原文用Hash函数生成一个叫消息摘要的东西
第二步：用发送方的私钥对这个消息摘要进行加密，产生的东西就叫做数字签名

数字签名流程图
* 首先发送方会将原文与数字签名(加密后的消息摘要)一起发送给接收方
* 接收方会接收原文和数字签名
* 接收方用Hash函数处理原文得到一份消息摘要
* 同时用发送方的公钥解密数字签名得到一份消息摘要
* 只要比较这两份消息摘要是否相等就可以验证数据有没有被篡改了


3. 解决通信方身份遭伪装(数字证书)
数字证书也叫公钥证书，主要是为了解决通信方身份遭伪装的问题，也就是验证通信方的身份
由一些权威的数字认证机构颁发给服务器的一个文件

证书的组成
* 明文信息
  包括申请者的公钥、组织信息、个人信息、签发机构CA的信息、有效时间、证书序列号等明文信息
* 签名
  CA(数字认证机构)先是通过Hash函数对公开的明文信息做处理生成一个信息摘要，接着用自己的私钥对信息摘要加密生成签名

## TLS握手
1. 传统的TLS握手就是RSA握手
2. 现在主流的TLS1.2版本的握手就是ECDHE握手

* ECDHE握手介绍
1. 客户端在第一次发送HTTPS请求的时候，会把client_random、TLS版本号、加密套件列表发送给服务器
2. 服务器在接收到之后确认TLS的版本号，同时发送server_random、server_params、需要使用的加密套件、以及自己的证书给客户端
3. 客户端在收到这些信息之后，首先会对服务器的证书进行验证，若是验证成功则会传递一个client_params给服务器
4. 与此同时客户端会通过ECDHE算法计算出一个pre_random，其中传入了两个参数，client_params和server_params
5. 这时客户端就同时拥有的client_random、server_random、pre_random，它会将这三个参数通过一个伪随机函数计算得出最终的secret,这个secret就是它们后续通信所要用的对称秘钥
6. 客户端生成完secret之后，会给服务器发送一个收尾消息，告诉服务器之后都要用对称秘钥，且对称加密的算法是用第一次约定好的
7. 服务器在接收刚刚传递过来的client_params之后，也会使用和客户端一样的方式生成secret，并且也会发送一个收尾消息给客户端
8. 当双方都收到收尾消息并验证成功之后，握手就结束了。后面开始用这个secret对称秘钥加密报文进行传输


* RSA握手介绍
1. 客户端首先发送 client_random、TSL版本号、加密套件列表给服务器
2. 服务器在接收到之后确认TSL版本号，同时发送server_random、需要使用的加密套件、自己的证书给客户端
3. 客户端在收到这些信息之后，首先是会对服务器的证书进行验证(也就是题目7)，若是验证成功则会用RSA算法生成一个pre_random，且用服务器的公钥(在证书中)加密pre_random发送给服务器。
4. 此时，客户端有了 client_random、server_random、pre_random，它会将这三个参数通过一个伪随机函数计算得出最终的secret，这个secret就是它们后续通信所要用的对称密钥。
5. 服务器接收到了刚刚用自己公钥加密的pre_random之后，用自己的私钥进行解密，得到里面的  pre_random，用和客户端一样的方式生成secret。
6. 之后就用这个secret对称密钥加密报文传输。

# 浏览器缓存
https://juejin.cn/post/6844904021308735502
https://www.jianshu.com/p/54cc04190252

## DNS缓存
域名系统 DNS(Domain Name System)
域名解析 通过域名，最后得到该域名对应的IP地址的过程

## CDN缓存
内容分发网络 CDN(Content Delivery Network)

## 浏览器缓存
强缓存和协商缓存
强缓存分为Cache Control和 Expires

## 缓存位置
Service Worker  离线缓存
Memory Cache  内存缓存
Disk Cache  磁盘缓存
Push Cache   推送缓存

# 浏览器本地存储
浏览器的本地存储分为
cookie 
WebStorage   包括localStorage和SessionStorage
IndexedDB


# 从输入URL到页面呈现发生了什么？
https://juejin.cn/post/6844904021308735502#heading-54
* 构建请求-查找强缓存-DNS解析-建立TCP连接-发送HTTP请求
* 构建DOM树-样式计算-生成布局树
* 建立图层树-生成绘制列表-生成图块并栅格化


# 重排和重绘

  1.HTML 被 HTML 解析器解析成 DOM 树；
  2.CSS  被 CSS 解析器解析成 CSSOM 树；
  3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；
  4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；
  5.将布局绘制(paint)在屏幕上，显示出整个页面。
  第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染。

  重排: 当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。

  重排也叫回流，简单的说就是重新生成布局，重新排列元素。

  页面初始渲染，这是开销最大的一次重排
  添加/删除可见的DOM元素
  改变元素位置
  改变元素尺寸，比如边距、填充、边框、宽度和高度等
  改变元素内容，比如文字数量，图片大小等
  改变元素字体大小
  改变浏览器窗口尺寸，比如resize事件发生时
  激活CSS伪类（例如：:hover）
  设置 style 属性的值，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow
  查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 getComputedStyle方法，或者IE里的 currentStyle 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。

  重绘: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。

  如何减少重绘和重排

    (1). CSS

      使用transform代替top;
      使用visibility替换display: none，因为前者只会引起重绘，后者会引发回流
      避免使用table布局，可能很小的一个改动会造成整个table的重新布局
      尽可能在DOM树的最末端改变class，回流是不可避免的，但是可以减少影响，尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点；
      将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘而不是回流

    (2). JavaScript

      (1).避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
      (2).避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
      (3).避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
      (4).对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。


# Web服务器及其组成

# 跨站和跨域的区别
同站：只要两个URL的eTLD+1相同即可，不需要考虑协议和端口 
      eTLD+1 表示有效顶级域名+二级域名，例如taobao.com
同源：URL由协议、域名、端口和路径组成。协议+域名+端口相同则表示同源
跨域：不同域之间相互请求资源 不同域：当协议、子域名、主域名、端口号中任意一个不相同时

# 跨域解决方案
## CORS 跨域资源共享
CORS请求分为两类
### 1.简单请求：
同时满足以下两大条件的属于简单请求
（1）请求方法为HEAD  GET POST
（2）HTTP的头信息不超过以下几种字段
Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type:只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

### 基本流程
1. 如果为简单请求，浏览器会自动在头信息中添加Origin字段，用来说明本次请求来自哪个源
2. 
如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段
    Access-Control-Allow-Origin  服务器用来决定浏览器是否拦截这个响应 *表示接受任意域名的请求
    Access-Control-Allow-Credentials  boolean值，表示是否允许发送Cookie
                                      如果需要拿到浏览器的Cookie,不仅需要添加这个响应头并设为true
                                      还需要在前端设置withCredentials为true
    Access-Control-Expose-Headers  可以指定想要拿到的其他字段
如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应
    头信息则不包含Access-Control-Allow-Origin字段

### 2.非简单请求
  1. 在正式通信之前，增加一次HTTP查询请求，称为"预检"请求
  例如
  OPTIONS / HTTP/1.1
  Origin: 当前地址
  Host: xxx.com
  Access-Control-Request-Method: PUT
  Access-Control-Request-Headers: X-Custom-Header
  --------------------------------------------
    预检请求用的请求方法是OPTIONS,表示这个请求是用来询问服务端是否允许跨域
    头部信息中有(1)关键字段Origin,表示请求来自哪个源
               (2)Access-Control-Request-Method  用来列出浏览器的CORS请求会用到哪些HTTP方法
               (3)Access-Control-Request-Headers   指定浏览器CORS请求会额外发送的头信息字段

  2. 服务器收到预检请求后，检查上述的三个字段，确认允许跨域请求，就可以做出回应
  例如
  HTTP/1.1 200 OK
  Date: Mon, 01 Dec 2008 01:15:39 GMT
  Server: Apache/2.0.61 (Unix)
  Access-Control-Allow-Origin: http://api.bob.com
  Access-Control-Allow-Methods: GET, POST, PUT
  Access-Control-Allow-Headers: X-Custom-Header
  Content-Type: text/html; charset=utf-8
  Content-Encoding: gzip
  Content-Length: 0
  Keep-Alive: timeout=2, max=100
  Connection: Keep-Alive
  Content-Type: text/plain
  --------------------------------------------
    Access-Control-Allow-Origin: 表示可以允许请求的源
    Access-Control-Allow-Methods: 表示允许的请求方法列表
    Access-Control-Allow-Headers: 表示允许发送的请求头字段


  3. 如果服务器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段


## JSONP
  利用script标签没有跨域限制的漏洞

## Nginx-高性能的反向代理服务器



# OSI网络分层模型，五层协议， TCP/IP网络分层模型

    OSI网络分层模型
    (1). 应用层: 文件传输，常用协议http, snmp, ftp; 报文

    (2). 表示层: 数据格式化，代码转换，数据加密;

    (3). 会话层: 建立，解除会话; 

    (4). 传输层: 提供端对端的接口， tcp，udp; 报文段/用户数据报

    (5). 网络层: 为数据包选择路由， ip, icmp; 数据报

    (6). 数据链路层: 传输有地址的帧; （Ethernet, FDDI）帧

    (7). 物理层: 二进制的数据形式在物理媒体上传输数据; 比特

    五层: 
    (1). 物理层
    (2). 数据链路层
    (3). 网络层
    (4). 运输层
    (5). 应用层

    TCP/IP网络分层模型
    (1). 网络接口层
    (2). 网际层IP
    (3). 运输层(TCP或UDP)
    (4). 应用层(Telnet, FTP, SMTP)


# HTTP/1.0 HTTP1.1 HTTP2.0版本之间的差异

1. HTTP 0.9
    1991年,原型版本，功能简陋，只有一个命令GET,只支持纯文本内容，该版本已过时。

2. HTTP 1.0
    1. 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。
    2. 除了GET命令，还引入了POST命令和HEAD命令。
    3. http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
    4. 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。不支持断点续传，也就是说，每次都会传送全部的页面和数据。
    5. 通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）

3. HTTP 1.1
    http1.1是目前最为主流的http协议版本，从1999年发布至今，仍是主流的http协议版本。

    1. 引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置
    2. 引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。
    3. HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。
    4. 支持断点续传，通过使用请求头中的 Range 来实现。
    5. 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
    6. 新增方法：PUT、 PATCH、 OPTIONS、 DELETE。
    
    ### http1.x版本问题

    1. 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。
    2. HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。
    3. http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。

4. HTTP 2.0

    1. 二进制分帧  这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。
    2. 头部压缩  HTTP 1.1版本会出现 「User-Agent、Cookie、Accept、Server、Range」 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。
    3. 多路复用 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。
    4. 服务器推送 允许服务器未经请求，主动向客户端发送资源，即服务器推送。请求优先级 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。














# TCP与UDP的区别

  1. UDP: 无连接; 面向报文，只是报文的搬运工; 不可靠，没有拥塞控制; 高效，头部开销只有8字节; 支持一对一，一对多，多对多，多对一; 适合直播，视频，语音，会议等实时性要求高的

  2. TCP: 面向连接: 传输前需要先连接; 可靠的传输; 流量控制: 发送方不会发送速度过快，超过接收方的处理能力; 拥塞控制: 当网络负载过多时能限制发送方的发送速率; 不能提供延时保障; 不提供最小带宽保障

    TCP协议保证可靠传输的手段

        (1). 应用数据块分割成TCP认为合适发送的数据块;
        (2). TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层;
        (3). 校验和：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。TCP的接收端会丢弃重复的数据.;
        (4). TCP 的接收端会丢弃重复的数据。;
        (5). 流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）;
        (6). 当网络拥塞时，减少数据的发送。;
        (7). ARQ协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。;
        (8). 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

# 其他

1. 进程与线程的区别

    进程: 是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位

    线程: 是进程的一部分，一个没有线程的进程可以被看作是单线程的，线程有时又被称为轻权进程或轻量级进程，也是CPU调度的一个基本单位

    区别: 

    (1). 进程是资源分配的最小单位，线程是程序执行的最小单位(资源调度的最小单位);

    (2). 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段，堆栈段和数据段，这种操作非常昂贵，而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多;

    (3). 线程之间的通信更方便，同一进程下的线程恭喜全局变量，静态变量等数据，而进程之间的通信要以通信的方式(IPC)进行;

    (4). 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间;

2. session, cookie, sessionsotrage, localstorage

    cookie中domain属性
    为了保证安全性，cookie无法设置除当前域名或者其父域名之外的其他domain。
    在此，分为两种情况：
    1.一种是前端范围内的是指cookie，如果网站的域名为，i.xiaohan.com,那么前端cookie的domain只能设置，i.xiaohan.com和其父域名xiaohan.com，如果设置成同级域名如api.xiaohan.com或者子域名api.i.xiaohan.com 那么cookie设置将无效。
    2.同样在服务端上，如果制定你的server服务的域名为server.xiaohan.com那么在服务端生成的cookie的domain只能指定为server.xiaohan.com或者xiaohan.com 其他domain都无法成功设置cookie。



    (1). cookie和session的区别

        a. cookie数据存放在客户端，session数据存放在服务器端;

        b. cookie安全性一般，他人可以通过分析存放在本地的cookie并进行cookie欺骗，在安全性第一的前提下，选择session更优，重要交互信息比如权限等就要放在session中，一般的信息记录放在cookie中;

        c. 单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie而session原则上没有限制;

        d. session会在一定的时间内保存在服务器上，当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie

        e. session运行以来Session ID,而Session ID是存在Cookie中，也就是说，如果浏览器禁用了Cookie，Session也会失效(但是可以通过其他方式实现，比如在url中传递Session ID，也就是地址重写)

    (2). localStorage和sessionStorage的区别

        localStorage和sessionStorage存储数据大小一般为5MB,并且仅在客户端(即浏览器)中保存，不参与和服务器的通信

        其实，localStorage最大容量5M的意思是每一个域名下的localStorage容量是5M，假如现在a.com域名下localstorage存不下了，我们可以使用iframe创建b.com域框架（子页面）用于存储a.com剩下的数据。然后使用postMessage读写数据。

        localStorage生命周期是永久的，除非被清除，否则永久保存，而sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除

    set-cookie: 开始状态管理所使用的Cookie信息    响应首部字段
    Cookie  服务器接收到的 Cookie 信息   请求首部字段

    cookie属性

        name: cookie名称
        value: cookie值
        domain: 即可访问此cookie的域名(不同级有不同限制)
        path: 可访问此cookie的页面路径
        expires/Max-Age: cookie超时时间, 默认为Session
        Size: cookie大小
        http: 即httponly属性, true时只有http请求头会带有此信息, 而不能通过document.cookie来访问, 加以限制，使 Cookie 不能被 JavaScript 脚本访问
        secure: 设置是否只可通过https来传递此条cookie

    怎么避免localstorage存满了怎么办

        (1). 划分域名。各域名下的存储空间由各业务组统一规划使用

        (2). 跨页面传数据：考虑单页应用、优先采用 url 传数据

        (3). 最后的兜底方案：清掉别人的存储

        给每个文件设置时间，当存满后，对localstorage里面的文件进行排序，删除时间最久的插入最新的

3. 跨域问题

    指一个域下的文档或脚本试图去请求另一个域下的资源，由于浏览器同源策略限制而产生

    同源策略: 协议+域名+端口三者相同且必须相同

    (1). JSONP实现跨域

        ```
        function handleResponse(response) {
            console.log(response.data);
        }
        var script = document.createElement("script");
        script.src = "http://example.com/jsonp/getSomething?uid=123&callback=hadleResponse"
        document.body.insertBefore(script, document.body.firstChild);
        /*handleResponse({"data": "hey"})*/


        ```

        动态添加`script`的标签，可控的去请求远端js并执行，这种跨域方式只能进行GET请求

        当我们通过新建一个script标签请求时，后台会根据相应的参数来生成相应的JSON数据。比如说上面这个链接，传递了handleResponse给后台，然后后台根据这个参数再结合数据生成了handleResponse({“data”: “hey”})。

        紧接着，这个返回的JSON数据其实就可以被当成一个js脚本，就是对一个函数的调用。
        由于我们事先已经声明了这么一个回调函数，于是当资源加载进来的时候，直接就对函数进行调用，于是数据当然就能获取到了。

    (2). CORS跨域

        只要同时满足以下两大条件，就属于简单请求。

    （1) 请求方法是以下三种方法之一：

        HEAD
        GET
        POST

    （2）HTTP的头信息不超出以下几种字段：

        Accept
        Accept-Language
        Content-Language
        Last-Event-ID
        Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

        对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个`Origin`字段。`Origin`字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

        如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段，就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

        a. Access-Control-Allow-Origin

            该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

        b. Access-Control-Allow-Credentials

            该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为`true`，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送Cookie，删除该字段即可。另一方面，开发者必须在AJAX请求中打开`withCredentials`属性

        c. Access-Control-Expose-Headers

            该字段可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。

        总的来说，CORS实现跨域的方法就是根据请求头的Origin值和响应头的Access-Control-Request-Headers和Access-Control-Request-Method的值进行比对，通过了就可以请求成功，没通过就请求失败。

    (3). Nginx反向代理接口跨域

        实现思路：通过Nginx配置一个代理服务器（域名与example1相同，端口不同）做跳板机，反向代理访问example2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

# 网络

# 用户输入url到页面展示的流程

    (1). 输入地址: 浏览器会自动在书签和浏览历史中搜寻，如果匹配则自动补全，在chrome中如果地址命中了缓存，会直接调用缓存展示页面;

    (2). 浏览器查询域名的IP地址(发送请求至DNS服务器): 浏览器会在本地寻找是否有匹配的映射，如果有直接使用映射的IP地址，如果没有，浏览器会发送DNS请求DNS服务器，DNS服务器的作用在于根据请求中的域名返回与之对应IP地址;

        DNS查找顺序: 浏览器缓存--> 操作系统缓存--> 本地host文件 --> 路由器缓存--> ISP DNS缓存 --> 顶级DNS服务器/根DNS服务器

        本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问

    (3). 浏览器获取IP地址请求TCP/IP连接，客户端和服务器之间进行三次握手的链接，随后发送HTTP请求:

        三次握手

        第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

        第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

        第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 

        三次握手的原因:
        为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。

    浏览器获取IP地址后会使用一个随机端口发送TCP连接请求，经过层层路由设备进入服务端，建立TCP/IP连接，随后浏览器会发送一个http请求;

    (4). 服务器解析TCP连接解析HTTP请求;

    (5). 服务器返回一个http响应: http响应由三个部分构成: 状态行，响应头，响应正文;

    (6). 浏览器解析html: 构建dom树 => 构建render树 => 布局render树 => 绘制render树;

    (7). 浏览器解析外联js css: 在解析html的过程中如果碰到外联的js脚本,会中断html的解析,等待js脚本下载解析完成后再恢复html的解析流程,构建完dom树,dom样式树,执行脚本后,页面就正确的展示出来了 

    浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。

    JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说同一时间内只能做一件事情，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。这就涉及到事件循环的问题

    (8). 连接结束四次挥手

        第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。

        第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。

        第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。

        第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放

        四次挥手的原因: TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送，之后就会中断这次TCP连接。

# XSS攻击 - 跨站脚本攻击
* XSS 的原理
恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页面时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。

* 类型
    1. 反射型
    攻击者可以直接通过 URL (类似：https://xxx.com/xxx?default=<script>alert(document.cookie)</script>) 注入可执行的脚本代码。
    2. 存储型
    一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。
* 如何防御
    1. CSP(内容安全策略)
        * 设置 HTTP Header 中的 Content-Security-Policy
        * 设置 meta 标签的方式

    2. 转义字符
    3. HttpOnly Cookie

# CSRF攻击 - 跨站请求伪造
# 原内容

4. TCP的三次握手和四次挥手

    三次握手

    第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

    第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

    第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

    三次握手的原因: 为防止已失效的连接请求报文突然又传送到服务端，因而产生错误，防止server端一直等待，浪费资源

    为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”，书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的防止server端一直等待，浪费资源。

    四次挥手

    (1). 第一次挥手: 主机1，设置Seq和ack向主机2发送一个FIN报文段，此时主机1进入FIN_WAIT_1状态，表示主机1没有数据要发送给主机2了;

    (2). 第二次挥手: 主机2收到主机1发送的FIN报文段，向主机1回一个ACK报文段，ACK=seq+1，主机1进入FIN_WAIT_2状态，主机2告诉主机1，同意关闭请求;

    (3). 第三次挥手: 主机2向主机1发送FIN报文段请求关闭连接，同时主机2进入LAST_ACK状态;

    (4). 第四次挥手: 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态，主机2收到主机1的ACK报文段以后，就关闭连接，此时主机1等待2msl后依然没有收到回复，则证明Server端已正常关闭，主机1也可以关闭连接了;

    四次挥手的原因: TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送，之后就会中断这次TCP连接。

5. 什么是HTTP协议
    
    HTTP是一个在计算机世界里专门在两点之间传输文字，图片，音频等超文本数据的约定和规范

6. 常见HTTP请求方法
    
    在HTTP1.0中有三种方法分别是`GET`, `POST`, `HEAD`, `GET`是从指定资源中请求数据，`POST`向指定的资源提交要被处理的数据，`HEAD`类似于`GET`请求但不返回具体内容，只有头部，可检查超链接的有效性和检查网页是否被修改

    HTTP1.1中加入了`PUT`替换或创建指定资源，`DELETE`对指定资源进行删除

    HTTP1.1在请求头中引入了range头域，它允许只请求资源的某个部分，即返回码是206(Partial Content)

    HTTP2.0中加入了`OPTION`用于获取目的资源所支持的通信选项，比如服务器支持的请求方式, `TRACE`: 实现沿通向目标资源的路径的消息环回(loop-back)测试，提供一种实用的debug机制，`connect`为代理服务器准备的

7. `GET`和`POST`的区别

    (1). get参数通过url传递，post放在request body中；

    (2). get请求在url中传递的参数是有长度限制的，而post没有；

    (3). get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息；

    (4). get只能进行url编码，而post支持多种编码方式

8. HTTP2.0与HTTP1.1区别

    (1). HTTP2.0允许多路复用 (通过二进制分帧层实现);

    (2). 首部压缩，在HTTP1中HTTP请求和响应都是由状态行，请求/响应头部，消息主题三部分组成;

    (3). 设置请求的优先级，可以设置让某些重要的数据优先被服务器处理并返回。

9. HTTPS

    加密算法

    (1). 对称加密

        对称加密就是通信的双方都持有同一个密钥，加密和解密都是使用这一个密钥进行的

        优点: 加密和解密的速度快，不会造成性能上太大的损失，尤其是在加密大量数据的情况下

        缺点: 商定加密规则的时候不安全

    (2). 非对称加密

        非对称加密存在两个密钥，一个称为公钥一个称为私钥，既可以使用公钥加密，也可以使用私钥加密，但是使用公钥加密那么就只有私钥才能解密，使用私钥加密就只能使用公钥解密

        优点: 公钥是任何人都可以获取的，经过公钥加密的内容，只有私钥才可以解开

        缺点: 必须保证私钥不能泄露，否则将无加密可言; 非对称加密相对于对称加密而言性能损耗较大，非对称加密还有一个最大的漏洞，中间人攻击

    https = http + tls/ssl

    TLS握手过程

        (1). 客户端发送'client hello' 包含密码信息和随机字符串'client random'等;
        (2). 服务器响应'server hello'包含密码组合和数字证书以及随机字符串'server random等';
        (3). 客户端验证数字证书并从证书种获取公钥，生成下一个随机字符串'premaster secret'并用公钥将其加密;
        (4). 客户端发送加密后的premaster secret给服务器;
        (5). 服务器使用私钥解密获取premaster secret;
        (6). 客户端和服务器双方使用相同的算法，并使用client random, server random和premaster secret生产相同的密钥key，用于后面的对称加密;
        (7). 客户端发送finished;
        (8). 服务器发送finished;;
        (9). 成功简历安全连接，双方使用共同的密钥key对称加密进行安全通信;

    使用数字签名，我们能够鉴别信息的发送者，(私钥加密签名)

10. HTTPS与HTTP的一些区别

    (1). HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费;

    (2). HTTP协议运行在TCP之上，所有的传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都是经过加密的;

    (3). HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不太一样，前者是80，后者是443;

    (4). HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题;

11. DNS

    解析顺序首先从浏览器缓存，操作系统缓存和本地DNS缓存逐级查找，然后从本地DNS服务器，根DNS，顶级DNS以及权威DNS层层递归查询

    不过传统的 DNS 有很多问题(解析慢、更新不及时)，HTTPDNS 通过客户端 SDK 和服务端配合，直接通过 HTTP 调用解析 DNS 的方式，可以绕过传统 DNS 这些缺点，实现智能调度。

    DNS查询的两种方式

    (1). 递归解析;

        局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端

    (2). 迭代解析;

        局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。

12. HTTP缓存

    浏览器缓存是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者子啊次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览

    浏览器缓存过程

    浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；

    下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求；

    服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；

    如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；

    * 策略

    通常浏览器缓存策略分为两种：强缓存（Expires，cache-control）和协商缓存（Last-modified ，Etag），并且缓存策略都是通过设置 HTTP Header 来实现的。

    强制缓存

    response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强制缓存。

    Cache-Control
    当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

    Expires和Cache-Control的区别
    Expires 是http1.0的产物，Cache-Control是http1.1的产物

    两者同时存在的话，Cache-Control优先级高于Expires；

    在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法

    Expires是一个具体的服务器时间，这就导致一个问题，如果客户端时间和服务器时间相差较大，缓存命中与否就不是开发者所期望的。Cache-Control是一个时间段，控制就比较容易

    协商缓存

    ETag和If-None-Match

    这两个要一起说。Etag是上一次加载资源时，服务器返回的response header，是对该资源的一种唯一标识，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存

    Last-Modified和If-Modified-Since

    这两个也要一起说。Last-Modified是该资源文件最后一次更改时间，服务器会在response header里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到request header里的If-Modified-Since里，服务器在接收到后也会做比对，如果相同则命中协商缓存。

    ETag和Last-Modified区别

    在方式上，Etag是对资源的一种唯一标识，而Last-Modified是该资源文件最后一次更改时间

    在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。

    在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。

    在优先级上，服务器校验优先考虑Etag。

13. HTTP状态码

    (1). 1xx (Informational): 收到请求，正在处理

    100 (继续): 请求者应当继续提出请求，服务器返回此代码表示已经收到请求的第一部分，正在等待其余部分;

    101 (切换协议): 请求者已要求服务器切换协议，服务器确认并准备切换;

    (2). 2xx (Successful): 该请求已成功收到，理解并接受

    200 (成功): 服务器完成已成功处理了请求，通常，这表示服务器提供了请求的网页;

    201 (已创建): 请求成功并且服务器创建了新的资源;

    202 (已接受): 服务器已接收请求，但尚未处理;

    203 (非授权信息): 服务器已成功处理了请求，但返回的信息可能来自另一来源;

    204 (无内容): 服务器成功处理了请求，但没有返回任何内容;

    205 (重置内容): 响应执行成功，重置页面(Form表单)，方便用户下次输入;

    206 (部分内容): 服务器成功处理了部分`get`请求;

    (3). 3xx (Redirection): 重定向

    300 (多种选择): 针对请求，服务器可执行多种操作，服务器可根据请求者(user agent)选择一项操作，或提供操作列表供请求者选;

    301 (永久移动): 请求的网页已永久移动到新位置，服务器返回此响应(对`GET`或`HEAD`请求的响应)时，会自动将请求者转到新位置;

    302 (临时移动): 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求;

    303 (查看其他位置): 请求者应当对不同的位置使用单独的`GET`请求来检索响应时，服务器返回此代码;

    304 (未修改): 自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容;

    305 (使用代理): 请求者只能使用代理访问请求的网页，如果服务器返回此响应，还表示请求者应使用代理;

    307 (临时重定向): 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求;

    (4). 4xx (Client Error): 该请求包含错误的语法或不能为完成

    400 (错误请求): 服务器不理解请求的语法;

    401 (未授权): 请求要求身份验证，对于需要登陆的网页，服务器可可能返回此响应;

    403 (禁止): 服务器拒绝请求;

    404 (未找到): 服务器找不到请求的网页;

    405 (方法禁用): 禁用请求中指定的方法;

    406 (不接受): 无法使用请求的内容特性响应请求的网页;

    407 (需要代理授权): 此状态码与401(未授权)类似，但指定请求者应当授权使用代理;

    408 (请求超时): 服务器等候请求时发生超时;

    409 (冲突): 服务器在完成请求时发生冲突，服务器必须在响应中包含有关冲突的信息;

    410 (已删除): 如果请求的资源已永久删除，服务器就会返回此响应;

    411 (需要有效长度): 服务器不接受不含有效内容长度标头字段的请求;

    412 (未满足前提条件): 服务器未满足请求者在请求中设置的其中一个前提条件;

    413 (请求实体过大): 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力;

    414 (请求URL过长): 请求的URL(通常为网址)过长，服务器无法处理;

    415 (不支持的媒体类型): 请求的格式不接受请求页面的支持;

    416 (请求范围不符合要求): 如果页面无法提供请求的范围，则服务器会返回此状态状态码;

    417 (未满足期望值): 服务器未满足"期望"请求标头字段的要求;

    (5). 5xx (Server Error): 服务器错误 504 - 网关超时

    500 (服务器内部错误): 服务器遇到错误，无法完成请求;

    501 (尚未实施): 服务器不具备完成请求的功能。例如服务器无法识别请求方法时可能会返回此代码;

    502 (错误网关): 服务器作为网关或代理，从上游服务器收到无效响应;

    503 (服务不可用): 服务器目前无法使用(由于超载或停机维护)。通常，这只是暂时状态;

    504 (网关超时): 服务器作为网关或代理，但是没有及时从上游服务器收到请求;

    505 (HTTP版本不受支持): 服务器不支持请求中所用的HTTP版本协议;

14. HTTP报文结构

    请求报文: 请求行 (方法字段，URL字段，HTTP协议版本字段)，请求头，空行，请求数据

    响应报文: 响应行(协议版本，状态码以及描述)，响应头，空行，响应体

15. HTTP常用的首部字段

    通用首部字段

        Cache-Control 控制缓存
        Connection 连接管理
        Transfor-Encoding 报文主体的传输编码格式
        Date 创建报文的时间
        Upgrade 升级为其他协议

    请求首部字段

        Host 请求资源所在的服务器 (唯一一个HTTP/1.1规范里要求必须出现的字段)Accept 客户端或者代理能够处理的媒体类型If-Match 比较实体标记 (ETag)If-None-Match 比较实体标记 (ETag)，与 If-Match 相反If-Modified-Since 比较资源更新时间 (Last-Modified)If-Unmodified-Since 比较资源更新时间 (Last-Modified)， 与 If-Modified-Since 相反Range 实体的字节范围请求User-Agent 客户端信息

    响应首部字段

        Accept-Ranges 能接受的字节范围
        Location 命令客户端重定向的 URI
        ETag 能够表示资源唯一资源的字符串
        Server 服务器的信息

    实体首部字段

        Allow 资源可支持 HTTP 请求方法Last-Modified 资源最后修改时间Expires 实体主体过期时间Content-Language 实体资源语言Content-Encoding 实体编码格式Content-Length 实体大小Content-Type 实体媒体类型

16. URL包含哪几个部分

    (1). 协议类型;
    (2). 主机名;
    (3). 端口号;
    (4). 路径;
    (5). 参数(:parameters);
    (6). 查询(?query);
    (7). 信息片段(fragment);

17. 

## 安全

1. CIA三元组
    
    (1). 机密性;
    (2). 完整性;
    (3). 可用性;

2. XSS攻击是如何产生的

    黑客在你的浏览器中插入一段恶意的JavaScript脚本，窃取你的隐私信息，冒充你的身份进行操作，这就是XSS(Cross-Site Scripting, 跨站攻击)

    因为浏览器无法区分脚本是恶意注入的还是正常的内容，它都会执行

3. XSS有哪几种类型
    
    (1). 反射型XSS(非持久型);

        顾名思义，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。

    (2). 基于DOM的XSS;

        目前更流行前后端分离的项目，反射型 XSS 无用武之地。 但这种攻击不需要经过服务器，我们知道，网页本身的 JavaScript 也是可以改变 HTML 的，黑客正是利用这一点来实现插入恶意脚本。

    (3). 存储型XSS(持久型);

        又叫持久型 XSS，顾名思义，黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。

    区别

        反射型的 XSS 的恶意脚本存在 URL 里，存储型 XSS 的恶意代码存在数据库里。

        而基于DOM型的XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，其他两种 XSS 都属于服务端的安全漏洞。

    如何防护

        (1). 一切用户输入皆不可信: 在输出时进行验证;
        (2). 将HTML元素内容，属性以及URL请求参数，CSS值进行编码;
        (3). 当编码影响业务时，使用白名单规则进行检测和过滤;
        (4). 使用W3C提出的CSP(Content Security Policy, 内容安全策略),定义域名白名单;
        (5). 设置Cookie的HTTpOnly属性;

4. CSRF攻击

    CSRF 英文全称是 Cross-site request forgery，又称为“跨站请求伪造”。
    顾名思义，CSRF 攻击就是黑客引诱用户打开黑客的网站，利用用户的登陆状态发起跨站请求。
    降维解释：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。
    利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证， 达到冒充用户对被攻击的网站执行某项操作的目的。

    如何实现

        (1). 最容易实现的是Get请求，一般进入黑客网站后，可以通过设置img的src属性来自动发起请求
        (2). 在黑客网站中，构造隐藏表单来自动发起post请求
        (3). 通过引诱链接诱惑用户点击触发请求，利用a标签的href

    与XSS区别

        CSRF攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击

        CSRF 攻击成本也比 XSS 低，用户每天都要访问大量网页，无法确认每一个网页的合法性， 从用户角度来说，无法彻底防止 CSRF 攻击。

    如何防范

        针对实际情况，设置关键 Cookie 的 SameSite 属性为 Strict 或 Lax服务端验证请求来源站点(Referer、Origin)使用 CSRF Token，服务端随机生成返回给浏览器的 Token，每一次请求都会携带不同的 CSRF Token加入二次验证(独立的支付密码)







