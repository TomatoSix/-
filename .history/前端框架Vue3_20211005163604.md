
# setup 
1. 组件中所用到的数据、方法等等，均配置在setup中
```js
setup() {
  let name='张三'
  let age = 18

  function sayHello() {
    alert(name, age)
  }

  return {
    name, age, sayHello
  }
}
```

# ref函数
1. 定义一个响应式数据
创建一个包含响应式数据的引用对象RefImpl(reference implement) 引用实现
2. 
    * ref 把基本数据类型的变量'name'加工为引用对象，借助Object.defineProperty()中的get和set完成的
    * 把对象'job'加工为Proxy代理对象，借助reactive函数
```js
setup() {
  let name = ref('张三')
  let age = ref(18)

  function changeInfo() {
    console.log(name)  // RefImpl {_rawValue: '张三'，value: '张三'} 对象
  }

  return {
    name, age, changeInfo
  }
}
```
3. 操作数据需要 ×××.value 
```js
setup() {
  let name = ref('张三')
  let age = ref(18)
  let job = ref({
    type: '前端工程师',
    salary: '30k'
  })

  function changeInfo() {
    // 修改name 和 age job
    name.value = "李四"
    age.value = 48
    jon.value.type = '测试'
  }

  return {
    name, age, changeInfo
  }
}
```

# reactive函数
作用: 定义一个对象类型的响应式数据(基本数据类型不能用，只能用ref)
const 代理对象 = reactive(源对象) 接受一个对象，返回一个代理对象
操作数据可以直接修改
```js
setup() {
  let name = ref('张三')
  let age = ref(18)
  let job = reactive({
    type: '前端工程师',
    salary: '30k'
  })
  let hobby = reactive(['你好','我们','认识吗'])

  function changeInfo() {
    // 修改name 和 age job
    name.value = "李四"
    age.value = 48
    job.type = '测试'
    hobby[2] = '不认识'
  }

  return {
    name, age, changeInfo
  }
}
```

# Vue3 响应式原理

## vue2 响应式原理
```js
let person = {
  name: '张三',
  age: 18
}
let p = {}
Object.defineProperty(p, 'name', {
  get() { // 有人读取name时调用
    return person.name
  },
  set(value) {  //有人修改name时调用
    person.name = value
  }
})
Object.defineProperty(p, 'age', {
  get() {  
    return person.age
  },
  set(value) {
    person.age = value
  }
})
```

## vue3 响应式原理
1. proxy
对p(代理对象)进行增删改查会反映到person(目标对象)上
```js
let person = {
  name: '张三',
  age: 18
}
// p 代理对象 第一个参数person 目标对象  第二个参数{} 处理程序对象
let p = new Proxy(person, {
  // 读取属性时调用
  // 参数 target目标对象 propName属性
  get(target, propName) {
    console.log(`有人读取了p身上的${propName}属性`)
    return target[propName]
  },
  // 修改、新增属性时调用
  // 参数 target 目标对象 propName 属性  value 值
  set(target, propName, value) {
    console.log(`有人修改了p身上的${propName}属性`)
    target[propName] = value
  },
  // 删除属性时调用
  deleteProperty(target, propName) {
    console.log(`有人删除了p身上的${propName}属性`)
    return delete target[propName]
  }
})
```
2. Reflect 反射
```js
// 修改对象可以用Reflect
let obj = {
  a: 1,
  b: 2
}
Reflect.get(obj,'a') //1
// obj {a: 1, b: 2}
Reflect.set(obj,'a', 666) // true
// obj {a: 666, b: 2}
Reflect.deleteProperty(obj,'a') // true
// obj { b: 2}
```
* 如果使用Object.defineProperty,追加属性如果重名可能会报错，导致整个代码瘫痪，而Reflect不会
```js
let obj = {a: 1, b: 2}
Object.defineProperty(obj, 'c', {
  get() {
    return 3
  }
})
Object.defineProperty(obj, 'c', {
  get() {
    return 4  // Uncaught TypeError
  }
})
```
* Reflect 可以输出对象x1 查看代码有没有执行成功
```js
// 修改对象可以用Reflect
let obj = {
  a: 1,
  b: 2
}
const x1 = Reflect.get(obj,'a') //1
// x1 true
Reflect.set(obj,'a', 666) // true
Reflect.deleteProperty(obj,'a') // true
```



3. vue3 响应式原理
```js
let person = {
  name: '张三',
  age: 18
}
// p 代理对象 第一个参数person 目标对象  第二个参数{} 处理程序对象
let p = new Proxy(person, {
  // 读取属性时调用
  // 参数 target目标对象 propName属性
  get(target, propName) {
    console.log(`有人读取了p身上的${propName}属性`)
    return target[propName]
  },
  // 修改、新增属性时调用
  // 参数 target 目标对象 propName 属性  value 值
  set(target, propName, value) {
    console.log(`有人修改了p身上的${propName}属性`)
    target[propName] = value
  },
  // 删除属性时调用
  deleteProperty(target, propName) {
    console.log(`有人删除了p身上的${propName}属性`)
    return delete target[propName]
  }
})
```
