
# setup 
1. 组件中所用到的数据、方法等等，均配置在setup中
```js
setup() {
  let name='张三'
  let age = 18

  function sayHello() {
    alert(name, age)
  }

  return {
    name, age, sayHello
  }
}
```

# ref函数
1. 定义一个响应式数据
创建一个包含响应式数据的引用对象RefImpl(reference implement) 引用实现
2. 
    * ref 把基本数据类型的变量'name'加工为引用对象，借助Object.defineProperty()中的get和set完成的
    * 把对象'job'加工为Proxy代理对象，借助reactive函数
```js
setup() {
  let name = ref('张三')
  let age = ref(18)

  function changeInfo() {
    console.log(name)  // RefImpl {_rawValue: '张三'，value: '张三'} 对象
  }

  return {
    name, age, changeInfo
  }
}
```
3. 操作数据需要 ×××.value 
```js
setup() {
  let name = ref('张三')
  let age = ref(18)
  let job = ref({
    type: '前端工程师',
    salary: '30k'
  })

  function changeInfo() {
    // 修改name 和 age job
    name.value = "李四"
    age.value = 48
    jon.value.type = '测试'
  }

  return {
    name, age, changeInfo
  }
}
```

# reactive函数
作用: 定义一个对象类型的响应式数据(基本数据类型不能用，只能用ref)
const 代理对象 = reactive(源对象) 接受一个对象，返回一个代理对象
操作数据可以直接修改
```js
setup() {
  let name = ref('张三')
  let age = ref(18)
  let job = reactive({
    type: '前端工程师',
    salary: '30k'
  })
  let hobby = reactive(['你好','我们','认识吗'])

  function changeInfo() {
    // 修改name 和 age job
    name.value = "李四"
    age.value = 48
    job.type = '测试'
    hobby[2] = '不认识'
  }

  return {
    name, age, changeInfo
  }
}
```

# Vue3 响应式原理
## vue2 响应式原理
```js
let person = {
  name: '张三',
  age: 18
}
let p = {}
Object.defineProperty(p, 'name', {
  get() { // 有人读取name时调用
    return person.name
  },
  set(value) {  //有人修改name时调用
    person.name = value
  }
})
Object.defineProperty(p, 'age', {
  get() {  
    return person.age
  },
  set(value) {
    person.age = value
  }
})
```
## vue3为什么要使用proxy?
1. Object.defineProperty无法监听数组的变化 
   proxy可以直接监听数组的变化；
2. Object.defineProperty只能劫持对象的属性，因此需要对每个对象的每个属性进行遍历
3. proxy可以监听对象而非属性.它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。
Proxy直接可以劫持整个对象,并返回一个新对象。
## vue3 响应式原理
- 通过Proxy代理：拦截对象中任意属性的变化，包括：属性值的读写、属性得添加、属性的删除等等
- 通过Reflect反射： 对源对象的属性进行操作
1. proxy
    对p(代理对象)进行增删改查会反映到person(目标对象)上
    ```js
    let person = {
      name: '张三',
      age: 18
    }
    // p 代理对象 第一个参数person 目标对象  第二个参数{} 处理程序对象
    let p = new Proxy(person, {
      // 读取属性时调用
      // 参数 target目标对象 propName属性
      get(target, propName) {
        console.log(`有人读取了p身上的${propName}属性`)
        return target[propName]
      },
      // 修改、新增属性时调用
      // 参数 target 目标对象 propName 属性  value 值
      set(target, propName, value) {
        console.log(`有人修改了p身上的${propName}属性`)
        target[propName] = value
      },
      // 删除属性时调用
      deleteProperty(target, propName) {
        console.log(`有人删除了p身上的${propName}属性`)
        return delete target[propName]
      }
    })
    ```
2. Reflect 反射
    ```js
    // 修改对象可以用Reflect
    let obj = {
      a: 1,
      b: 2
    }
    Reflect.get(obj,'a') //1
    // obj {a: 1, b: 2}
    Reflect.set(obj,'a', 666) // true
    // obj {a: 666, b: 2}
    Reflect.deleteProperty(obj,'a') // true
    // obj { b: 2}
    ```
    * 如果使用Object.defineProperty,追加属性如果重名可能会报错，导致整个代码瘫痪，而Reflect不会
    ```js
    let obj = {a: 1, b: 2}
    Object.defineProperty(obj, 'c', {
      get() {
        return 3
      }
    })
    Object.defineProperty(obj, 'c', {
      get() {
        return 4  // Uncaught TypeError
      }
    })
    ```
    * Reflect 可以输出对象x1 查看代码有没有执行成功
    ```js
    // 修改对象可以用Reflect
    let obj = {
      a: 1,
      b: 2
    }
    const x1 = Reflect.defineProperty(obj, 'c', {
      get() {
        return 3
      }
    })
    // x1 true 
    const x2 = Reflect.defineProperty(obj, 'c', {
      get() {
        return 4  
      }
    })
    //x2 false
    ```
3. vue3 响应式原理
      ```js
      let person = {
        name: '张三',
        age: 18
      }
      // p 代理对象 第一个参数person 目标对象  第二个参数{} 处理程序对象
      let p = new Proxy(person, {
        // 读取属性时调用
        // 参数 target目标对象 propName属性
        get(target, propName) {
          console.log(`有人读取了p身上的${propName}属性`)
          return  Reflect.get(target, propName)
        },
        // 修改、新增属性时调用
        // 参数 target 目标对象 propName 属性  value 值
        set(target, propName, value) {
          console.log(`有人修改了p身上的${propName}属性`)
          Reflect.set(target, propName, value)
        },
        // 删除属性时调用
        deleteProperty(target, propName) {
          console.log(`有人删除了p身上的${propName}属性`)
          return Reflect.deleteProperty(target, propName)
        }
      })
      ```

# ref 与 reactive对比
1. 从定义数据角度对比
ref用来定义：基本数据类型， 对象数据类型(它内部会自动通过reactive转为代理对象)
reactive用来定义： 对象（或数组）类型数据
2. 从原理角度对比
ref通过Object.defineProperty()的get 和 set 来实现响应式(数据劫持)
reactive通过使用Proxy来实现响应式(数据劫持)，并通过Reflect操作源对象内部的数据
3. 从使用角度对比：
ref定义的数据： 操作数据需要×××.value， 读取数据时模板中直接读取不需要.value
reactive定义的数据：操作数据与读取数据均不需要.value