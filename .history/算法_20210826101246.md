# 排序
https://juejin.cn/post/6856546833025237006#heading-9
## 分类
* 按排序依据的原则
插入排序： 直接插入排序、希尔排序
交换排序： 冒泡排序、快速排序
选择排序:  直接选择排序、堆排序
归并排序： 2-录归并排序
基数排序

* 根据排序的稳定性：关键字相同的记录在排序过程中是否保持前后次序不变
不变则为稳定排序，变化则为不稳定排序

稳定排序： 直接插入排序、冒泡排序、归并排序、计数排序
不稳定排序：希尔排序、直接选择排序、堆排序、快速排序

* 时间复杂度

1. 冒泡排序-稳定
```
let bubbleSort = function(arr, flag = 0) {
  let len = arr.length

  // 最外层for循环表示循环次数，需循环len - 1次
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {
      //比较相邻两者之间的关系大小
      if (arr[j] > arr[j+1]) {
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
      }
    }
  }
  return flag ? arr.reverse() : arr

  let arr = [2,10,8,3,0,5]
  console.log(bubbleSort(arr, 1)) //flag 0-正序 1-倒序
}
```

2. 快速排序- 不稳定
基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
```
let quickSort = function(arr) {
  // 递归出口就是数组长度为1
  if (arr.length <= 1) return arr
  // 获取中间值的索引，使用Math.floor向下取整
  let index = Math.floor(arr.length / 2)
  // 使用splice截取中间值
  let pivot = arr.splice(index,1)[0], left = [], right = []
  for (let i = 0; i < arr.length; i++) {
    // 如果中间值更大，则将arr[i] push左边数组
    if (pivot > arr[i]) {
      left.push(arr[i])
    } else {
      // 否则，将arr[i] push右边数组
      right.push(arr[i])
    }
  }
  return quickSort(left).concat([pivot], quickSort(right))
}
```

3. 直接插入排序-稳定
基本原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
```
let insertSort = function(arr) {
  // 取数组长度
  let len = arr.length

  for (let i = 0; i < len; i++) {
    let preIndex = i -1, cur = arr[[i]
    // 若前面的数字比当前值cur大，则前面的数字向后移动一位，继续向前一位与当前值比较
    while (preIndex >= 0 && arr[preIndex] > cur) {
      arr[preIndex + 1] = arr[preIndex]
      preIndex--
    }
    // 如果小，则放入当前数字的后面
    arr[preIndex + 1] = cur
  }
  return arr
}
```

4. 归并排序

5. 计数排序

6. 希尔排序

7. 直接选择排序
基本原理：每一次从待排序的数组元素中选择最大的一个元素作为首元素，直到排完为止
```
let selectSort = function (arr, flag = 0) {    
  let len = arr.length,  temp = 0;    
  // 一共需要排序len-1次    
  for (let i = 0; i < len - 1; i++) {        
    temp = i;  
    // 取出后续数字中最小数字的索引      
    for (let j = i + 1; j < len; j++) {            
      if (arr[j] < arr[temp])                
      temp = j;        
    }        
    // 每一趟保证第i位为最小值        
    if (temp !== i) {            
      [arr[i], arr[temp]] = [arr[temp], arr[i]]        
    }    
  }    
  return flag ? arr.reverse() : arr}

  let arr = [2, 9, 6, 7, 4, 3, 1, 7, 0, -1, -2]
  console.log(selectSort(arr, 1))

```

8. 堆排序






# 二叉树 
## 二叉树的深度
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    return !root ? 0 : Math.max(maxDepth(root.left),maxDepth(root.right))+1
};

## 二叉树的遍历

DLR--前序遍历-中左右（根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面 ）

LDR--中序遍历-左中右（根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）

LRD--后序遍历-左右中（根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面）


### 二叉树的先序遍历

1. 非递归实现
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    const result = []
    const stack = []
    let current = root
    while (current || stack.length > 0){
        while (current){
            result.push(current.val)
            stack.push(current)
            current = current.left
        }
        current = stack.pop()
        current = current.right
    }
    return result
};

2. 递归实现
var preorderTraversal = function(root，array = []) {
    if (root){
      array.push(root.val)
      preorderTraversal(root.left, array)
      preorderTraversal(root.right, array)
    }
    return array
};


### 二叉树的后序遍历

1. 非递归实现
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if(root == null) return [];
    let stack = [], res = [];
    let visited = new Set();
    let p = root;
    while(stack.length || p) {
        while(p) {
            stack.push(p);
            p = p.left;
        }
        let node = stack[stack.length - 1];
        // 如果右孩子存在，而且右孩子未被访问
        if(node.right && !visited.has(node.right)) {
            p = node.right;
            visited.add(node.right);
        } else {
            res.push(node.val);
            stack.pop();
        }
    }
    return res;
};

2. 递归实现
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    let arr = [];
    let traverse = (root) => {
      if(root == null) return;
      traverse(root.left);
      traverse(root.right);
      arr.push(root.val);
    }
    traverse(root);
    return arr
};




