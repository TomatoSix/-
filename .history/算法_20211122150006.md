# 和为s的连续正数序列
```javascript
/**
 * @param {number} target
 * @return {number[][]}
 */
// 利用滑动窗口
var findContinuousSequence = function(target) {
    let result = []

    let i=1,j=1,sum=0  // i表示左指针，j表示右指针
    while (i <= Math.floor(target/2)) {
        if (sum < target) {
            sum += j
            j++
        } else if (sum > target) {
            sum -=i
            i++
        } else {
            const arr=[]
            for (let k=i; k<j; k++) {
                arr.push(k)
            }
            result.push(arr)
            sum -= i
            i++
        }
    }
    return result
};
```

# 最长回文子串
```javascript
var longestPalindrome = function(s) {
    if (s.length < 2) return s

    let res = ''
    for (let i=0; i<s.length; i++) {
        helper(i,i);
        helper(i,i+1);
    }

    function helper(m,n) {
        while (m>=0 && n<s.length && s[n] === s[m]) {
            m--;
            n++
        }

        if (n-m-1 > res.length) {
            res = s.slice(m+1, n)
        } 
    }
    return res
}
```

# 二分查找
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left = 0, right = nums.length-1
    while (left <= right) {
        let midIndex = Math.floor((right - left)/2) + left
        let mid = nums[midIndex]
        if (mid === target) {
            return midIndex
        } else if(mid < target) {
            left = midIndex + 1
        } else {
            right = midIndex -1
        }
    }
    return -1
};
```

// 最小路径和
```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var minPathSum = function(grid) {
    if (grid.length === 0 || grid[0].length === 0) return 0
    let rows=grid.length, columns=grid[0].length
    // 定义二维数组
    const dp = new Array(rows)
    for (let i=0; i<rows; i++) {
        dp[i] = new Array(columns)
    }
    dp[0][0] = grid[0][0]
    for (let i=1; i<rows; i++) {
        dp[i][0] = dp[i-1][0] + grid[i][0]
    }
    for (let j=1; j<columns; j++) {
        dp[0][j] = dp[0][j-1] + grid[0][j]
    }

    for (let i=1; i<rows; i++) {
        for (let j=1; j<columns; j++) {
            dp[i][j] = Math.min(dp[i][j-1], dp[i-1][j]) + grid[i][j]
        }
    }

    return dp[rows-1][columns-1]
};
```

# 排序
https://juejin.cn/post/6856546833025237006#heading-9
## 分类
* 按排序依据的原则
插入排序： 直接插入排序、希尔排序
交换排序： 冒泡排序、快速排序
选择排序:  直接选择排序、堆排序
归并排序： 2-录归并排序
基数排序

* 根据排序的稳定性：关键字相同的记录在排序过程中是否保持前后次序不变
不变则为稳定排序，变化则为不稳定排序

稳定排序： 直接插入排序、冒泡排序、归并排序、计数排序
不稳定排序：希尔排序、直接选择排序、堆排序、快速排序

* 时间复杂度

1. 冒泡排序-稳定 O(n*n)
    ```javascript
    let bubbleSort = function(arr, flag = 0) {
      let len = arr.length

      // 最外层for循环表示循环次数，需循环len - 1次
      for (let i = 0; i < len - 1; i++) {
        for (let j = 0; j < len - 1 - i; j++) {
          //比较相邻两者之间的关系大小
          if (arr[j] > arr[j+1]) {
            [arr[j], arr[j+1]] = [arr[j+1], arr[j]]
          }
        }
      }
      return flag ? arr.reverse() : arr
    }
    let arr = [2,10,8,3,0,5]
    console.log(bubbleSort(arr, 1)) //flag 0-正序 1-倒序
    ```

2. 快速排序- 不稳定
    基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。
    * 方法一
    ```javascript
    let quickSort = function(arr) {
        // 递归出口就是数组长度为1
        if (arr.length <= 1) return arr
        // 获取中间值的索引，使用Math.floor向下取整
        let index = Math.floor(arr.length / 2)
        // 使用splice截取中间值
        let pivot = arr.splice(index,1)[0], left = [], right = []
        for (let i = 0; i < arr.length; i++) {
        // 如果中间值更大，则将arr[i] push左边数组
        if (pivot > arr[i]) {
            left.push(arr[i])
        } else {
            // 否则，将arr[i] push右边数组
            right.push(arr[i])
        }
        }
        return quickSort(left).concat([pivot], quickSort(right))
    }
    ```
    * 方法二
    ```javascript
    function quickSort(array) {
        if (array.length < 2) return array
        let pivot = array[array.length - 1]
        let left = array.filter((item, index) => item <= pivot && index !== array.length -1)
        let right = array.filter(item => item > pivot)
        return [...quickSort(left), pivot, ...quickSort(right)]
    }
    ```


3. 直接插入排序-稳定
    基本原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
    ```javascript
    let insertSort = function(arr) {
      // 取数组长度
      let len = arr.length

      for (let i = 1; i < len; i++) {
        // cur 表示当前要插入比较的元素
        let curValue = arr[i]
        let j = i-1
        // 若前面的数字比当前值cur大，则前面的数字向后移动一位，继续向前一位与当前值比较
        // preIndex >= 0 是为了保证第一个元素认为被排序
        while (j >= 0 && curValue < arr[j]) {
          arr[j + 1] = arr[j]
          j--
        }
        // 如果小，则放入当前数字的后面
        arr[j + 1] = curValue
      }
      return arr
    }
    ```


4. 归并排序

    归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后 将数组排序合并，最终合并为排序好的数组。

    ```js
    function merge(left, right) {
        let result = []
        let i = 0, j = 0
        while(i < left.length && j < right.length) {
            if (left[i] <= right[j]) {
            result.push(left[i++])
            } else {
            result.push(right[j++])
            }
        }
        if (i < left.length) {
            result.push(...left.slice(i))
        } else {
            result.push(...right.slice(j))
        }
        return result
    }

    function mergeSort(array) {
        if (array.length < 2) {
            return array
        }
        let m = Math.floor(array.length / 2)
        let left = mergeSort(array.slice(0, m))
        let right = mergeSort(array.slice(m))
        return merge(left, right)
    } 

    let arr = [1,8,9,5,4,3,6,2]
    console.log(mergeSort(arr));

    ```

5. 计数排序
    所谓“计数”，就是数一数，统计每个元素重复出现的次数。
    ```js
    function countingSort(arr) {
        let min = Infinity
        for (let v of arr) {
            if (v < min) {
                min = v
            }
        }
        let counts = []
        for (let v of arr) {
            counts[v-min] = (counts[v-min] || 0) + 1
        }
        let index = 0 
        for (let i = 0; i < counts.length; i++) {
            let count = counts[i]
            while(count > 0) {
                arr[index] = i + min
                count--
                index++
            }
        }
        return arr
    }
    ```

6. 希尔排序
    通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。
    ```js
    function shellSort(arr) {
        let len = arr.length;
        // 初始步数
        let gap = parseInt(len / 2);
        // 逐渐缩小步数
        while (gap) {
            // 从第gap个元素开始遍历
            for (let i = gap; i < len; i++) {
                // 逐步其和前面其他的组成员进行比较和交换
                for (let j = i - gap; j >= 0; j -= gap) {
                    if (arr[j] > arr[j + gap]) {
                        [arr[j], arr[j + gap]] = [arr[j + gap], arr[j]];
                    } else {
                        break;
                    }
                }
            }
            gap = parseInt(gap / 2);
        }
        return arr
    }
    ```

7. 直接选择排序 - 不稳定 - O(n*n)

    ```javascript
    // 基本原理：每一次从待排序的数组元素中选择最大的一个元素作为首元素，直到排完为止
    let selectSort = function (arr) {    
      let len = arr.length,curMinIndex= 0;    
      // 一共需要排序len-1次, 即循环次数
      for (let i = 0; i < len - 1; i++) {        
        curMinIndex= i;  
        // 取出后续数字中最小数字的索引      
        for (let j = i + 1 ; j < len; j++) {            
          if (arr[j] < arr[curMinIndex]) {
            curMinIndex= j;        
          }             
        }        
        // 每一趟保证第i位为最小值, 此时的temp为后续最小数字的索引                    
        [arr[i], arr[curMinIndex]] = [arr[curMinIndex], arr[i]]        
      }    
      return arr
    }
      let arr = [2, 9, 6, 7, 4, 3, 1, 7, 0, -1, -2]
      console.log(selectSort(arr))
    ```

8. 堆排序
https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/xie-gei-qian-duan-tong-xue-de-ti-jie-yi-kt5p2/

    ```javascript
    /**
     * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
    // 整个流程就是上浮下沉
    var findKthLargest = function(nums, k) {
      let heapSize=nums.length
        buildMaxHeap(nums,heapSize) // 构建好了一个大顶堆
        // 进行下沉 大顶堆是最大元素下沉到末尾
        for(let i=nums.length-1;i>=nums.length-k+1;i--){
            swap(nums,0,i)
            --heapSize // 下沉后的元素不参与到大顶堆的调整
            // 重新调整大顶堆
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0]
      // 自下而上构建一颗大顶堆
      function buildMaxHeap(nums,heapSize){
        for(let i=Math.floor(heapSize/2)-1;i>=0;i--){
            maxHeapify(nums,i,heapSize)
        }
      }
      // 从左向右，自上而下的调整节点
      function maxHeapify(nums,i,heapSize){
          let l=i*2+1
          let r=i*2+2
          let largest=i
          if(l < heapSize && nums[l] > nums[largest]){
              largest=l
          }
          if(r < heapSize && nums[r] > nums[largest]){
              largest=r
          }
          if(largest!==i){
              swap(nums,i,largest) // 进行节点调整
              // 继续调整下面的非叶子节点
              maxHeapify(nums,largest,heapSize)
          }
      }
      function swap(a,  i,  j){
          let temp = a[i];
          a[i] = a[j];
          a[j] = temp;
      }
    };

    ```




# 二叉树 
## 二叉树的深度
```javascript

/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    return !root ? 0 : Math.max(maxDepth(root.left),maxDepth(root.right))+1
};
```

## 二叉树的遍历

DLR--前序遍历-中左右（根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面 ）

LDR--中序遍历-左中右（根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）

LRD--后序遍历-左右中（根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面）


### 二叉树的先序遍历

1. 非递归实现
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let res = []
    let stack = []
    if (root) stack.push(root)
    while (stack.length > 0) {
        let node = stack.pop()
        res.push(node.val)
        if (node.right) stack.push(node.right)
        if (node.left) stack.push(node.left)
    }
    return res
};
```


2. 递归实现
```javascript
var preorderTraversal = function(root, array = []) {
    if (root){
      array.push(root.val)
      preorderTraversal(root.left, array)
      preorderTraversal(root.right, array)
    }
    return array
};


var preorderTraversal = function(root) {
    let res = []

    var preorder = function(root)  {
        if (!root) return
        res.push(root.val)
        preorder(root.left)
        preorder(root.right)
    }
    preorder(root)
    return res
};
```

### 二叉树的中序遍历

1. 非递归实现
```javascript

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let res = []
    let stack = []
    let cur = root
    while(stack.length || cur) {
        if (cur) {
            stack.push(cur)
            cur = cur.left
        } else {
            cur = stack.pop()
            res.push(cur.val)
            cur = cur.right
        }
    }
    return res
};
```
2. 递归实现
```javascript

/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    let res = []
    var inorder = function(root) {
        if (root) {
            inorder(root.left)
            res.push(root.val)
            inorder(root.right)
        }
    }
    inorder(root)
    return res
};
```


### 二叉树的后序遍历

1. 非递归遍历
```js
const inorderTraversal = (root) => {
    if(!root) return [];
  const res = [];
  const stack = [];
  while(root || stack.length){
      while(root){
          stack.push(root)
          root = root.left;
      }
     root = stack.pop();
     res.push(root.val);
     root = root.right;
  }
  return res;
};

// 方法二
var postorderTraversal = function(root) {
    let res = []
    let stack = []
    if (!root) return res
    stack.push(root)
    let cur = null
    while (stack.length) {
        cur = stack.pop()
        res.push(cur.val)
        if (cur.left) stack.push(cur.left)
        if (cur.right) stack.push(cur.right)
    }
    return res.reverse()
};
```




### 二叉树的层序遍历
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    const res = []
    if (!root) return res

    let seq = []
    seq.push(root)

    while (seq.length !== 0) {
        let len = seq.length
        res.push([])

        for (let i=1; i<=len; i++) {
            let node = seq.shift()
            res[res.length-1].push(node.val)
            if (node.left) seq.push(node.left)
            if (node.right) seq.push(node.right)
        }
    }

    return res
};

// 二叉树的锯齿形层序遍历
var zigzagLevelOrder = function(root) {
    if (!root) return []
    let res = []
    let seq = []
    seq.push(root)
    let flag = true
    while (seq.length) {
        let len = seq.length
        res.push([])
        for (let i=1; i<=len; i++) {
            let node = seq.shift()
            if (flag) {
                res[res.length-1].push(node.val)
            } else {
                res[res.length-1].unshift(node.val)
            }
            if (node.left) seq.push(node.left)
            if (node.right) seq.push(node.right)
        }
        flag = !flag
    }
    return res
};
```
### N叉树

1. N叉树的层序遍历
```js
var levelOrder = function(root) {
    if (!root) return []
    let res = []
    let seq = []
    seq.push(root)
    while (seq.length) {
        let len = seq.length
        let curArr = []
        while (len--) {
            let node = seq.shift()
            curArr.push(node.val)
            for (let item of node.children) {
                if (item) seq.push(item)
            }
        }
        res.push(curArr)
    }
    return res
};
```
2. N叉树的前序遍历
```js
// 递归
/**
 * // Definition for a Node.
 * function Node(val, children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node|null} root
 * @return {number[]}
 */
var preorder = function(root) {
    let res = []
    var preCheck = function(root) {
        if (root) {
            res.push(root.val)
            for (let item of root.children) {
                preCheck(item)
            }
        }
    }
    preCheck(root)
    return res
};
```

3. N叉树的后序遍历
```js
// 递归
var postorder = function(root) {
    let res = []
    var postCheck = function (node) {
        if (node) {
            for (let i=0; i<node.children.length; i++) {
                postCheck(node.children[i])
            }
            res.push(node.val)
        }
    }
    postCheck(root)
    return res
};
```


## 确定一棵二叉树
```js
// 前序和中序确定一棵二叉树
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function(preorder, inorder) {
    if (!preorder.length) return null

    let root = new TreeNode(preorder[0])

    let index = inorder.findIndex(item => item === root.val)

    root.left = buildTree(preorder.slice(1, index+1), inorder.slice(0, index))
    root.right = buildTree(preorder.slice(index+1, preorder.length), inorder.slice(index+1, preorder.length))
    return root

};
```

```js
// 后序和中序确定一棵二叉树
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {

    if (!postorder.length) return null

    let root = new TreeNode(postorder[postorder.length - 1])

    let index = inorder.findIndex( item => item === root.val)

    root.left =  buildTree(inorder.slice(0, index), postorder.slice(0, index))
    root.right = buildTree(inorder.slice(index+1, index.length), postorder.slice(index, postorder.length-1))
    return root
};
```


## 最大二叉树
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function(nums) {
  if(nums.length==0)
    return null
  var big=Math.max(...nums)
  var root=new TreeNode(big)
  root.left=constructMaximumBinaryTree(nums.slice(0,nums.indexOf(big)))
  root.right=constructMaximumBinaryTree(nums.slice(nums.indexOf(big)+1))
  return root
};
```

## 是否为对称二叉树
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {

    var check = function(left, right) {
        if (!left && !right) return true
        if (!left || !right) return false
        return left.val === right.val && check(left.left, right.right) && check(left.right, right.left)
    }
    return check(root, root)
    
};
```




## 二叉树的最小深度和最大深度
```js
// 最小深度
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    var getDepth = function(root) {
        if (!root) return 0
        if (!root.left && !root.right) return 1
        if (!root.left) return 1+getDepth(root.right)
        if (!root.right) return 1+ getDepth(root.left)
        return 1+Math.min(getDepth(root.left), getDepth(root.right))
    }
    return getDepth(root)
};
```

```js
// 最大深度
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {

    var getDepth = function (root) {
        if (!root) return 0
        return 1 + Math.max(getDepth(root.left), getDepth(root.right))
    }
    return getDepth(root)
};
```







## 合并二叉树
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function(root1, root2) {
    var preOrder = function(root1, root2) {
        if (!root1 && !root2) return null
        if (!root1) return root2
        if (!root2) return root1
        root1.val += root2.val
        root1.left = mergeTrees(root1.left, root2.left)
        root1.right = mergeTrees(root1.right, root2.right)
        return root1
    }
    return preOrder(root1, root2)
   
};
```
## 完全二叉树的节点个数
层序遍历


## 二叉树的所有路径
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function(root) {

    if (!root) return []
    let res = []

    var getPath = function(node, curPath) {
      // 确定终止条件，到叶子结点就终止
        if (!node.left && !node.right) {
            curPath += node.val
            res.push(curPath)
            return 
        }

        curPath += node.val + '->'

        if (node.left) getPath(node.left, curPath)
        if (node.right) getPath(node.right, curPath)
    }
    getPath(root, '')
    return res
};
```





## 二叉搜索树中的搜索
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var searchBST = function(root, val) {
    if (!root || root.val === val) {
        return root
    }
    if (root.val < val) {
        return searchBST(root.right,val)
    }
    if (root.val > val) {
        return searchBST(root.left, val)
    }
    // return null
};
```

## 左叶子之和
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
    if (!root) return null
    let sum = 0
    let seq = []
    seq.push(root)

    while(seq.length) {
        let len = seq.length
        for (let i=1; i<=len ;i++) {
            let node = seq.shift()
            if (node.left && !node.left.left && !node.left.right) {
                sum += node.left.val
            }
            if (node.left) seq.push(node.left)
            if (node.right) seq.push(node.right)
        }
    }
    return sum
};



/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
    let res = 0
    var getSum = function(root,value) {
        if (!root.left && !root.right && value===1) {
            res += root.val
            return
        }
        if (root.left) getSum(root.left,1)
        if (root.right) getSum(root.right,2)
    }
    getSum(root, 2)
    return res
};
```



## 找树左下角的值
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var findBottomLeftValue = function(root) {
    if (!root) return null
    let res = 0
    let seq = []
    seq.push(root)

    while (seq.length) {
        let len = seq.length

        for (let i=1; i<=len; i++) {
            let node = seq.shift()
            if (i===1) {
                res = node.val
            }
            if (node.left) seq.push(node.left)
            if (node.right) seq.push(node.right)
        }
    }

    return res
};
```



## 二叉树中和为某一值得路径
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} target
 * @return {number[][]}
 */
//  方法一
var pathSum = function(root, target) {
    if (!root) return [];
    var getPath = function(sum,path,node) {
        if (node.val === sum && !node.left && !node.right) {
            res.push(path)
        }
        path.push(node.val)
        if (node.left) getPath(sum - node.val, path.slice(), node.left)
        if (node.right) getPath(sum - node.val, path.slice(), node.right)
    }
    let res = []
    getPath(target, [], root)
    return res
};

// 方法二
var pathSum = function(root, target) {
    if (!root) return []
    let res = []
    let path = []
    var getPath = function(node, sum) {
        if (sum + node.val === target && !node.left && !node.right) {
            res.push([...path, node.val])
            return 
        }
        path.push(node.val)
        if (node.left) getPath(node.left, sum + node.val, path)
        if (node.right) getPath(node.right, sum + node.val, path)
        path.pop()
    }
    getPath(root, 0)
    return res
};
```


## 路径总和
https://leetcode-cn.com/problems/path-sum-ii/
```js
//路径总和I
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if (!root) return false
    if (!root.left && !root.right) {
        return targetSum - root.val === 0
    }
    return hasPathSum(root.left, targetSum-root.val) || hasPathSum(root.right, targetSum-root.val)
};

//路径总和II
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number[][]}
 */
var pathSum = function(root, targetSum) {
    if (!root) return []
    let res = []
    var getPath = function(node, curPath, sum) {
        if (sum === 0 && !node.left && !node.right) {
            res.push([...curPath])
            return 
        }
        if (!node.left && !node.right) return
        if (node.left) {
            curPath.push(node.left.val)
            getPath(node.left, curPath, sum - node.left.val)
            curPath.pop()
        }
        if (node.right) {
            curPath.push(node.right.val)
            getPath(node.right, curPath, sum - node.right.val)
            curPath.pop()
        } 
        return
    }
    getPath(root, [root.val], targetSum - root.val)
    return res
};

```

## 翻转二叉树
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if (!root) return null
    var invert = function(left,right) {
        let temp = left
        left = right
        right = temp
        root.left = left
        root.right = right
    }
    invert(root.left, root.right)
    invertTree(root.left)
    invertTree(root.right)
    return root
};
```




## 二叉搜索树
1. 二叉搜索树中的搜索
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var searchBST = function(root, val) {
    if (!root || root.val === val) return root
    if (root.val > val) {
        return searchBST(root.left, val)
    } 
    if (root.val < val) {
        return searchBST(root.right, val)
    }
    return null
};

```
# 链表

//反转链表
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let prev = null
    let curr  = head
    //如果curr为null,则其已经成为最后一个节点，链表已经反转完成
    while (curr){
        //先用next保存下一个节点
        let next = curr.next
        //将curr指向prev前面一个节点
        curr.next = prev
        //prev节点后移
        prev = curr
        //curr节点也后移
        curr = next
    }
    return prev
};



//合并两个排序的链表
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var mergeTwoLists = function(l1, l2) {
    if(!l1){
        return l2
    }
    if(!l2){
        return l1
    }
    let head
    if (l1.val < l2.val){
        head = l1
        head.next = mergeTwoLists(l1.next,l2)
    }else{
        head = l2
        head.next = mergeTwoLists(l1,l2.next)
    }
    return head
};


//删除链表中的节点
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */

var deleteNode = function(head, val) {
    if (head.val === val){
        return head.next
    }
    head.next = deleteNode(head.next,val)
    return head
};





# 数组

```js
//找出数组中重复数字
/**
 * @param {number[]} nums
 * @return {number}
 */
var findRepeatNumber = function(nums) {
    let map = new Map()
    for (let i of nums){
        if (map.has(i)) return i;
        map.set(i,1)
    }
    return null
};


//最大子序和
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let pre = 0 ;
    let maxSum = nums[0];
    nums.forEach((x) =>{
        //如果之前的和加上当前元素值还没有当前元素值大，则丢弃
        pre = Math.max(pre+x,x)
        maxSum = Math.max(pre,maxSum)
    })
    return maxSum
};


//数组变整数加一
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {
    
    for (let i=digits.length-1; i>=0; i--){
        digits[i]++
        digits[i] = digits[i] % 10
        if (digits[i] != 0){
            return digits
        }      
    }
    digits.unshift(1)
    return digits  
};


//有序数组的平方
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function(nums) {
    let newNum = nums.map((x) =>{
        return x = x * x
    })
    newNum.sort((x,y) => x - y)
    return newNum
};
```



# 动态规划

## 最大子序和
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let dp = new Array(nums.length + 1).fill(0)
    let result = nums[0]
    dp[0] = nums[0]
    for (let i=1; i<nums.length; i++) {
        dp[i] = Math.max(dp[i-1] + nums[i], nums[i])

        if (result < dp[i]) {
            result = dp[i]
        }
    }
    return result
};
```

## 最长递增子序列
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    let dp = new Array(nums.length).fill(1)
    let res =0 
    for (let i=0; i<nums.length; i++) {
        for (let j=0; j<i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j]+1)
            }
        }
        if ( res < dp[i]) {
            res = dp[i]
        }
    }
    return res
};
```

## 最长连续递增序列
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findLengthOfLCIS = function(nums) {
    let dp = new Array(nums.length).fill(1)
    let result = 1
    for (let i=0; i<nums.length-1; i++) {
        if (nums[i+1] > nums[i]) {
            dp[i+1] = dp[i] + 1  
        }
        if (result < dp[i+1]) {
            result = dp[i+1]
        }
    }
    return result
};
```

## 最长重复子数组
```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findLength = function(nums1, nums2) {
    let dp = new Array(nums1.length + 1).fill(0).map (x => new Array(nums2.length + 1).fill(0))
    let result = 0
    for (let i=1; i<=nums1.length; i++) {
        for (let j=1; j<=nums2.length; j++) {
            if (nums1[i-1] === nums2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1
            }
            if (result < dp[i][j]){
                result = dp[i][j]
            }
        }
        
    }
    return result
};
```

## 最长公共子序列
```js
/**
 * @param {string} text1
 * @param {string} text2
 * @return {number}
 */
var longestCommonSubsequence = function(text1, text2) {
    let dp = new Array(text1.length + 1).fill(0).map(x => new Array(text2.length + 1).fill(0))

    for (let i=1; i<=text1.length; i++) {
        for (let j=1; j<=text2.length; j++) {
            if (text1[i-1] === text2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])
            }

            
        }
    }
    return dp[text1.length][text2.length] 
};
```

# 面试题
//翻转单词顺序
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    //将两个单词多余的空格减少到一个
    s = s.replace(/ +/g, ' ')
    return  s.split(' ').reverse().join(' ').trim()
};