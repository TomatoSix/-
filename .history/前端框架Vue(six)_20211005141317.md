# 在开发环境中关于 proxyTable 代理实现跨域

同源策略： 协议、主机、端口号相同

其它解决跨域： 
1. cors(跨域资源共享)  
2. jsonp(借助script标签src属性，在引入外部资源不受同源策略限制的特点，只能解决get请求)
3. 配置代理服务器
   * nginx
   * vue-cli devServer.proxy

## 配置代理 方式一

```js
// vue.config.js文件
devServer: {
  proxy: 'http://localhost:5000'  //发送请求的服务器端口号
}
```
## 配置代理 方式二
```js
devServer: {
  proxy: {
    // 如果请求的前缀(在端口号后)是'/api', 就把请求转发给target'http://localhost: 5000'
    '/api': {
      target: 'http://localhost:5000',  // 发送请求的服务器端口号
      pathRewrite: {
        '^/api': ''
      }，
      ws: true, //用于支持websocket
      changeOrigin: false 
      //是否更改代理服务器的端口号， 用于控制请求头中的host值
      // true时，服务器收到的请求头中的host为： localhost:5000 和服务器端口号一致
      // false时，服务器收到的请求头中的host为： localhost: 8080 和脚手架开启的端口号一致
    }
  }
}
```




https://blog.csdn.net/weixin_44116302/article/details/105420071

原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。vue-cli 的 proxyTable 用的是 http-proxy-middleware 中间件，该中间件本质上是在本地开了一个服务器 dev-server，所有的请求都通过这里转发出去，即把浏览器的发送请求代理转发到代理服务器上，再由代理服务器发送请求给目标服务器，从而解决跨域问题。

```js
proxyTable: {
  '/api/*': {
      target: 'http://127.0.0.1:8088',  //代理目标的基础路径
      changeOrigin: true,
      pathRewrite: {
          '^/api': ''  //匹配所有以'/api'为开头的路径
      },
     
  }
}
```
```js

```

## jQuery、axios 都封装了ajax请求 xhr  fetch 原生就有(兼容性问题)
```js

```


# 什么是观察者模式？
一个对象维持一系列依赖于它的对象，将有关状态的任何变更自动通知给它们
# 什么是 SPA 单页面应用？
SPA( single-page application)
* 概念：
仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

* 优点：
(1)用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
(2)基于上面一点，SPA 相对对服务器压力小；
(3)前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

* 缺点：
(1)初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
(2)前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
(3)SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

# 什么是 MVC？

M: Model 数据模型（专门用来操作数据，数据的 CRUD）  
V：View 视图（对于前端来说，就是页面）  
C：Controller 控制器（是视图和数据模型沟通的桥梁，用于处理业务逻辑）  

# 什么是 MVVM？
Model-View-ViewModel(MVVM)是一种软件架构设计模式  
1. View 层(视图)
视图层，即用户界面，由 HTML 和 CSS 构建  
2. Model 层(模型)
指数据模型，即后端提供的 API 接口，指后端进行的各种业务逻辑处理和数据操控  
3. ViewModel 层(视图模型)
视图数据层，View 和 Model 层的桥梁    
数据会绑定到 viewModel 层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。



# 什么是双向绑定
双向绑定： 数据变化更新视图，视图变化更新数据
即：输入框的内容发生变化时， data中的数据同步变化； data中的数据变化时，文本节点的内容同步变化
 
# 什么是虚拟DOM
虚拟DOM是对DOM的抽象，本质上是 Javascript对象
虚拟 DOM 提升性能的点在于 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图。

# Object.defineProperty 

```javascript
  let number = 18

  let person = {
    name: '小六',
    height: 180,
  }

  Object.defineProperty(person, 'age' , {
    value: 18,
    enumerable: true,  //控制属性是否可以枚举
    writable: true,  //控制属性是否可以修改
    configurable(可配置的): true,  //控制属性是否可以被删除

    //当有人读取person的age属性时， get函数就会被调用， 且返回值就是age值
    get: function() {
      return number
    },
    //当有人读取person的age属性时， set函数(setter)就会被调用， 且会收到修改的具体值
    set: function(value) {
      // 把number修改掉
      number = value
    }
  })
```


# Vur中的数据代理

1. 数据代理
概念：通过一个对象代理对另一个对象中的属性操作
```javascript
  let obj = {x:100}
  let obj2 = {y:200}

  Object.defineProperty(obj2, x ,{
    get() {
      return obj.x
    },

    set(value) {
      obj.x = value
    }
  })
```

2. Vue中的数据代理
```javascript
let data = {
  name: '尚硅谷',
  address: '不想'
}

const vm = new Vue({
  el: '#root',
  data: data
})
```
vm中的 _data 就是 options定义的data,即vm._data = options.data = data  
vm._data = options.data 前也做了一步处理，对options中的data进行加工 即数据监测

```javascript
let data = {
  name: '尚硅谷',
  address: '北京'
}

// 创建一个监视的实例对象，用于监视data中属性的变化
const obs = new Observer(data)

// 准备一个vm实例对象
let vm = {}
vm._data = data = obs

function Observer(obj) {
  // 汇总对象中所有的属性形成一个数组
  const keys = Object.keys(obj)
  // 遍历
  keys.forEach((k) => {
    Object.defineProperty(this, k, {
      get() {
        return obj[k]
      },
      set(val) {
        obj[k] = val
      }
    })
  })
}
```

# key的作用与原理
1. 虚拟DOM中key的作用：
  key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

2. 对比规则
  (1)旧虚拟DOM中找到了与新虚拟DOM相同的key:
     若虚拟DOM中内容没变，直接使用之前的真实DOM
     若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM
  (2)旧虚拟DOM中未找到与新虚拟DOM相同的key
     创建新的真实DOM，随后渲染到页面

3. 用index作为key可能会引发的问题：
    1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作
      会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低
    2. 如果结构中还包含输入类的DOM
     会产生错误DOM更新 ==> 界面有问题
4. 开发中如何选择key?
    1. 最好使用每条数据的唯一标识作为key,比如id, 手机号, 身份证号等唯一值
    2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表展示，使用index作为key是没有问题的

* 虚拟DOM的diffing算法




# Vue更新时的问题 对象新增属性、删除属性、数组

Vue 监测不到对象新增属性和删除属性
Vue 检测不到数组元素的修改(通过索引赋值的方式)
## Vue监测对象数据的改变？
Vue.set(对象， 属性， 属性值) 会为对象的属性添加getter和setter
* 用法：
    向响应式对象中添加一个property,并确保这个新property同样是响应式的，且触发视图更新。
    注意： 对象不能是Vue实例，或者Vue实例的根数据对象vm._data

## Vue监测数组对象的改变？
数组中的元素不是通过setter 和 getter 进行响应的
例如arr[0] = '111'  无法进行视图更新
* Vue只承认push pop shift unshift splice sort reverse这七个方法承认修改数组，会触发视图更新
```javascript
data() {
  return {
    user:['你好', '我们', '认识吗']
  }
}
methods： {
  change() {
    this.user[2] = '不认识'   // 视图不会更新
    this.user.splice(2,1,'不认识')  //视图会更新
  }
}
```

1. 利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue
解决方法： Vue.set(vm.items, indexOfItem, newValue) 2.修改数组的长度时，例如：vm.items.length = newLength
解决方法： vm.items.splice(newLength)
<!--
  Vue监视数据的原理：
    1. vue会监视data中所有层次的数据。

    2. 如何监测对象中的数据？
            通过setter实现监视，且要在new Vue时就传入要监测的数据。
              (1).对象中后追加的属性，Vue默认不做响应式处理
              (2).如需给后添加的属性做响应式，请使用如下API：
                      Vue.set(target，propertyName/index，value) 或 
                      vm.$set(target，propertyName/index，value)

    3. 如何监测数组中的数据？
              通过包裹数组更新元素的方法实现，本质就是做了两件事：
                (1).调用原生对应的方法对数组进行更新。
                (2).重新解析模板，进而更新页面。

    4.在Vue修改数组中的某个元素一定要用如下方法：
          1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()
          2.Vue.set() 或 vm.$set()
    
    特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！
-->

# 数据劫持

# Vue 的生命周期

8 个分别为  

> beforeCreate vue 实例的挂载元素 el 和数据对象 data 都为 undefined; methods还未初始化  
> created vue 实例的数据对象 data 有了，el 为 undefined,还未初始化

> beforeMount vue 实例的挂载元素 el 和 data 都初始化了，但挂在之前为虚拟的 dom 节点，data.message 还未替换, 模板尚未挂载到页面中

> mounted vue 被新创建的 vm.$el 替换，表示整个 Vue 实例已经初始化完毕，data.message 成功渲染

> beforeUpdate 当 data 变化时，会触发 beforeUpdate 和 updated 方法，data 数据是最新的，但是页面尚未和最新的数据保持同步

> updated 执行时，页面和 data 数据已经保持同步

> activated keep-alive 专属，组件被激活时调用  
> deactivated keep-alive 专属，组件被销毁时调用

> beforeDestroy 当执行 beforeDestroy 的时候，实例身上所有的 data 和所有的 methods 以及过滤器、指令都处于可用状态，此时还未真正执行销毁的过程

> destroyed 对 data 的改变不会再触发周期函数，此时 vue 实例已经解除了事件监听和 DOM 的绑定，但是 dom 结构依然存在

# v-show 和 v-if 的区别？

相同点： 当条件不成立时，其所对应的标签元素都不可见

不同点：

> v-if 真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

       适用于不需要频繁切换条件的场景

> v-show 仅在初始化时加载一次，操作的是样式(display),切换当前样式的显示与隐藏，

       适用于需要频繁切换条件的场景

# computed 和 watch 的区别？

* 计算属性 computed：

  1. 支持缓存，只有依赖数据发生改变，才会重新进行计算不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化 computed 属性值会默认走缓存
  2. 计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值。如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed。如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法。
  3. 每个计算属性都包含一个 getter 和一个 setter 方法
     例如

  ```javascript
  const app = new Vue({
    el: '#app',
    data: {
      firstName: 'Kobe',
      lastName: 'Bryant'
    },
    // computed简写形式,只设置get方法，为只读属性
    // 计算属性的字段类似于放到data中
    computed: {
      fullName: function() {
        return this.firstName + ' ' + this.lastName
      }
    }

    //  计算属性的get和set方法
    computed: {
      fullName: {
        set: function(newValue) {
          const names = newValue.split(' ')
          this.firstName = name[0]
          this.lastName = name[1]
        },
        get: function() {
          return this.firstName + ' ' + this.lastName
        }
      }
    }
  })
  ```

* 侦听属性 watch：
  > 不支持缓存，数据变，直接会触发相应的操作；
  > watch 支持异步；
  > 监听的函数接收两个参数，第一个参数是最新的值；
  > 第二个参数是输入之前的值；
  > 当一个属性发生变化时，需要执行对应的操作；一对多；
  > 监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数
  > 数组的变化不需要通过深度监听，对象数组中对象的属性变化则需要deep深度监听
  ```javascript
  new Vue({
    el: '#root',
    data: {
      cityName: {id: 1, name: 'shanghai'}
    },
    watch: {
      //简写形式
      //cityName(newName, oldName) {}
      cityName: {
        handler(newName, oldName) {
        // ...
        },
        deep: true,   //deep表示深度监听，用于监听对象内部属性的改变
        immediate: true   //immediate表示立刻监听，当值第一次绑定的时候，不会执行监听函数，只有值发生改变才会执行，使用该属性表示会立刻监听
      }
    } 
  })
  ```

# class 与 style 的动态绑定

class 的动态绑定

1. 对象语法
v-bind:class 指令也可以与普通的 class attribute 共存
<div v-bind:class="{ active: isActive }"></div>

2. 数组语法
<div v-bind:class="[activeClass, errorClass]"></div>

<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>

<div v-bind:class="[{ active: isActive }, errorClass]"></div>

# v-for 进行列表渲染

1. 在 v-for 里使用数组
<li v-for="(item, index) in items">
2. 在 v-for 里使用对象
<div v-for="(value, name, index) in object">
3. 在 v-for 里使用值范围
   <span v-for="n in 10">{{ n }} </span>

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 key attribute：

# v-on 的修饰符使用

@click.stop 阻止冒泡 调用 event.stopPropagation()

<!-- 阻止单击事件继续传播 -->

<a v-on:click.stop="doThis"></a>
@click.prevent 阻止默认事件 调用 event.preventDefault()

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>
<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>
@click.native  监听组件根元素的原生事件
@click.once  只触发一次回调
@keyUp.enter  键修饰符，监听回车

# 事件处理方法


```vue
<body>
  <div id="app">
    <button @click="say()"> 方法 </button>
    // <!-- 没有参数()可以直接省略，有括号必须传入参数，否则为undefined -->
    <button @click="say1">方法1</button>
    <button @click="say2('hi')">方法2</button>
    // <!-- 通过$event访问原始的DOM事件 -->
    <button @click="say3(message, $event)">方法3</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script>
    const app = new Vue({
      el: "#app",
      data: {
        message: "你好啊"
      },
      methods: {
        say(event){
          console.log(event);  //undefined
        },
        say1: function(event){
          // 会自动传入一个event
          console.log(event);  //MouseEvent
          console.log(this.message);   //你好啊
        },
        say2: function(a) {
          console.log(a);  //hi
        },
        say3: function(b,event) {
          console.log(b,event);  //你好啊   MouseEvent
        }
      },
    })
  </script>
</body>
```

# 为什么 vue 组件中 data 必须是一个函数？

======================================
对象为引用类型，当复用组件时，由于数据对象都指向同一个 data 对象，当在一个组件中修改 data 时，其他重用的组件中的 data 会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object 的实例），引用地址不同，则不会出现这个问题。

# v-model 的原理

v-model 指令在表单 <input>、<textarea> 及 <select> 元素上创建双向数据绑定。

1.  text 和 textarea 元素使用 value property 和 input 事件；
2.  checkbox 和 radio 使用 checked property 和 change 事件；
3.  select 字段将 value 作为 prop 并将 change 作为事件。
```js
<body>
  <div id="app">
    <!-- v-model实现双向绑定 -->
    <!-- <input type="text" v-model="message"> -->

    <!-- 实现双向绑定方法二 -->
    <!-- <input type="text" :value="message" @input="valueChange"> -->
    <input type="text" :value="message" @input="message = $event.target.value">
    <h2>{{message}}</h2>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script>
    const app = new Vue({
      el: '#app',
      data: {
        message: '你好啊'
      },
      methods: {
        // 会默认传入一个event参数
        valueChange(event) {
          this.message = event.target.value
        }
      },
    })  
  </script>
</body>
```

# 消息订阅与发布
pubsub-js(publish-subscribe-js) 消息订阅与发布插件  实现任意组件间通信

# Vue 组件的通信方式

常见使用场景可以分为三类：  
父子组件通信、兄弟组件通信、跨级通信      

常见的几种通信方式  
(1) props / $emit  适用于父子组件通信  
(2) ref="组件名" this.$refs.组件名 | this.$refs['组件名'] 适用于父子组件通信  
(3) $parent / $children 适用于父子组件通信  
(4) eventBus 全局事件总线  $emit/$on 任意组件间通信  
(5) vuex 适用于父子、隔代、兄弟组件通信  
(6) provide / inject 适用于隔代组件通信  
(7) $attrs / $listeners 适用于隔代组件通信
(8) pubsub-js库  消息订阅与发布插件  实现任意组件间通信


## project和inject
```js
provide: function() {
  return {
    getIndexRef: () => {
      return this
    }
  }
}
```

```js
inject: ['getIndexRef']
// 使用
this.getIndexRef()
```

## 全局事件总线
vc.prototype.__proto__ === vue.prototype  vc是VueComponent的实例对象
$on $emit $off 都在vue的原型对象上

* 安装全局事件总线
```javascript
const vm = new Vue({
  el: '#app',
  render: h => h(App),
  beforeCreate() {
    Vue.prototype.$bus = this  //安装全局事件总线
  }
})
```
* 使用与解绑
```javascript
this.$bus.$emit('hello', 数据data)
```
全局事件总线要解绑
```javascript
mounted() {
  this.$bus.$on('hello', (data) => {
    console.log('我们认识吗')
  })
}
beforeDestroy() {
  this.$bus.$off('hello')
}
```



# vuex 的使用

Vuex：专为 Vue.js 应用程序开发的状态管理模式
格式：
const store = new Vuex.Store({
state:{},
getters:{},
mutations:{},
actions:{}
})
主要模块为
state:用于设置默认的初始状态  
getters:相当于 Vue 中的计算属性 computed，getter 的返回值会根据它的依赖被缓存起来，
且只有当它的依赖值发生了改变才会被重新计算

        接收两个参数分别为(state,getters)

mutations: 包括两个部分为
1 字符串的事件类型(type)  
 2 一个回调函数(handler)参数为(state,payload)

            state状态更新的唯一方式：
            在组件中使用this.$store.commit('mutations中的方法名'，payload) 提交mutation
            且必须为同步函数

actions: 用于提交 mutation,而不是直接变更状态，可以包含任意异步操作
组件中使用 this.$store.dispatch('actions中的方法名'，data)
            mutations中使用this.$store.commit('mutations 中的方法名'，data)
modules: 允许将单一的 store 拆分成多个 store 且同时保存在单一的状态树中

### vue-router

# vue-router 

## 路由
方法一
to 表示路由 active-class当前切换路由效果
<router-link to="/about" active-class="active"> </router-link>
指定组件的呈现位置实现路由切换
<router-view></router-view>
方法二 编程式路由导航



## 嵌套路由
  ```javascript
  routes: [
    {
      path: '/about',
      component: About
    },
    {
      path: './home',
      component: Home,
      children: [
        {
          path:'new',  //子路由不需要加'/'
          component: News
        }
      ]
    }
  ]
  ```
  方法一
  ```javascript
  // 跳转必须把路径写全
  <router-link to="/home/news" active-class="active"></router-link>
  ```

  方法二

## 路由传参
<router-link> 中的to 字符串写法和对象写法
query参数   放在请求体中   可以name，也可以path
params参数   1. 放在链接中  必须和name命名路由一起  2.props配置(三种)

## 编程式路由导航
this.$router.push({
  name: 'about',
  params: {}
})
this.$router.back  //回退
this.$router.forward   //前进
this.$router.go(-1)  //后退一步
this.$router.go(1)  //前进一步


## 缓存路由导航
include 包含的路由组件会缓存,不会被销毁
<keep-alive include="News">
  <router-view></router-view>
<keep-alive>

## 路由钩子
1. activated() {}   //表示激活时
2. deactivated() {}  //表示销毁时

## 路由守卫
1. 全局前置守卫
<!-- 全局前置路由守卫——初始化、每次路由切换之前被调用 -->
router.beforeEach(to, from, next){}
to  点击的路由
from 上一个路由
next() 放行
2. 全局后置守卫
<!-- 全局后置路由守卫——初始化、每次路由切换之前被调用 -->
router.afterEach(to, from){}  可以用来修改窗口名 window.title
to  点击的路由
from 上一个路由
3. 独享路由守卫 beforeEnter(写在路由里)
beforeEnter(to, from , next)
4. 组件内路由守卫
<!-- 通过路由规则，进入该组件时被调用 -->
beforeRouterEnter(to, from, next) {}
<!-- 通过路由规则，离开该组件时被调用 -->
beforeRouterLeave(to, from, next) {}


## history模式和hash模式
mode: history


# 对 keep-alive 的了解

是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染

1. 一般结合路由和动态组件一起使用，用于缓存组件  
2. 提供 include 和 exclude 属性，两者都支持字符串或正则表达式  
include 表示只有名称匹配的组件会被缓存，
exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高； 
3. 对应两个钩子函数 activated 和 deactivated  
 当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。


# assets 和 static 的区别？
assets 中的文件在运行 npm run build 的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到 static 中。

static 中的文件则不会被打包。

# $nextTick 是什么？

在 DOM 更新完毕之后执行一个回调
<template>
  <div :class="$style.behavior">
    <TopView :cparams="params" ref="bb"></TopView>
  </div>
</template>
export default {
  created() {
    console.log('bbbbbbbbbbbbbbbbb', this.$refs.bb);
    this.$nextTick(() => {
    // 响应式发生修改页面渲染完成之后触发
    //在DOM更新完毕之后执行一个回调
    console.log('bbbbbbbbbbbbbbbbb', this.$refs.bb);
    });
    setTimeout(this.setOptions, 500);
  }
}

结果为
bbbbbbbbbbbbbbbbb undefined
bbbbbbbbbbbbbbbbb 打印出当前组件
可用于加载中，模拟延迟效果

# 非单文件组件和单文件组件？
非单文件组件：
    一个文件中包含有n个组件
单文件组件：
    一个文件中只包含有1个组件

# VueComponent 构造函数？
1. 组件的本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的
2. 