# 手撕代码部分

1. 模拟实现函数的call，apply，bind方法(six)
    
    1. call

        ```javascript
        Function.prototype.myCall = function (context) {
            context = context || window
            //保存this指向
            context.fn = this
            //取出剩余参数
            let args = [...arguments].slice(1)
            //参数执行
            let result = context.fn(...args)
            //删除context.fn
            delete context.fn
            //返回结果
            return result
        }
        ```
    2. apply

        ```javascript
        Function.prototype.myApply = function (context) {
            //默认为window
            context = context || window
            //保存this指向
            context.fn = this
            //取出剩余参数
            let args = [...arguments][1]
            // 判断是否有第二个参数
            if (!args) return context.fn()
            let res = context.fn(...args)
            delete context.fn
            return res
        }
        ```
    3. bind

        1. 方法一

        ```javascript
        Function.prototype.myBind = function(context) {
          const fn = this
          context = context || window
          const otherArg = [...arguments].slice(1)
          const result = function() {
            const resultArg = [...arguments]
            if (this instanceof result) {
              fn.apply( this, otherArg.concat(resultArg))
            } else {
              fn.apply( context, otherArg.concat(resultArg))
            }
          }
          result.prototype = fn.prototype
          return result
        }
        ```
        2. 方法二(six)
        ```javascript
        Function.prototype.myBind = function(context) {
            if(typeof this != "function") {
                throw Error("not a function")
            }
            // 若没问参数类型则从这开始写
            let fn = this;
            let args = [...arguments].slice(1);
            
            //判断是不是new出来的
            let resFn = function() {
                return fn.apply(this instanceof resFn ? this : context,args.concat(...arguments) )
            }
            function tmp() {}
            tmp.prototype = this.prototype;
            resFn.prototype = new tmp();
            
            return resFn;
        }



      
        ```



2. 模拟实现函数节流和防抖方法(six)
  https://juejin.cn/post/6844903651278848014

    (1). 防抖
    在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时
    应用场景：
    1. search搜索，用户不断输入值时，用防抖来节约Ajax请求，也就是输入框事件
    2. window触发resize时，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

    ```javascript
    function debounce(fn, delay) {
      // 维护一个timer，用来记录当前函数的执行状态
      let timer = null;
      return function() {
        // 通过this和arguments获取函数的作用域和变量
        let self = this;
        let args = Array.from(arguments)
        // 清理正在执行的函数，并重新执行
        if(timer) clearTimeout(timer);
        timer = setTimeout(function() {
            fn.apply(self, args)
        }, delay)
      }
    }

    let flag = 0; // 记录当前函数调用次数
    // 当用户滚动时被调用的函数
    function foo() {
        flag += 1
        console.log('Number of calls: %d', flag)
    }

    // 在 debounce 中包装我们的函数，过 2 秒触发一次
    document.body.addEventListener('scroll', debounce(foo, 2000))
    ```

    (2). 节流
    规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。
    1. 鼠标的点击事件，mousedown只触发一次
    2. 监听滚动事件，比如是否滑到底部自动加载更多，用throttle判断

    ```javascript
    function throttle(fn, delay) {
      let timer = null;
      let startTime = Date.now()
      return function() {
        let curTime = Data.now()
        let remaining = delay - (curTime - startTime)
        let self = this
        let args = [...arguments]
        clearTimeout(timer)
        if (remaining <= 0) {
          fn.apply(self, args)
          startTime = Date.now()
        } else {
          timer = setTimeout(fn, remaining)
        }
      }
    }
    ```
















3. 模拟实现对象的深拷贝(six)

    ```javascript

    // 第一种: JSON.parse(JSON.stringify())方法实现深拷贝
    let Obj={a:"hello",b:1,c:true,d:[1,2],e:{x:1,y:2},f:function(){console.log("copytest");},g:null,h:undefined};
    let copyObj = JSON.parse(JSON.stringify(Obj))
    console.log(copyObj)
    copyObj.a = 'change'
    copy.obj.e.x = 8
    console.log(Obj)

    // 第二种: 递归的方法实现深拷贝
    function deepClone(Obj, copyObj) {

      let copyObj = copyObj || {}
      for (let keys in Obj) {
        if (Obj.hasOwnProperty(keys)) { // 剥离原型链的数据
          if ((typeof(Obj[keys])) === 'Object' && Obj[keys] !== null) { //判断是否为引用数据类型
            if (Object.prototype.toString.call(Obj[keys]) === '[object Array]') { // Object原型方法得到类型
              copyObj[keys] = [];
            } else {
              copyObj[keys] = {}
            }
            deepClone(Obj[keys], copyObj[keys])
          } else {
            copyObj[keys] = Obj[keys]
          }
        }
      }
      return copyObj
    }
    ```


    ```javascript
    //考虑到数组、循环引用、性能优化
    function clone(target, map = new WeakMap()) {
      if (typeof target === 'object'){
        const isArray = Array.isArray(target)
        let cloneTarget = isArray ? []:{}

        if (map.get(target)) {
          return map.get(target)
        }
        map.set(target, cloneTarget)

        const keys = isArray ? undefined : Object.keys(target)
        forEach(keys || target, (value, key) => {
          if (keys) {
            key = value
          }
          cloneTarget[key] = clone(target[key], map)
        })

        return cloneTarget
      } else {
        return target
      }
    }
    ```
    
    ```javascript
    // 不考虑性能优化
    function clone(target, map = new WeakMap()) {
      if (typeof target === 'object') {
        let isArray = Array.isArray(target) 
        let cloneTarget = isArray ? []:{}

        if (map.get(target)) {
          return map.get(target)
        }
        map.set(target, cloneTarget)
        for (let key in target) {
          cloneTarget[key] = clone(target[key])
        }
        return cloneTarget
      } else {
        return target
      }
    }
    ```

4. 嵌套数组指定层次展开flat扁平化(six)

    ```javascript
    // 1. 普通方法递归
    const res = []
    const flatten = arr => {
      for (let i = 0; i < arr.length; i++) {
        if (Array.isArray(arr[i])) {
          flatten(arr[i])
        } else {
          res.push(arr[i])
        }
      }
    }

    // 2. concat
    function flatten(arr) {
      let res = []
      arr.forEach(item => {
        if (Array.isArray(item)) {
            res = res.concat(flatten(item))
        } else {
            res.push(item)
        }
      })
      return res
    }

    // 3. reduce
    function flattenMd(arr) {
      return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flattenMd(cur) : cur)
      , []} 
    }

    // 4. 扩展运算符
    function flattenMd(arr) {
      let flatten = arr => [].concat(...arr)
      return flatten(arr.map(item => Array.isArray(item) ? flattenMd(item) : item ))
    }

    // 5. join和split组合
    function flattenMd(arr) {
      return arr.join().split(',')
    }

    // 6. ES6的flat方法
    arr = [1,2,3,[4,[5,6]]]
    const res = arr.flat(Infinity)

    // 7. 正则
    const res = JSON.stringify(arr).replace(/\[|\]/g, '').split(',');
    ```

5. 模拟实现reduce方法(six)

    ```javascript
    // reduce() 函数接受两个参数，一个函数一个积累变量的初始值
    // 函数有四个参数: 累计变量初始值(默认第一个成员)，当前变量值(默认第二个成员)，当前位置，数组自身
    // arr.reduce(function(prev, cur, index, arr){}, initialValue)
    Array.prototype.myReduce = function(cb,initValue){
        if (!Array.isArray(this)){
            throw new TypeError('不是数组')
        }
        // 数组为空
        if (arguments.length <2 && this.length ===0){
            throw new TypeError('数组为空')
        }

        let arr = this
        let res = null
        if (arguments.length > 1){
            res = initValue
        }else{
            res = arr.splice(0,1)[0]
        }
        arr.forEach((item,index) =>{
            res = cb(res,item,index,arr)
        })
        return res
    }
    ```

6. 模拟实现数组map方法(six)

    ```javascript
    // arr.map((currentValue, index, curr) => {})
    // currentValue 必须。 当前元素的值
    // index 可选。 当期元素的索引值
    // arr 可选。 当期元素属于的数组对象

    Array.prototype.newMap = function(fn) {

        let newArr = [];
        for (let i = 0; i < this.length; i++) {
            newArr.push(fn(this[i], i, this)) // this指向调用newMap方法的数组
        }
        return newArr
    }

    Array.prototype.newMap = function (fn, Arg) { ////写法二：用数组的reduce方法实现数组的map
        let res = [];
        this.reduce((prev, curr, index, array) => {
            res.push(fn.call(Arg, curr, index, array));
        }, 0) //指定初始值initialValue=0，所以从currentIndex=0开始，即第一个开始  不这样会缺第一项，结果为[3,4]
        return res;
    }
    let arr = [1, 2, 3];
    let res = arr.newMap((a) => a + 1);
    console.log(res);
    ```

7. 模拟实现Array.fill(), Array.filter()(six)

    ```js
    // array.fill(value, start, end)
    Array.prototype.myFill = function (value, start = 0, end = this.length) {  
        for (let i = start; i < end; i++) {
            this[i] = value
        }
    }

    // array.filter()
    Array.prototype.myFilter = function myFilter(fn, context) {
        if (typeof fn !== 'function') {
            throw new TypeError(`${fn} is not a function`)
        }
        let arr = this;
        let newArr = [];
        for (let i = 0; i < arr.length; i++) {
            let res = fn.call(context, arr[i], i, arr)
            if (res) newArr.push(arr[i])
        }
        return newArr
    }
    ```

8. 模拟实现Array.find(), Array.findIndex()(six)

    ```js

    Array.prototype.myFind = function (fn, start = 0, end = this.length) {
        for (let i = start; i < end; i++) {
            if (fn.call(this, this[i], i, this)) {
                return this[i]
            }
        }
    }

    Array.prototype.myFindIndex = function (fn, start = 0, end = this.length) {
        for (let i = start; i < end; i++) {
            if (fn.call(this, this[i], i, this)) {
                return i
            }
        }
        return -1
    } 
    ```


10. 使用原生JS实现ajax请求(six)

    ```js
    let xhr = new XMLHttpRequest(); // 创建XMLHttpRequest
    let url = 'https://steven.com'
    xhr.onreadystatechange = function() { // 监听状态码的变化，每次变化均执行
      if (xhr.readyState === 4) {
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) { // 服务端状态码
          console.log(xhr.responseText); // 服务器返回的响应文本
        } else {
          console.error(xhr.statusText) // 状态码的文本描述，如200的statusText是ok
        }
      }
    }
    xhr.open('GET', url, true)
    xhr.send(null)

    // xhr.abort() 用于取消请求
    ```

11. 模拟实现构造函数new的过程(six)

    ```javascript
    function myNew(func, ...args) {
    // 1. 判断方法体
      if (typeof func !== 'function') {
        throw '第一个参数必须是方法体';
      }

      // 2. 创建新对象
      const obj = {};

      // 3. 这个对象的 __proto__ 指向 func 这个类的原型对象
      // 即实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性
      obj.__proto__ = Object.create(func.prototype);

      // 为了兼容 IE 可以让步骤 2 和 步骤 3 合并
      // const obj = Object.create(func.prototype);

      // 4. 通过 apply 绑定 this 执行并且获取运行后的结果
      let result = func.apply(obj, args);
      
      // 5. 如果构造函数返回的结果是引用数据类型，则返回运行后的结果
      // 否则返回新创建的 obj
      const isObject = typeof result === 'object' && result !== null;
      const isFunction = typeof result === 'function';
      return isObject || isFunction ? result : obj;
    }

    // 测试
    function Person(name) {
      this.name = name;
      return function() { // 用来测试第 5 点
        console.log('返回引用数据类型');
      };
    }
    // 用来测试第 2 点和第 3 点
    Person.prototype.sayName = function() {
      console.log(`My name is ${this.name}`);
    }
    const me = myNew(Person, 'jsliang'); // 用来测试第 4 点
    me.sayName(); // My name is jsliang
    console.log(me); // Person {name: 'jsliang'}

    // 用来测试第 1 点
    // const you = myNew({ name: 'jsliang' }, 'jsliang'); // 报错：第一个参数必须是方法体
    ``` 

12. 模拟实现Object.create方法(six)

    ```js
    // 用于创建一个新对象,被创建的对象继承另一个对象(o)的原型
    function createObj(o) { //传入的参数o为返回实例的__porto__,也就是实例构造函数的显示原型
        function F() {} //构造函数
        F.prototype = o;
        return new F(); // 返回实例
    }
    ```

13. 模拟实现instanceof的功能(six)

    ```javascript
    function myInstanceof(left, right) {
      let RP = right.prototype
      let LP = left.__proto__

      while (true) {
        if (LP == null) {
          return false
        }
        if (LP == RP) {
          return true
        }
        LP = LP.__proto__
      }
    }


    console.log(myInstanceof([], Array));
    myInstanceof([], Array); //true
    ```

14. 使用setTimeout实现setInterval方法

    ```js
    function mysetinterval(fn,time){
        console.log("利用steTimeout实现setInterval");
        function interval(){//执行该函数，异步被挂起time时间后在执行，一上来就执行fn
            setTimeout(interval,time);//异步
            //好，time时间过去，这个异步被执行，而内部执行的函数正是interval，就相当于进了一个循环，递归
            fn();//同步
        }
        setTimeout(interval,time);//interval被延迟time时间执行
    }
    ```

15. 实现jsonp
    * JSONP实现流程
    1. 客户端先定义一个接收数据的全局函数，该函数要唯一
    2. 动态生成Script标签，发送请求，把回调函数当做参数传到服务端
    3. 服务端收到请求，返回该函数的调用，并且把数据作为参数一起返回
    4. 客户端执行回调，拿到数据
    ```js
    // 简单版本
    function handleResponse(response) {s
      console.log(response.ip, response.city)
    }

    let script = document.createElement('script')

    script.src= 'http://freegeoip.net/json/?callback=handleResponse'
    document.body.insertBefore(script, document.body.firstChild)
    ```

    ```js
    // 复杂版本
    function JSONP({
        url,
        params = {},
        callbackKey = 'cb',
        callback
    }) {
        // 定义本地的唯一callbackId，若是没有的话则初始化为1
        JSONP.callbackId = JSONP.callbackId || 1;
        let callbackId = JSONP.callbackId;
        // 把要执行的回调加入到JSON对象中，避免污染window
        JSONP.callbacks = JSONP.callbacks || [];
        JSONP.callbacks[callbackId] = callback;
        // 把这个名称加入到参数中: 'cb=JSONP.callbacks[1]'
        params[callbackKey] = `JSONP.callbacks[${callbackId}]`;

        // 得到'id=1&cb=JSONP.callbacks[1]'
        const paramString = Object.keys(params).map(key => {
            return `${key}=${params[key]}`
        }).join('&')
        // 创建 script 标签
        const script = document.createElement('script');
        script.setAttribute('src', `${url}?${paramString}`);
        document.body.appendChild(script);
        // id自增，保证唯一
        JSONP.callbackId++;
    }
    JSONP({
        url: 'http://localhost:8080/api/jsonp',
        params: { id: 1 },
        callbackKey: 'cb',
        callback (res) {
            console.log(res)
        }
    })
    JSONP({
        url: 'http://localhost:8080/api/jsonp',
        params: { id: 2 },
        callbackKey: 'cb',
        callback (res) {
            console.log(res)
        }
    })
    ```

    ```js
    //最终JSONP方案
    function JSONP({
        url,
        params = {},
        callbackKey = 'cb',
        callback
    }) {
        // 定义本地的唯一callbackId，若是没有的话则初始化为1
        JSONP.callbackId = JSONP.callbackId || 1;
        let callbackId = JSONP.callbackId;
        // 把要执行的回调加入到JSON对象中，避免污染window
        JSONP.callbacks = JSONP.callbacks || [];
        JSONP.callbacks[callbackId] = callback;
        // 把这个名称加入到参数中: 'cb=JSONP.callbacks[1]'
        params[callbackKey] = `JSONP.callbacks[${callbackId}]`;
        // 得到'id=1&cb=JSONP.callbacks[1]'
        const paramString = Object.keys(params).map(key => {
            return `${key}=${encodeURIComponent(params[key])}`
        }).join('&')
        // 创建 script 标签
        const script = document.createElement('script');
        script.setAttribute('src', `${url}?${paramString}`);
        document.body.appendChild(script);
        // id自增，保证唯一
        JSONP.callbackId++;

    }
    JSONP({
        url: 'http://localhost:8080/api/jsonps',
        params: {
            a: '2&b=3',
            b: '4'
        },
        callbackKey: 'cb',
        callback (res) {
            console.log(res)
        }
    })
    JSONP({
        url: 'http://localhost:8080/api/jsonp',
        params: {
            id: 1
        },
        callbackKey: 'cb',
        callback (res) {
            console.log(res)
        }
    })
    ```

16. promise实现sleep函数

    ```js
    async function test() {
        console.log('start')
        await sleep(4000)
        console.log('end')
    }

    function sleep(ms) {
        return new Promise(resolve => {
            setTimeout(resolve, ms)
        })
    }

    test()
    ```

17. 数组转树

    ```js
    function turnToTreeOfManyRootPlus(arr) {
      var arrs = []
      arr.forEach(item => {
        if (!item.parentMenu) {
          arrs.push(item)
        }
      })
     
      return arr.reduce((h, m) => {
        if (m.parentMenu) {
          foo(h, m)
        }
     
        function foo(arr, cur) {
          arr.forEach(item => {
            if (item.menuId === cur.parentMenu) {
              if (!item.children) {
                item.children = []
              }
              item.children.push(cur)
            } else if (item.children) {
              foo(item.children, cur)
            }
          })
        }
     
        return h
      }, arrs)
    }


    ```

18. 实现slice方法

    ```
    Array.prototype.slice2 = function (start, end) {
      let len = this.length;
      let l = start === undefined ? 0 : start < 0 ? Math.max(start + len, 0) : Math.min(start, len);
      let r = end === undefined ? len : end < 0 ? Math.max(end + len, 0) : Math.min(end, len);
      const res = [];
      while (l < r) {
        res.push(this[l++])
      }
      return res;
    }
    ```

19. LRU算法

    ```
    class LRUListNode:
        def __init__(self, key=0, value=0, next=None, prev=None):
            self.key = key
            self.value = value
            self.next = next
            self.prev = prev

    class LRUCache:

        def __init__(self, capacity: int):
            self.capacity = capacity
            self.head = LRUListNode()
            self.tail = LRUListNode()
            self.head.next = self.tail
            self.tail.prev = self.head
            self.cache = dict()
            self.size = 0
            

        def get(self, key: int) -> int:
            
            if key not in self.cache:
                return -1
            node = self.cache[key]
            self.moveToHead(node)
            return node.value
            

        def put(self, key: int, value: int) -> None:
            
            if key not in self.cache:
                node = LRUListNode(key, value)
                self.cache[key] = node
                self.addTohead(node)
                self.size += 1
                if self.size > self.capacity:
                    removed = self.removeTail()
                    self.cache.pop(removed.key)
                    self.size -= 1
            else:
                node = self.cache[key]
                node.value = value
                self.moveToHead(node)
                
        def removeTail(self):
            node = self.tail.prev
            self.remove(node)
            return node
        
        def moveToHead(self, node):
            self.remove(node)
            self.addTohead(node)
        
        def addTohead(self, node):
            nxt = self.head.next
            self.head.next = node
            node.next = nxt
            node.prev = self.head
            nxt.prev = node
        
        def remove(self, node):
            node.prev.next = node.next
            node.next.prev = node.prev
    ```

    ```
    class DoubleLinkedListNode {
        constructor(key, value) {
            this.key = key;
            this.value = value;
            this.prev = null;
            this.next = null;
        }
    }

    class LRUCache {
        constructor(capacity) {
            this.capacity = capacity;
            // Mappings of key->node.
            this.hashmap = {};
            // Use two dummy nodes so that we don't have to deal with the head/tail seperately.
            this.dummyHead = new DoubleLinkedListNode(null, null);
            this.dummyTail = new DoubleLinkedListNode(null, null);
            this.dummyHead.next = this.dummyTail;
            this.dummyTail.prev = this.dummyHead;
        }

        _isFull() {
            return Object.keys(this.hashmap).length === this.capacity;
        }

        _removeNode(node) {
            node.prev.next = node.next;
            node.next.prev = node.prev;
            node.prev = null;
            node.next = null;
            return node;
        }

        _addToHead(node) {
            const head = this.dummyHead.next;
            node.next = head;
            head.prev = node;
            node.prev = this.dummyHead;
            this.dummyHead.next = node;
        }

        get(key) {
            if (key in this.hashmap) {
                const node = this.hashmap[key];
                this._addToHead(this._removeNode(node));
                return node.value;
            } else {
                return -1;
            }
        }

        put(key, value) {
            if (key in this.hashmap) {
                // If key exists, update the corresponding node and move it to the head.
                const node = this.hashmap[key];
                node.value = value;
                this._addToHead(this._removeNode(node));
            } else {
                // If it's a new key.
                if (this._isFull()) {
                    // If the cache is full, remove the tail node.
                    const node = this.dummyTail.prev;
                    delete this.hashmap[node.key];
                    this._removeNode(node);
                }
                // Create a new node and add it to the head.
                const node = new DoubleLinkedListNode(key, value);
                this.hashmap[key] = node;
                this._addToHead(node);
            }
        }
    }
    ```

20. 发布订阅模式

    ```js
    // 公众号对象
    let eventEmitter = {};

    // 缓存列表，存放 event 及 fn
    eventEmitter.list = {};

    // 订阅
    eventEmitter.on = function (event, fn) {
        let _this = this;
        // 如果对象中没有对应的 event 值，也就是说明没有订阅过，就给 event 创建个缓存列表
        // 如有对象中有相应的 event 值，把 fn 添加到对应 event 的缓存列表里
        (_this.list[event] || (_this.list[event] = [])).push(fn);
        return _this;
    };

    // 发布
    eventEmitter.emit = function () {
        let _this = this;
        // 第一个参数是对应的 event 值，直接用数组的 shift 方法取出
        let event = [].shift.call(arguments),
            fns = [..._this.list[event]];
        // 如果缓存列表里没有 fn 就返回 false
        if (!fns || fns.length === 0) {
            return false;
        }
        // 遍历 event 值对应的缓存列表，依次执行 fn
        fns.forEach(fn => {
            fn.apply(_this, arguments);
        });
        return _this;
    };

    function user1 (content) {
        console.log('用户1订阅了:', content);
    };

    function user2 (content) {
        console.log('用户2订阅了:', content);
    };

    // 订阅
    eventEmitter.on('article', user1);
    eventEmitter.on('article', user2);

    // 发布
    eventEmitter.emit('article', 'Javascript 发布-订阅模式');

    /*
        用户1订阅了: Javascript 发布-订阅模式
        用户2订阅了: Javascript 发布-订阅模式
    */
    ```

21. 数据双向绑定(six)

    ```javascript
    let number = 18

    let person = {
      name: '小六',
      height: 180,
    }

    Object.defineProperty(person, 'age' , {
      value: 18,
      enumerable: true,  //控制属性是否可以枚举
      writable: true,  //控制属性是否可以修改
      configurable(可配置的): true,  //控制属性是否可以被删除

      //当有人读取person的age属性时， get函数就会被调用， 且返回值就是age值
      get: function() {
        return number
      },
      //当有人读取person的age属性时， set函数(setter)就会被调用， 且会收到修改的具体值
      set: function(value) {
        // 把number修改掉
        number = value
      }
    })

    let name = '番茄炒小六'
    const obj = {
      age = 11
    }
    ```

22. 手写字符串方法trim()

    ```
    function Trim() {
        let str = this
        let i = 0
        let j = str.length-1
        while (str[i] === '') {
            i += 1
        }
        while (str[j] === ' ') {
            j -= 1
        }
        let res = ''
        for (let c = i; c <= j; c++) {
            res += str[c]
        }
        return res
    }
    ```

23. 懒加载
    
    (1).将需要懒加载的img标签的src设置缩略图或者不设置src，这里的占位图可以是缺省图，loading图；
    (2).判断该img标签是否在浏览器可视区域，如果在可视区域，则将真实的图片url设置到img标签的src属性；
    (3).用户滚动浏览器，遍历需要懒加载的标签，根据步骤2判断并执行；

    ```javascript
    var num = document.getElementsByTagName('img').length;
    var img = document.getElementsByTagName("img");
    var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历

    lazyload(); //页面载入完毕加载可是区域内的图片

    window.onscroll = lazyload;

    function lazyload() { //监听页面滚动事件
      var seeHeight = document.documentElement.clientHeight; //可见区域高度
      var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度
      for (var i = n; i < num; i++) {
        if (img[i].offsetTop < seeHeight + scrollTop) {
          if (img[i].getAttribute("src") == "default.jpg") {
            img[i].src = img[i].getAttribute("data-src");
          }
          n = i + 1;
        }
      }
    }
    ```

24. 函数柯里化
    柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数。

    ```js
    let add = function() {

        let args = Array.from(arguments);
        let inner = function() {
            args.push(...arguments)
            return inner
        }
        inner.toString = function() {
            return args.reduce((pre, cur) {
                return pre + cur
            })
        }
    }

    console.log(add(1)(2)(3)); // 6
    console.log(add(1, 2, 3)(4)); // 10;
    console.log(add(1)(2)(3)(4)(5)); // 15;
    ```

25. `setTimeout`输出1，2，3，4，5

    ```javascript
    // 闭包的使用
    for (var i=1; i < 6; i++) {
        (function (j) {
            setTimeout(function timer() {
            console.log(j)
            }, 1000*j)
        })(i)
    }

    // 利用setTimeout第三个参数
    for (var i=1; i < 6; i++) {
        setTimeout(function timer(j) {
            console.log(j)
        }, 1000 * i, i)
    }

    // 利用let形成块级作用域
    for (let i = 1; i < 6; i++) {
        setTimeout(function () {
            console.log(i)
        }, 1000 * i)
    }
    ```

26. 数组去重(six)

    (1). 利用ES6 Set去重

    ```javascript
    function unique (arr) {
      return Array.from(new Set(arr)) // return [... new Set(arr)]
    }
    ```

    (2). 双层for循环 + splice

    ```javascript
    function unique (arr) {
      for (var i = 0; i < arr.length; i++) {
        for (var j = i+1; j < arr.length; j++) {
          if (arr[i] == arr[j]) {
            arr.splice(j, 1)
            j--;
          }
        }
      }
      return arr
    }
    ```

    (3). 利用indexOf去重

    ```javascript
    function unique (arr) {
      if (!Array.isArray(arr)) {
        console.log('type error!')
        return
      }
      let res = []
      for (let i = 0; i < arr.length; i++) {
        if (res.indexOf(arr[i]) === -1) {
          arr.push(arr[i])
        }
      }
      return res
    }
    ```

    (4). 利用sort()

    ```javascript
    function unique (arr) {
      if (!Array.isArray(arr)) {
        console.log('type error!')
        return
      }
      arr = arr.sort()
      let array = [arr[0]]
      for (let i = 1; i < arr.length; i++) {
        if (arr[i] !== arr[i-1]) {
          array.push(arr[i]);
        }
      }
      return array
    }
    ```

    (5). 利用includes

    ```javascript
    function unique (arr) {
      if (!Array.isArray(arr)) {
        console.log('type error!')
        return
      }
      let res = []
      for (let i = 0; i < arr.length; i++) {
        if (!res.includes(arr[i])) { // includes 检测数组是否有某个值
          res.push(arr[i])
        }
      }

      return res 
    }
    ```

    (6). for循环 + Object

    ```javascript
    function unique(arr) {
      let result = []
      let obj = {}
      for (let i of arr) {
        if (!obj[i]) {
          result.push(i)
          obj[i] = 1
        }
      }
      return result
    }
    ```

    (7). Map

    ```javascript
    function unique(arr) {
      let result = []
      let map = new Map()

      for (map i of arr) {
        if (!obj.has(i)) {
          result.push(i)
          map.set(i, 1)
        }      
      }
      return result
    }
    ```

    (7). JSON.stringify()

    ```javascript
    function unique(array) {
      var obj = {};
      return array.filter(function(item, index, array){
        console.log(typeof item + JSON.stringify(item))
        return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true)
      })
    }
    ```



28. 遍历对象的方法

    (1). 使用`Object.keys()`遍历

    * Object.values() 方法返回一个数组
    ```js
    Object.keys(obj).forEach(function (key)) {
        console.log(key, obj[key])
    }
    ```

    * Object.values() 方法返回一个数组
    ```js
    const obj = { foo: 'bar', baz: 42 };
    Object.values(obj)  // ["bar", 42]
    ```

    * Object.entries() 方法返回一个数组
    ```js
    const obj = { foo: 'bar', baz: 42 };
    Object.entries(obj)  // [ ["foo", "bar"], ["baz", 42] ]
    ```

    (2). for...in...遍历

    ```js
    for (var i in obj) {
        console.log(i, ":", obj[i])
    }
    ```

    (3). `Object.getOwnPropertyNames(obj)`

    ```js
    Object.getOwnPropertyNames(obj).forEach(function (key) {
        console.log(key, obj[key])
        })
    ```

    (4). `Reflect.ownKeys(obj)`遍历

    ```js
    Reflect.ownKeys(obj).forEach(function (key) {
        console.log(key, obj[key])
        })
    ```



29. 类数组转化为数组(six)
  Array.from()
  Array.prototype.slice.call()
  [].slice.call()
  扩展运算符
  利用concat


30. 封装axios(six)
文档：https://blog.csdn.net/weixin_44972008/article/details/114368528
视频：https://www.bilibili.com/video/BV1NJ41197u6?p=13&spm_id_from=pageDriver

    ```js
    /*
    1. 函数返回的值为promise, 成功的结果为response, 失败的结果为error
    2. 能处理多种类型的请求：GET/POST/PUT/DELETE
    3. 函数的参数为一个配置对象
        {
          url: '',
          method: '',
          params: {}，
          data: {}
        }
    4. 响应json数据自动解析为js
    */
    function axios({
      url,
      method='GET',
      params={},
      data={}
    }) {
      // 返回一个Promise对象
      return new Promise((resolve, reject) => {

        // 处理method大小写
        method = method.toUpperCase()


        // 处理params参数(拼接到url上) id=1&×××=abc
        /*
        {
          id:1,
          xxx: 'abc'
        }
        */
        let queryString=''
          Object.keys(params).forEach(key => {
            queryString += `${key}=${params[key]}&`
          })
          if (queryString) {
            // 去除最后的&
            queryString = queryString.substring(0, queryString.length-1)
            // 拼接到url
            url += '?' + queryString
          }


        // 1. 执行异步ajax请求
        // 创建xhr对象
        const request = new XMLHttpRequest()
        // 打开连接(初始化请求，没有请求)
        request.open(method, url, true)
        // 发送请求 GET/delete
        if (method === 'GET' || method === 'DELETE') {
          request.send()

        // 发送请求 POST/PUT
        } else if (method === 'POST' || method === 'PUT') {
          // 告诉服务器请求体的格式是json
          request.setRequestHeader('Content-Type', 'application/json;charset=utf-8')
          // 发送json格式请求体参数
          request.send(JSON.stringify(data))
        }


        // 绑定状态改变的监听
        request.onreadystatechange = function() {
          // 如果请求没有完成，直接结束
          if (request.readyState !== 4) {
            return 
          }
          // 如果响应状态码在[200,300)之间，代表成功，否则失败
          const {status, statusText} = request
          // 2.1 如果请求成功了，调用resolve()
          if (status >= 200 && status <= 299) {
            const response = {
              data: JSON.parse(request.response)
              status,
              statusText
            }
            resolve(response)
          // 2.2 如果失败了，调用reject()
          } else {
            reject(new Error('request error status is' + status))
          }
        } 
      })
    }

    // 发送get请求
    axios({
      url: 'http://localhost:3000/posts',
      method: 'GET',
      params: {
        id: '1',
        xxx: 'abc'
      }
    }).then(response => {
        console.log(response)
      },
      error => {
        alert(error.message)
      })

    // 发送post请求
    axios({
      url: 'http://localhost:3000/posts',
      method: 'POST',
      data: {
        'title': '番茄炒小六正在学习中',
        'author': '番茄炒小六'
      }
    })

    // 发送PUT请求
    axios({
      url: 'http://localhost:3000/posts/1',
      method: 'PUT',
      data: {
        'title': '番茄炒小六正在学习中',
        'author': '番茄炒小六'
      }
    }).then(
      response => {
        console.log(response)
      },
      error => {
        alert(error.message)
      }
    )

    // DELETE请求 删除数据
    axios({
      url: 'http://localhost:3000/posts/2',
      method: 'DELETE',
      data: {
        'title': '番茄炒小六正在学习中',
        'author': '番茄炒小六'
      }
    }).then(
      response => {
        console.log(response)
      },
      error => {
        alert(error.message)
      }
    )

    ```


31. 模拟实现Promise(six)
    ```javascript
    let p = new Promise((resolve,reject) => {
        resolve('OK')
    });
    p.then(value =>{
        console.log(value);
    },reason =>{
        console.log(reason)
    })   
    ----------------------------------------------------
    //声明构造函数
    function Promise(executor){
        //添加属性,状态及结果
        this.promiseState = 'pending'
        this.promiseResult = null
        //保存实例对象的this值
        const self = this

        //resolve函数
        function resolve(data){
            //判断状态，保证一经修改不能再改变
            if (self.promiseState !== 'pending') return

            //1.修改对象状态（promiseState）
            self.promiseState = 'funfilled';
            //2.设置对象结果值(promiseResult)
            self.promiseResult = data;
        }

        //reject函数
        function reject(data){
            //判断状态，保证一经修改不能再改变
            if (self.promiseState !== 'pending') return

            //1.修改对象状态（promiseState）
            self.promiseState = 'rejected'
            //2.设置对象结果值(promiseResult)
            self.promiseResult = data
        }

        //同步调用执行器函数
        try{
            executor(resolve,reject); 
        }catch(e){
            //修改promise对象状态为失败
            reject(e);
        }
    }

    //Promise.then实现
    Promise.prototype.then = function(onResolved,onRejected){

        //调用回调函数
        if(this.promiseState === 'fulfilled'){
            onResolved(this.promiseResult);
        }
        if(this.promiseState === 'rejected'){
            onRejected(this.promiseResult);
        }
    }




    --------------------------------------------------------
    //异步完善

    //声明构造函数
    function Promise(executor){

        //添加属性
        this.promiseState = 'pending'
        this.promiseResult = null
        //声明回调属性
        this.callbacks =[]
        //保存实例对象的this值
        const self = this

        //resolve函数
        function resolve(data){
            //判断状态，保证一经修改不能再改变
            if (self.promiseState !== 'pending') return

            //1.修改对象状态（promiseState）
            self.promiseState = 'funfilled';
            //2.设置对象结果值(promiseResult)
            self.promiseResult = data;

            //调用成功的回调函数(指定多个)
            self.callbacks.forEach(item =>{
                item.onResolved(data)
            })
        }

        //reject函数
        function reject(data){
            //判断状态，保证一经修改不能再改变
            if (self.promiseState !== 'pending') return

            //1.修改对象状态（promiseState）
            self.promiseState = 'rejected'
            //2.设置对象结果值(promiseResult)
            self.promiseResult = data

            //执行失败的回调函数(指定多个回调)
            self.callbacks.forEach(item =>{
                item.onRejected(data)
            })

        }

        //同步调用执行器函数
        try{
            executor(resolve,reject); 
        }catch(e){
            reject(e);
        } 
    }

    //Promise.then实现
    Promise.prototype.then = function(onResolved,onRejected){

        //调用回调函数
        if(this.promiseState === 'fulfilled'){
            onResolved(this.promiseResult);
        }
        if(this.promiseState === 'rejected'){
            onRejected(this.promiseResult);
        }

        //判断pending状态
        if(this.promiseState === 'pending' ){
            //保存回调函数
            this.callbacks.push({
                onResolved: onResolved,
                onRejected: onRejected
            })
        }
    }


    ---------------------------------------------------------
    //promise的all方法封装
    Promise.all = function(promise){
        return new Promise((resolve, reject) =>{
            let count = 0
            let arr = []
            //遍历
            for (let i=0; i<promise.length; i++){
                promise[i].then(v =>{
                    //得知对象的状态是成功,且每个promise都是成功的
                    count++
                    //将当前promise对象成功的结果 存入到数组中
                    arr[i] = v
                    //判断 如果count值等于Promise的长度，说明每个promise都成功
                    if(count === promise.length){
                        resolve(arr)
                    }
                },r =>{
                    reject(r)
                })
            }
        })
    }
    -------------------------------------------------------------
    //promise的race方法封装
    Promise.race = function(promise){
        return new Promise((resolve,reject) =>{
            for(let i=0; i<promise.length; i++){
                promise[i].then(v=>{
                    resolve(v)
                },r =>{
                    reject(r)
                })
            }
        });
    }

    //添加 resolve 方法
    Promise.resolve = function(value){
        //返回promise对象
        return new Promise((resolve, reject) => {
            if(value instanceof Promise){
                value.then(v=>{
                    resolve(v);
                }, r=>{
                    reject(r);
                })
            }else{
                //状态设置为成功
                resolve(value);
            }
        });
    }

    //添加 reject 方法
    Promise.reject = function(reason){
        return new Promise((resolve, reject)=>{
            reject(reason);
        });
    }


    //添加 catch 方法
    Promise.prototype.catch = function(onRejected){
        return this.then(undefined, onRejected);
    }
    ```