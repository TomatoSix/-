# 手撕代码部分

1. 模拟实现函数的call，apply，bind方法(six)
    
    (1). call

    ```javascript
     Function.prototype.myCall = function (context) {
        context = context || window
        //保存this指向
        context.fn = this
        //取出剩余参数
        let args = [...arguments].slice(1)
        //参数执行
        let result = context.fn(...args)
        //删除context.fn
        delete context.fn
        //返回结果
        return result
    }
    ```

    (2). apply

    ```javascript
    Function.prototype.myApply = function (context) {
        //默认为window
        context = context || window
        //保存this指向
        context.fn = this
        //取出剩余参数
        let args = [...arguments][1]
        // 判断是否有第二个参数
        if (!args) return context.fn()
        let res = context.fn(...args)
        delete context.fn
        return res
    }
    ```

    (3). bind

    1. 方法一

    ```javascript
    Function.prototype.myBind = function(context) {
      const fn = this
      context = context || window
      const otherArg = [...arguments].slice(1)
      const result = function() {
        const resultArg = [...arguments]
        if (this instanceof result) {
          fn.apply( this, otherArg.concat(resultArg))
        } else {
          fn.apply( context, otherArg.concat(resultArg))
        }
      }
      result.prototype = fn.prototype
      return result
    }
    ```
    2. 方法二(six)
    ```javascript
    Function.prototype.myBind = function(context) {
        if(typeof this != "function") {
            throw Error("not a function")
        }
        // 若没问参数类型则从这开始写
        let fn = this;
        let args = [...arguments].slice(1);
        
        //判断是不是new出来的
        let resFn = function() {
            return fn.apply(this instanceof resFn ? this : context,args.concat(...arguments) )
        }
        function tmp() {}
        tmp.prototype = this.prototype;
        resFn.prototype = new tmp();
        
        return resFn;
    }
    ```

2. 模拟实现函数节流和防抖方法(six)

    (1). 防抖
    在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时
    应用场景：
    1. search搜索，用户不断输入值时，用防抖来节约Ajax请求，也就是输入框事件
    2. window触发resize时，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

    ```javascript
    function debounce(fn, delay) {
      // 维护一个timer，用来记录当前函数的执行状态
      let timer = null;
      return function() {

        // 通过this和arguments获取函数的作用域和变量
        let context = this;
        let args = arguments
        // 清理正在执行的函数，并重新执行
        if(timer) clearTimeout(timer);
        timer = setTimeout(function() {
            fn.apply(context, args)
        }, delay)
      }
    }

    let flag = 0; // 记录当前函数调用次数
    // 当用户滚动时被调用的函数
    function foo() {
        flag += 1
        console.log('Number of calls: %d', flag)
    }

    // 在 debounce 中包装我们的函数，过 2 秒触发一次
    documenet.body.addEventListener('scroll', debounce(foo, 2000))
    ```

    (2). 节流
    规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。
    1. 鼠标的点击事件，mousedown只触发一次
    2. 监听滚动事件，比如是否滑到底部自动加载更多，用throttle判断

    ```javascript
    function throttle(func, delay) {
      let timer = null;

      return function() {
        let content = this
        let args = arguments
        if (!timer) {
          timer = setTimeout(function(){
            func.apply(context, args)
            timer = null
          }, delay)
        }
      }
    }
    ```

3. 模拟实现对象的深拷贝(six)

    ```

    // 第一种: JSON.parse(JSON.stringify())方法实现深拷贝
    let Obj={a:"hello",b:1,c:true,d:[1,2],e:{x:1,y:2},f:function(){console.log("copytest");},g:null,h:undefined};
    let copyObj = JSON.parse(JSON.stringify(Obj))
    console.log(copyObj)
    copyObj.a = 'change'
    copy.obj.e.x = 8
    console.log(Obj)

    // 第二种: 递归的方法实现深拷贝
    function deepClone(Obj, copyObj) {

      let copyObj = copyObj || {}
      for (let keys in Obj) {
        if (Obj.hasOwnProperty(keys)) { // 剥离原型链的数据
          if ((typeof(Obj[keys])) === 'Object' && Obj[keys] !== null) { //判断是否为引用数据类型
            if (Object.prototype.toString.call(Obj[keys]) === '[object Array]') { // Object原型方法得到类型
              copyObj[keys] = [];
            } else {
              copyObj[keys] = {}
            }
            deepClone(Obj[keys], copyObj[keys])
          } else {
            copyObj[keys] = Obj[keys]
          }
        }
      }
      return copyObj
    }

    ```


    ```
    //考虑到数组、循环引用、性能优化
    function clone(target, map = new WeakMap()) {
      if (typeof target === 'object'){
        const isArray = Array.isArray(target)
        let cloneTarget = isArray ? []:{}

        if (map.get(target)) {
          return map.get(target)
        }
        map.set(target, cloneTarget)

        const keys = isArray ? undefined : Object.keys(target)
        forEach(keys || target, (value, key) => {
          if (keys) {
            key = value
          }
          cloneTarget[key] = clone(target[key], map)
        })

        return cloneTarget
      } else {
        return target
      }
    }
    ```

4. 嵌套数组指定层次展开flat扁平化(six)

    ```javascript
    // 1. 普通方法递归
    const res = []
    const flatten = arr => {
      for (let i = 0; i < arr.length; i++) {
        if (Array.isArray(arr[i])) {
          flatten(arr[i])
        } else {
          res.push(arr[i])
        }
      }
    }

    // 2. concat
    function flatten(arr) {
      let res = []
      arr.forEach(item => {
        if (Array.isArray(item)) {
            res = res.concat(flattenMd(item))
        } else {
            res.push(item)
        }
      })
      return res
    }

    // 3. reduce
    function flattenMd(arr) {
      return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur)
      , []} 
    }

    // 4. 扩展运算符
    function flattenMd(arr) {
      let flatten = arr => [].concat(...arr)
      return flatten(arr.map(item => Array.isArray(item) ? flattenMd(item) : item ))
    }

    // 5. join和split组合
    function flattenMd(arr) {
      return arr.join().split(',')
    }

    // 6. ES6的flat方法
    arr = [1,2,3,[4,[5,6]]]
    const res = arr.flat(Infinity)

    // 7. 正则
    const res = JSON.stringify(arr).replace(/\[|\]/g, '').split(',');

    ```

5. 模拟实现reduce方法(six)

    ```javascript
    // reduce() 函数接受两个参数，一个函数一个积累变量的初始值
    // 函数有四个参数: 累计变量初始值(默认第一个成员)，当前变量值(默认第二个成员)，当前位置，数组自身
    // arr.reduce(function(prev, cur, index, arr){}, initialValue)
    Array.prototype.myReduce = function(cb,initValue){
        if (!Array.isArray(this)){
            throw new TypeError('不是数组')
        }
        // 数组为空
        if (arguments.length <2 && this.length ===0){
            throw new TypeError('数组为空')
        }

        let arr = this
        let res = null
        if (arguments.length > 1){
            res = initValue
        }else{
            res = arr.splice(0,1)[0]
        }
        arr.forEach((item,index) =>{
            prev = cb(prev,item,index,arr)
        })
        return cb
    }
    ```

6. 模拟实现数组map方法(six)

    ```
    // arr.map((currentValue, index, curr) => {})
    // currentValue 必须。 当前元素的值
    // index 可选。 当期元素的索引值
    // arr 可选。 当期元素属于的数组对象

    Array.prototype.newMap = function(fn) {

        let newArr = [];
        for (let i = 0; i < this.length; i++) {
            newArr.push(fn(this[i], i, this)) // this指向调用newMap方法的数组
        }
        return newArr
    }

    Array.prototype.newMap = function (fn, Arg) { ////写法二：用数组的reduce方法实现数组的map
        let res = [];
        this.reduce((prev, curr, index, array) => {
            res.push(fn.call(Arg, curr, index, array));
        }, 0) //指定初始值initialValue=0，所以从currentIndex=0开始，即第一个开始  不这样会缺第一项，结果为[3,4]
        return res;
    }
 

    let arr = [1, 2, 3];
    let res = arr.newMap((a) => a + 1);
    console.log(res);

    ```

7. 模拟实现Array.fill(), Array.filter()

    ```

    // array.fill(value, start, end)
    Array.prototype.myFill = function (value, start = 0, end = this.length) {
        for (let i = start; i < end; i++) {
            this[i] = value
        }
    }

    // array.filter()
    Array.prototype.myFilter = function myFilter(fn, context) {
        if (typeof fn !== 'function') {
            throw new TypeError(`${fn} is not a function`)
        }
        let arr = this;
        let temp = [];
        for (let i = 0; i < arr.length; i++) {
            let res = fn.call(context, arr[i], i, arr)
            if (res) temp.push(arr[i])
        }
        return temp
    }

    ```

8. 模拟实现Array.find(), Array.findIndex()

    ```

    Array.prototype.myFind = function (fn, start = 0, end = this.length) {

        for (let i = start; i < end; i++) {
            if (fn.call(this, this[i], i, this)) {
                return this[i]
            }
        }

    }

    Array.prototype.myFind = function (fn, start = 0, end = this.length) {

        for (let i = start; i < end; i++) {
            if (fn.call(this, this[i], i, this)) {
                return i
            }
        }

        return -1

    }

    ```

9. 模拟实现Promise.all方法和Promise.race

    ```
    Promise.prototype.myAll = function(promises) {
      let results = [];
      let promiseCount = 0;
      let promisesLength = promises.length;
      return new Promise(function(resolve, reject) {
        for (let i = 0; i < promises.length; i++) {
            const val = promises[i]
            Promise.resolve(val).then(function(res) {
                promiseCount++;
                results[i] = res;
                // 当所有函数都正确执行了，resolve输出所有返回结果。
                if (promiseCount === promisesLength) {
                return resolve(results);
            }
          }, function(err) {
            return reject(err);
          });
        }
      });
    };

    // promise.race();
    // 这么简单得益于promise的状态只能改变一次，即resolve和reject都只被能执行一次
    Promise.prototype.myRace = function (promises) {

        return new Promise(function (resolve, reject) {
            for (let i = 0; i < promises.length; i++) {
                primises[i].then(resolve, reject)
            }
        })

    }
    ```

10. 使用原生JS实现ajax请求

    ```
    let xhr = new XMLHttpRequest(); // 创建XMLHttpRequest
    let url = 'https://steven.com'
    xhr.onreadystatechange = function() { // 监听状态码的变化，每次变化均执行
      if (xhr.readyState === 4) {
        if (xhr.status === 200) { // 服务端状态码
          console.log(xhr.responseText); // 服务器返回的响应文本
        } else {
          console.error(xhr.statusText) // 状态码的文本描述，如200的statusText是ok
        }
      }
    }
    xhr.open('GET', url, true); // 初始化请求参数，还没发送请求   true表示异步
    xhr.send(null) // 向服务器发送请求,但是不带有数据发送过去,一般在get方式发送时候多使用这个方式
    ```

11. 模拟实现构造函数new的过程(six)

    ```
    function Mynew() {
        let Constructor = Array.prototype.shift.call(arguments) // 1. 取出构造函数

        let obj = {} // 2. 创建一个新的对象

        obj.__proto__ = Constructor.prototype // 3. 该对象的原型等于构造函数的prototype

        let result = Constructor.apply(obj, arguments) // 4. 执行函数中的代码

        return typeof reuslt === 'object' ? result : obj // 5. 返回值必须是对象

    }
    //我的
    function myNew () {
      // 1. 获取构造函数，并且删除 arguments 中的第一项，shift()会返回删除的元素，由con接收
      var Con = [].shift.call(arguments);
      //或者 var Con = Array.prototype.shift.call(arguments)
      // 2. 创建一个空的对象并链接到构造函数的原型，使它能访问原型中的属性
      var obj = Object.create(Con.prototype);
      //或者 obj.__proto__ = Con.prototype
      // 3. 使用apply改变构造函数中this的指向实现继承，使obj能访问到构造函数中的属性
      var result = Con.apply(obj, arguments);
      // 4. 优先返回构造函数返回的对象
      return result instanceof Object ? result : obj;
    }
    ```

12. 模拟实现Object.create方法

    ```
    // 用于创建一个新对象,被创建的对象继承另一个对象(o)的原型
    function createObj(o) { //传入的参数o为返回实例的__porto__,也就是实例构造函数的显示原型
        function F() {} //构造函数
        F.prototype = o;
        return new F(); // 返回实例
    }
    ```

13. 模拟实现instanceof的功能

    ```
    function instanceofObj(a, b) {
        // 模拟 a instanceof b
        let prototypeB = b.prototype;
        let protoA = a.__proto__;
        let state = false;
        while (true) {

            if (protoA == null) { // 可能是undefined
                state = false;
                break
            }

            if (prototypeB === protoA) {
                state = true;
                break;
            }
            protoA = protoA.__proto__

        }

        return state
    }

    console.log(instanceofObj([], Array));
    instanceofObj([], Array); //true


    //手写Instanceof2
    function myInstanceof(left,right){
        
        let proto = left.__proto__
        while (true){
            if (left == null) return false
            if (left == right.prototype){
                return true
            }
            proto = proto.__proto__
        }
    }
    ```

14. 使用setTimeout实现setInterval方法

    ```
    function mysetinterval(fn,time){
        console.log("利用steTimeout实现setInterval");
        function interval(){//执行该函数，异步被挂起time时间后在执行，一上来就执行fn
            setTimeout(interval,time);//异步
            //好，time时间过去，这个异步被执行，而内部执行的函数正是interval，就相当于进了一个循环，递归
            fn();//同步
        }
        setTimeout(interval,time);//interval被延迟time时间执行
    }
    ```

15. 实现jsonp

    ```
    let newscript = document.createElement('script')
    newscript.src = 'url'
    document.body.appendChild(newscript)
    function foo(data) { // callback函数要绑定在window对象上
        console.log(data)
    }
    ```

16. promise实现sleep函数

    ```
    async function test() {
        console.log('start')
        await sleep(4000)
        console.log('end')
    }

    function sleep(ms) {
        return new Promise(resolve => {
            setTimeout(resolve, ms)
        })
    }

    test()
    ```

17. 数组转树

    ```
    function turnToTreeOfManyRootPlus(arr) {
      var arrs = []
      arr.forEach(item => {
        if (!item.parentMenu) {
          arrs.push(item)
        }
      })
     
      return arr.reduce((h, m) => {
        if (m.parentMenu) {
          foo(h, m)
        }
     
        function foo(arr, cur) {
          arr.forEach(item => {
            if (item.menuId === cur.parentMenu) {
              if (!item.children) {
                item.children = []
              }
              item.children.push(cur)
            } else if (item.children) {
              foo(item.children, cur)
            }
          })
        }
     
        return h
      }, arrs)
    }


    ```

18. 实现slice方法

    ```
    Array.prototype.slice2 = function (start, end) {
      let len = this.length;
      let l = start === undefined ? 0 : start < 0 ? Math.max(start + len, 0) : Math.min(start, len);
      let r = end === undefined ? len : end < 0 ? Math.max(end + len, 0) : Math.min(end, len);
      const res = [];
      while (l < r) {
        res.push(this[l++])
      }
      return res;
    }
    ```

19. LRU算法

    ```
    class LRUListNode:
        def __init__(self, key=0, value=0, next=None, prev=None):
            self.key = key
            self.value = value
            self.next = next
            self.prev = prev

    class LRUCache:

        def __init__(self, capacity: int):
            self.capacity = capacity
            self.head = LRUListNode()
            self.tail = LRUListNode()
            self.head.next = self.tail
            self.tail.prev = self.head
            self.cache = dict()
            self.size = 0
            

        def get(self, key: int) -> int:
            
            if key not in self.cache:
                return -1
            node = self.cache[key]
            self.moveToHead(node)
            return node.value
            

        def put(self, key: int, value: int) -> None:
            
            if key not in self.cache:
                node = LRUListNode(key, value)
                self.cache[key] = node
                self.addTohead(node)
                self.size += 1
                if self.size > self.capacity:
                    removed = self.removeTail()
                    self.cache.pop(removed.key)
                    self.size -= 1
            else:
                node = self.cache[key]
                node.value = value
                self.moveToHead(node)
                
        def removeTail(self):
            node = self.tail.prev
            self.remove(node)
            return node
        
        def moveToHead(self, node):
            self.remove(node)
            self.addTohead(node)
        
        def addTohead(self, node):
            nxt = self.head.next
            self.head.next = node
            node.next = nxt
            node.prev = self.head
            nxt.prev = node
        
        def remove(self, node):
            node.prev.next = node.next
            node.next.prev = node.prev
    ```

    ```
    class DoubleLinkedListNode {
        constructor(key, value) {
            this.key = key;
            this.value = value;
            this.prev = null;
            this.next = null;
        }
    }

    class LRUCache {
        constructor(capacity) {
            this.capacity = capacity;
            // Mappings of key->node.
            this.hashmap = {};
            // Use two dummy nodes so that we don't have to deal with the head/tail seperately.
            this.dummyHead = new DoubleLinkedListNode(null, null);
            this.dummyTail = new DoubleLinkedListNode(null, null);
            this.dummyHead.next = this.dummyTail;
            this.dummyTail.prev = this.dummyHead;
        }

        _isFull() {
            return Object.keys(this.hashmap).length === this.capacity;
        }

        _removeNode(node) {
            node.prev.next = node.next;
            node.next.prev = node.prev;
            node.prev = null;
            node.next = null;
            return node;
        }

        _addToHead(node) {
            const head = this.dummyHead.next;
            node.next = head;
            head.prev = node;
            node.prev = this.dummyHead;
            this.dummyHead.next = node;
        }

        get(key) {
            if (key in this.hashmap) {
                const node = this.hashmap[key];
                this._addToHead(this._removeNode(node));
                return node.value;
            } else {
                return -1;
            }
        }

        put(key, value) {
            if (key in this.hashmap) {
                // If key exists, update the corresponding node and move it to the head.
                const node = this.hashmap[key];
                node.value = value;
                this._addToHead(this._removeNode(node));
            } else {
                // If it's a new key.
                if (this._isFull()) {
                    // If the cache is full, remove the tail node.
                    const node = this.dummyTail.prev;
                    delete this.hashmap[node.key];
                    this._removeNode(node);
                }
                // Create a new node and add it to the head.
                const node = new DoubleLinkedListNode(key, value);
                this.hashmap[key] = node;
                this._addToHead(node);
            }
        }
    }
    ```

20. 发布订阅模式

    ```
    // 公众号对象
    let eventEmitter = {};

    // 缓存列表，存放 event 及 fn
    eventEmitter.list = {};

    // 订阅
    eventEmitter.on = function (event, fn) {
        let _this = this;
        // 如果对象中没有对应的 event 值，也就是说明没有订阅过，就给 event 创建个缓存列表
        // 如有对象中有相应的 event 值，把 fn 添加到对应 event 的缓存列表里
        (_this.list[event] || (_this.list[event] = [])).push(fn);
        return _this;
    };

    // 发布
    eventEmitter.emit = function () {
        let _this = this;
        // 第一个参数是对应的 event 值，直接用数组的 shift 方法取出
        let event = [].shift.call(arguments),
            fns = [..._this.list[event]];
        // 如果缓存列表里没有 fn 就返回 false
        if (!fns || fns.length === 0) {
            return false;
        }
        // 遍历 event 值对应的缓存列表，依次执行 fn
        fns.forEach(fn => {
            fn.apply(_this, arguments);
        });
        return _this;
    };

    function user1 (content) {
        console.log('用户1订阅了:', content);
    };

    function user2 (content) {
        console.log('用户2订阅了:', content);
    };

    // 订阅
    eventEmitter.on('article', user1);
    eventEmitter.on('article', user2);

    // 发布
    eventEmitter.emit('article', 'Javascript 发布-订阅模式');

    /*
        用户1订阅了: Javascript 发布-订阅模式
        用户2订阅了: Javascript 发布-订阅模式
    */
    ```

21. 数据双向绑定

    ```
    var obj = {};
    Object.defineProperty(obj,"name",{
        get:function(){
            console.log("get方法被调用了");
            return name;
        },
        set:function(val){
            name = val;
            console.log("set方法被调用了，参数是"+val);
        }
    });
    obj.name="张三";
    console.log(obj.name);
    ```

22. 手写字符串方法trim()

    ```
    function Trim() {

        let str = this
        let i = 0
        let j = str.length-1
        while (str[i] === '') {
            i += 1
        }
        while (str[j] === ' ') {
            j -= 1
        }

        let res = ''
        for (let c = i; c <= j; c++) {
            res += str[c]
        }

        return res

    }
    ```

23. 懒加载
    
    (1).将需要懒加载的img标签的src设置缩略图或者不设置src，这里的占位图可以是缺省图，loading图；
    (2).判断该img标签是否在浏览器可视区域，如果在可视区域，则将真实的图片url设置到img标签的src属性；
    (3).用户滚动浏览器，遍历需要懒加载的标签，根据步骤2判断并执行；

    ```
    let imgs = document.getElementTageName('img')
    let num = imgs.length
    let n = 0; // 存储图片加载到的位置，避免每次都从第一张图片开始遍历

    function lazyload() {

        let seeHeight = document.documentElement.clientHeight // 可见区域高度
        let scrollTop = document.documentElement.scrollTop || document.body.scrollTop //滚动条距离顶部高度
        for (let i = n; i < num; i++) {

            if (imgs[i].offsetTop < seeHeight + scrollTop) {
                if (imgs[i].getAttribute('src') === 'default.jpg') {
                    imgs[i].src = img[i].getAttribute('data-src')
                }
                n = i+1
            }

        }

    }
    ```

24. 函数柯理化

    ```
    function curry(func) {

      return function curried(...args) {
        if (args.length >= func.length) {
          return func.apply(this, args);
        } else {
          return function(...args2) {
            return curried.apply(this, args.concat(args2));
          }
        }
      };

    }

    let add = function() {

        let args = Array.prototype.slice.call(arguments);

        let inner = function() {
            args.push(...arguments)
            return inner
        }

        inner.toString = function() {

            return args.reduce((pre, curr) {
                return pre + curr
            })

        }

    }
    ```

25. `setTimeout`输出1，2，3，4，5

    ```
    // 闭包的使用
    for (var i=1; i < 6; i++) {
        (function (j) {
                setTimeout(function timer() {
                console.log(j)
                }, 1000*j)
            })(i)
    }

    // 利用setTimeout第三个参数
    for (var i=1; i < 6; i++) {
        setTimeout(function timer(j) {
            console.log(j)
            }, 1000 * i, i)
    }

    // 利用let形成块级作用域
    for (let i = 1; i < 6; i++) {
        setTimeout(function () {
            console.log(i)
            }, 1000 * i)
    }
    ```

26. 数组去重(six)

    (1). 利用ES6 Set去重

    ```javascript
    function unique (arr) {
      return Array.from(new Set(arr)) // return [... new Set(arr)]
    }
    ```

    (2). 双层for循环 + splice

    ```javascript
    function unique (arr) {
      for (var i = 0; i < arr.length; i++) {
        for (var j = i+1; j < arr.length; j++) {
          if (arr[i] == arr[j]) {
            arr.splice(j, 1)
            j--;
          }
        }
      }
      return arr
    }
    ```

    (3). 利用indexOf去重

    ```javascript
    function unique (arr) {
      if (!Array.isArray(arr)) {
        console.log('type error!')
        return
      }
      let res = []
      for (let i = 0; i < arr.length; i++) {
        if (res.indexOf(arr[i]) === -1) {
          arr.push(arr[i])
        }
      }
      return res
    }
    ```

    (4). 利用sort()

    ```javascript
    function unique (arr) {
      if (!Array.isArray(arr)) {
        console.log('type error!')
        return
      }
      arr = arr.sort()
      let array = [arr[0]]
      for (let i = 1; i < arr.length; i++) {
        if (arr[i] !== arr[i-1]) {
          array.push(arr[i]);
        }
      }
      return array
    }
    ```

    (5). 利用includes

    ```javascript
    function unique (arr) {
      if (!Array.isArray(arr)) {
        console.log('type error!')
        return
      }
      let res = []
      for (let i = 0; i < arr.length; i++) {
        if (!res.includes(arr[i])) { // includes 检测数组是否有某个值
          res.push(arr[i])
        }
      }

      return res 
    }
    ```

    (6). for循环 + Object

    ```javascript
    function unique(arr) {
      let result = []
      let obj = {}
      for (let i of arr) {
        if (!obj[i]) {
          result.push(i)
          obj[i] = 1
        }
      }
      return result
    }
    ```

    (7). Map

    ```javascript
    function unique(arr) {
      let result = []
      let map = new Map()

      for (map i of arr) {
        if (!obj.has(i)) {
          result.push(i)
          map.set(i, 1)
        }      
      }
      return result
    }
    ```

    (7). JSON.stringify()

    ```javascript
    function unique(array) {
      var obj = {};
      return array.filter(function(item, index, array){
        console.log(typeof item + JSON.stringify(item))
        return obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true)
      })
    }
    ```

27. 写一个抽奖方法。有四等奖品，中奖概率如下 一等奖：10%，二等奖：15%，三等奖：25%，四等奖：50%；

    ```
    const lottery = () => {

      const randomNum = Math.round(Math.random() * 100)
      console.log(randomNum);

      if (randomNum >= 0 && randomNum < 10) {
        return console.log('First Prize')
      } else if (randomNum >= 10 && randomNum < 25) {
        return console.log('Second Prize')
      } else if (randomNum >= 25 && randomNum < 50) {
        return console.log('Third Prize')
      } else {
        return console.log('Forth Prize')
      }

    }

    lottery()
    ```

28. 遍历对象的方法

    (1). 使用`Object.keys()`遍历

    ```
    Object.keys(obj).forEach(function (key)) {
        console.log(key, obj[key])
    }
    ```

    (2). for...in...遍历

    ```
    for (var i in obj) {
        console.log(i, ":", obj[i])
    }
    ```

    (3). `Object.getOwnPropertyNames(obj)`

    ```
    Object.getOwnPropertyNames(obj).forEach(function (key) {
        console.log(key, obj[key])
        })
    ```

    (4). `Reflect.ownKeys(obj)`遍历

    ```
    Reflect.ownKeys(obj).forEach(function (key) {
        console.log(key, obj[key])
        })
    ```








29. 类数组转化为数组(six)

  1. Array.from()

  2. Array.prototype.slice.call()
  
  3. 扩展运算符
  
  4. 利用concat

30. 模拟实现Promise(six)
  ```javascript
  let p = new Promise((resolve,reject) => {
      resolve('OK')
  });
  p.then(value =>{
      console.log(value);
  },reason =>{
      console.log(reason)
  })

  ----------------------------------------------------
  //声明构造函数
  function Promise(executor){
      //添加属性,状态及结果
      this.promiseState = 'pending'
      this.promiseResult = null
      //保存实例对象的this值
      const self = this

      //resolve函数
      function resolve(data){
          //判断状态，保证一经修改不能再改变
          if (self.promiseState !== 'pending') return

          //1.修改对象状态（promiseState）
          self.promiseState = 'funfilled';
          //2.设置对象结果值(promiseResult)
          self.promiseResult = data;
      }

      //reject函数
      function reject(data){
          //判断状态，保证一经修改不能再改变
          if (self.promiseState !== 'pending') return

          //1.修改对象状态（promiseState）
          self.promiseState = 'rejected'
          //2.设置对象结果值(promiseResult)
          self.promiseResult = data
      }

      //同步调用执行器函数
      try{
          executor(resolve,reject); 
      }catch(e){
          //修改promise对象状态为失败
          reject(e);
      }
  }

  //Promise.then实现
  Promise.prototype.then = function(onResolved,onRejected){

      //调用回调函数
      if(this.promiseState === 'fulfilled'){
          onResolved(this.promiseResult);
      }
      if(this.promiseState === 'rejected'){
          onRejected(this.promiseReuslt);
      }
  }

  --------------------------------------------------------
  //异步完善

  //声明构造函数
  function Promise(executor){

      //添加属性
      this.promiseState = 'pending'
      this.promiseResult = null
      //声明回调属性
      this.callbacks =[]
      //保存实例对象的this值
      const self = this


      //resolve函数
      function resolve(data){
          //判断状态，保证一经修改不能再改变
          if (self.promiseState !== 'pending') return

          //1.修改对象状态（promiseState）
          self.promiseState = 'funfilled';
          //2.设置对象结果值(promiseResult)
          self.promiseResult = data;

          //调用成功的回调函数(指定多个)
          self.callbacks.forEach(item =>{
              item.onResolved(data)
          })
      }

      //reject函数
      function reject(data){
          //判断状态，保证一经修改不能再改变
          if (self.promiseState !== 'pending') return

          //1.修改对象状态（promiseState）
          self.promiseState = 'rejected'
          //2.设置对象结果值(promiseResult)
          self.promiseResult = data

          //执行失败的回调函数(指定多个回调)
          self.callbacks.forEach(item =>{
              item.onRejected(data)
          })

      }

      //同步调用执行器函数
      try{
          executor(resolve,reject); 
      }catch(e){
          reject(e);
      } 
  }

  //Promise.then实现
  Promise.prototype.then = function(onResolved,onRejected){

      //调用回调函数
      if(this.promiseState === 'fulfilled'){
          onResolved(this.promiseResult);
      }
      if(this.promiseState === 'rejected'){
          onRejected(this.promiseReuslt);
      }

      //判断pending状态
      if(this.promiseState === 'pending' ){
          //保存回调函数
          this.callbacks.push({
              onResolved: onResolved,
              onRejected: onRejected
          })
      }
  }


  ---------------------------------------------------------
  //promise的all方法封装
  Promise.all = function(promise){
      return new Promise((resolve, reject) =>{
          let count = 0
          let arr = []
          //遍历
          for (let i=0; i<promise.length; i++){
              promise[i].then(v =>{
                  //得知对象的状态是成功,且每个promise都是成功的
                  count++
                  //将当前promise对象成功的结果 存入到数组中
                  arr[i] = v
                  //判断 如果count值等于Promise的长度，说明每个promise都成功
                  if(count === promise.length){
                      resolve(arr)
                  }
              },r =>{
                  reject(r)
              })
          }
      })
  }
  -------------------------------------------------------------
  //promise的race方法封装
  Promise.race = function(promise){
      return new Promise((resolve,reject) =>{
          for(let i=0; i<promise.length; i++){
              promise[i].then(v=>{
                  resolve(v)
              },r =>{
                  reject(r)
              })
          }
      });
  }


  //添加 resolve 方法
  Promise.resolve = function(value){
      //返回promise对象
      return new Promise((resolve, reject) => {
          if(value instanceof Promise){
              value.then(v=>{
                  resolve(v);
              }, r=>{
                  reject(r);
              })
          }else{
              //状态设置为成功
              resolve(value);
          }
      });
  }

  //添加 reject 方法
  Promise.reject = function(reason){
      return new Promise((resolve, reject)=>{
          reject(reason);
      });
  }


  //添加 catch 方法
  Promise.prototype.catch = function(onRejected){
      return this.then(undefined, onRejected);
  }
  ```