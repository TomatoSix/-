最全的手写 JS 面试题
https://juejin.cn/post/6968713283884974088#heading-26

「中高级前端面试」JavaScript 手写代码无敌秘籍
https://juejin.cn/post/6844903809206976520#heading-1

关于 JS 中一些重要的 api 实现, 巩固你的原生 JS 功底
https://juejin.cn/post/6844903924520992782

# 手撕代码部分

# 小技巧

1. 创建二维数组

   ```js
   // 值为0
   let dp = new Array(5).fill().map((item) => Array(4).fill(0));
   // 值为undefined
   const dp = Array(m)
     .fill()
     .map((item) => Array(n));
   ```

2. 不同路径问题

   ```js
   let dp = [0, 0, 0, 1, 0, 1];
   for (let i = 0; i < dp.length && dp[i] === 0; i++) {
     dp[i] = "障碍";
   }
   console.log(dp); //['障碍', '障碍', '障碍', 1, 0, 1]
   ```

   ```js
   let dp = [0, 0, 0, 1, 0, 1];
   for (let i = 0; i < dp.length; i++) {
     if (dp[i] === 0) {
       dp[i] = "障碍";
     }
   }
   console.log(dp); // ['障碍', '障碍', '障碍', 1, '障碍', 1]
   ```

3. sort 用法

   ```js
   sort((a, b) => a - b); // 可以解决数组中重复数字的排序问题
   sort(); //可以解决字符串的排序问题
   ```

4. 对象的使用

   ```js
   let m = "name",
     n = "age";
   const obj = {
     [m]: "小六",
     [n]: 19,
   };
   const obj2 = {
     m: "小六",
     n: 19,
   };
   console.log(obj); // {name: '小六', age: 19}
   console.log(obj2); // {m: '小六', n: 19}
   ```

5. || 与 三元表达式的使用

   ```js
   let res = a || b; // 若a为null或者undefined, 为false, 则 res = b

   let res = a ? "000" : "111"; // 若a 为null或者undefined, 三元表达式会认为存在， 则 res = 111
   ```

# 手撕代码

1.  模拟实现函数的 call，apply，bind 方法(six)

    1. call

       ```javascript
       //context表示第一个参数
       Function.prototype.myCall = function (context) {
         context = context || window;
         //设置fn为调用 myCall 的方法
         // 把this绑定到 context.fn上
         context.fn = this;
         //取出剩余参数
         let args = [...arguments].slice(1);
         //调用这个方法，将剩余参数传递进去
         let result = context.fn(...args);
         //删除context.fn
         delete context.fn;
         //返回结果
         return result;
       };
       ```

       ```js
       Function.prototype.myCall = function (thisArg, ...args) {
         // this指向xxx.call()中的xxx
         const fn = this;
         // 将传入的基本数据类型转化成对象， 利用Object()
         // 当传入null或者undefined, 则绑定window
         thisArg =
           thisArg !== null && thisArg !== undefined ? Object(thisArg) : window;
         // 在对象上绑定xxx函数
         thisArg.fn = fn;
         var result = thisArg.fn(...args);
         delete thisArg.fn;
         return result;
       };
       ```

    2. apply

       ```javascript
       Function.prototype.myApply = function (context) {
         //默认为window
         context = context || window;
         //保存this指向
         context.fn = this;
         //取出剩余参数
         let args = [...arguments][1];
         // 判断是否有第二个参数
         if (!args) return context.fn();
         let res = context.fn(...args);
         delete context.fn;
         return res;
       };
       ```

       ```js
       Function.prototype.myApply = function (thisArg, argArray) {
         fn = this;

         thisArg =
           thisArg !== null && thisArg !== undefined ? Object(thisArg) : window;

         thisArg.fn = fn;

         // 判断argArray是否存在, 因为...undefined会报错
         argArray = argArray || [];
         var result = thisArg.fn(...argArray);

         delete thisArg.fn;
         return result;
       };
       ```

    3. bind

       1. 方法一(six)

          ```javascript
          Function.prototype.myBind = function (context) {
            // 设置fn 为调用myCll的方法
            const fn = this;
            context = context || window;
            // 获取该方法剩余参数
            const otherArg = [...arguments].slice(1);
            // 设置返回的一个新方法
            const result = function () {
              // 获取返回方法体的参数
              const resultArg = [...arguments];
              if (this instanceof result) {
                // 如果是通过new 调用的，绑定this为实例对象
                fn.apply(this, otherArg.concat(resultArg));
              } else {
                // 否则普通函数形式绑定context
                fn.apply(context, otherArg.concat(resultArg));
              }
            };
            // 绑定原型链
            // result.prototype = fn.prototype
            result.prototype = Object.create(fn.prototype);
            return result;
          };
          ```

       2. 方法二(six)

          ```javascript
          Function.prototype.myBind = function (context) {
            if (typeof this != "function") {
              throw Error("not a function");
            }
            // 若没问参数类型则从这开始写
            let fn = this;
            // 获取该方法剩余参数
            let args = [...arguments].slice(1);

            //判断是不是new出来的
            let resFn = function () {
              return fn.apply(
                this instanceof resFn ? this : context,
                args.concat(...arguments)
              );
            };
            function tmp() {}
            tmp.prototype = this.prototype;
            resFn.prototype = new tmp();

            return resFn;
          };
          ```

       3. 方法三

          ```js
          Function.prototype.myBind = function (thisArg, ...argArray) {
            // 1.获取真实需要调用的函数
            var fn = this;
            // 2. 绑定this
            thisArg =
              thisArg !== null && thisArg !== undefined
                ? Object(thisArg)
                : window;

            function proxyFn(...args) {
              thisArg.fn = fn;
              // 对两个传入的参数进行合并
              var finalArgs = [...argArray, ...args];
              var result = thisArg.fn(...finalArgs);

              delete thisArg.fn;
              return result;
            }

            return proxyFn;
          };
          ```

2.  模拟实现函数节流和防抖方法(six)
    https://juejin.cn/post/6844903651278848014

    伢羽 防抖
    https://github.com/mqyqingfeng/Blog/issues/22
    伢羽 节流
    https://github.com/mqyqingfeng/Blog/issues/26

    1. 防抖
       在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时
       应用场景：

       1. search 搜索，用户不断输入值时，用防抖来节约 Ajax 请求，也就是输入框事件
       2. window 触发 resize 时，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

       ```javascript
       function debounce(fn, delay) {
         // 维护一个timer，用来记录当前函数的执行状态
         let timer = null;
         return function () {
           // 通过this和arguments获取函数的作用域和变量
           let self = this;
           let args = Array.from(arguments);
           // 清理正在执行的函数，并重新执行
           if (timer) clearTimeout(timer);
           timer = setTimeout(function () {
             fn.apply(self, args);
           }, delay);
         };
       }

       let flag = 0; // 记录当前函数调用次数
       // 当用户滚动时被调用的函数
       function foo() {
         flag += 1;
         console.log("Number of calls: %d", flag);
       }

       // 在 debounce 中包装我们的函数，过 2 秒触发一次
       document.body.addEventListener("scroll", debounce(foo, 2000));
       ```

       ```js
       const input = document.querySelector("input");

       var debounce = function (fn, delay) {
         // 1. 定义一个定时器， 保存上一次的定时器
         let timer = null;

         // 2. 真正执行的函数
         const _debounce = function (...args) {
           // 取消上一次的定时器
           if (timer) clearTimeout(timer);
           // 延迟执行
           timer = setTimeout(() => {
             fn.apply(this, args);
           }, delay);
         };

         return _debounce;
       };

       var inputChange = function () {
         console.log("你打印了");
       };
       input.oninput = debounce(inputChange, 2000);
       ```

       ```js
       const input = document.querySelector("input");

       var debounce = function (fn, delay, immediate = false) {
         // 1. 定义一个定时器， 保存上一次的定时器
         let timer = null;
         let isInvoke = false;
         // 2. 真正执行的函数
         const _debounce = function (...args) {
           // 取消上一次的定时器
           if (timer) clearTimeout(timer);

           // 是否立即执行
           if (immediate && !isInvoke) {
             fn.apply(this, args);
             isInvoke = true;
           } else {
             // 延迟执行
             timer = setTimeout(() => {
               fn.apply(this, args);
               isInvoke = false;
             }, delay);
           }
         };

         return _debounce;
       };

       var inputChange = function () {
         console.log("你打印了");
       };
       input.oninput = debounce(inputChange, 2000);
       ```

    2. 节流
       规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

       1. 鼠标的点击事件，mousedown 只触发一次
       2. 监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 判断

       ```javascript
       function throttle(fn, delay) {
         let timer = null;
         let startTime = Date.now();
         return function () {
           let curTime = Data.now();
           let remaining = delay - (curTime - startTime);
           let self = this;
           let args = [...arguments];
           clearTimeout(timer);
           if (remaining <= 0) {
             fn.apply(self, args);
             startTime = Date.now();
           } else {
             timer = setTimeout(() => {
               fn.apply(self, remaining);
             }, remaining);
           }
         };
       }
       ```

3.  模拟实现对象的深拷贝(six)

    ```javascript
    // 第一种: JSON.parse(JSON.stringify())方法实现深拷贝
    let Obj = {
      a: "hello",
      b: 1,
      c: true,
      d: [1, 2],
      e: { x: 1, y: 2 },
      f: function () {
        console.log("copytest");
      },
      g: null,
      h: undefined,
    };
    let copyObj = JSON.parse(JSON.stringify(Obj));
    console.log(copyObj);
    copyObj.a = "change";
    copy.obj.e.x = 8;
    console.log(Obj);

    // 第二种: 递归的方法实现深拷贝
    function deepClone(Obj, copyObj) {
      let copyObj = copyObj || {};
      for (let keys in Obj) {
        if (Obj.hasOwnProperty(keys)) {
          // 剥离原型链的数据
          if (typeof Obj[keys] === "Object" && Obj[keys] !== null) {
            //判断是否为引用数据类型
            if (
              Object.prototype.toString.call(Obj[keys]) === "[object Array]"
            ) {
              // Object原型方法得到类型
              copyObj[keys] = [];
            } else {
              copyObj[keys] = {};
            }
            deepClone(Obj[keys], copyObj[keys]);
          } else {
            copyObj[keys] = Obj[keys];
          }
        }
      }
      return copyObj;
    }
    ```

    ```javascript
    //考虑到数组、循环引用、性能优化
    function clone(target, map = new WeakMap()) {
      if (typeof target === "object") {
        const isArray = Array.isArray(target);
        let cloneTarget = isArray ? [] : {};

        if (map.get(target)) {
          return map.get(target);
        }
        map.set(target, cloneTarget);

        const keys = isArray ? undefined : Object.keys(target);
        forEach(keys || target, (value, key) => {
          if (keys) {
            key = value;
          }
          cloneTarget[key] = clone(target[key], map);
        });

        return cloneTarget;
      } else {
        return target;
      }
    }
    ```

    ```javascript
    // 不考虑性能优化
    function clone(target, map = new WeakMap()) {
      if (typeof target === "object") {
        let isArray = Array.isArray(target);
        let cloneTarget = isArray ? [] : {};

        if (map.get(target)) {
          return map.get(target);
        }
        map.set(target, cloneTarget);
        for (let key in target) {
          cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
      } else {
        return target;
      }
    }

    let obj = {
      name: "six",
      age: 18,
      arr: [1, 2, 3, 4, 5],
      thing: {
        number: [12, 23],
        dog: "狗",
      },
    };
    let res = clone(obj);
    console.log(res, "111");
    ```

4.  嵌套数组指定层次展开 flat 扁平化(six)

    ```javascript
    // 1. 普通方法递归
    const res = []
    const flatten = arr => {
      for (let i = 0; i < arr.length; i++) {
        if (Array.isArray(arr[i])) {
          flatten(arr[i])
        } else {
          res.push(arr[i])
        }
      }
    }

    // 2. concat
    function flatten(arr) {
      let res = []
      arr.forEach(item => {
        if (Array.isArray(item)) {
            res = res.concat(flatten(item))
        } else {
            res.push(item)
        }
      })
      return res
    }

    // 3. reduce
    function flattenMd(arr) {
      return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flattenMd(cur) : cur)
      , []}
    }

    // 4. 扩展运算符
    function flattenMd(arr) {
      let flatten = arr => [].concat(...arr)
      return flatten(arr.map(item => Array.isArray(item) ? flattenMd(item) : item ))
    }

    // 5. join和split组合
    function flattenMd(arr) {
      return arr.join().split(',')
    }

    // 6. ES6的flat方法
    arr = [1,2,3,[4,[5,6]]]
    const res = arr.flat(Infinity)

    // 7. 正则
    const res = JSON.stringify(arr).replace(/\[|\]/g, '').split(',');
    ```

5.  模拟实现 reduce 方法(six)

    ```javascript
    // reduce() 函数接受两个参数，一个函数一个积累变量的初始值
    // 函数有四个参数: 累计变量初始值(默认第一个成员)，当前变量值(默认第二个成员)，当前位置，数组自身
    // arr.reduce(function(prev, cur, index, arr){}, initialValue)
    Array.prototype.myReduce = function (cb, initValue) {
      if (!Array.isArray(this)) {
        throw new TypeError("不是数组");
      }
      // 数组为空
      if (arguments.length < 2 && this.length === 0) {
        throw new TypeError("数组为空");
      }

      let arr = this;
      let res = null;
      if (arguments.length > 1) {
        res = initValue;
      } else {
        res = arr.splice(0, 1)[0];
      }
      arr.forEach((item, index) => {
        res = cb(res, item, index, arr);
      });
      return res;
    };
    ```

6.  模拟实现数组 map 方法(six)

    ```javascript
    // arr.map((currentValue, index, curr) => {})
    // currentValue 必须。 当前元素的值
    // index 可选。 当期元素的索引值
    // arr 可选。 当期元素属于的数组对象

    Array.prototype.newMap = function (fn) {
      let newArr = [];
      for (let i = 0; i < this.length; i++) {
        newArr.push(fn(this[i], i, this)); // this指向调用newMap方法的数组
      }
      return newArr;
    };

    Array.prototype.newMap = function (fn, Arg) {
      ////写法二：用数组的reduce方法实现数组的map
      let res = [];
      this.reduce((prev, curr, index, array) => {
        res.push(fn.call(Arg, curr, index, array));
      }, 0); //指定初始值initialValue=0，所以从currentIndex=0开始，即第一个开始  不这样会缺第一项，结果为[3,4]
      return res;
    };
    let arr = [1, 2, 3];
    let res = arr.newMap((a) => a + 1);
    console.log(res);
    ```

7.  模拟实现 Array.fill(), Array.filter()(six)

    ```js
    // array.fill(value, start, end)
    Array.prototype.myFill = function (value, start = 0, end = this.length) {
      for (let i = start; i < end; i++) {
        this[i] = value;
      }
    };

    // array.filter()
    Array.prototype.myFilter = function myFilter(fn, context) {
      if (typeof fn !== "function") {
        throw new TypeError(`${fn} is not a function`);
      }
      let arr = this;
      let newArr = [];
      for (let i = 0; i < arr.length; i++) {
        let res = fn.call(context, arr[i], i, arr);
        if (res) newArr.push(arr[i]);
      }
      return newArr;
    };
    ```

8.  模拟实现 Array.find(), Array.findIndex()(six)

    ```js
    Array.prototype.myFind = function (fn, start = 0, end = this.length) {
      for (let i = start; i < end; i++) {
        if (fn.call(this, this[i], i, this)) {
          return this[i];
        }
      }
    };

    Array.prototype.myFindIndex = function (fn, start = 0, end = this.length) {
      for (let i = start; i < end; i++) {
        if (fn.call(this, this[i], i, this)) {
          return i;
        }
      }
      return -1;
    };
    ```

9.  实现 slice 方法

    ```js
    Array.prototype.mySlice = function (start, end) {
      var arr = this;
      start = start || 0;
      end = end || arr.length;
      var newArr = [];
      for (let i = start; i < end; i++) {
        newArr.push(arr[i]);
      }
      return newArr;
    };
    ```

    ```js
    Array.prototype.slice2 = function (start, end) {
      let len = this.length;
      let l =
        start === undefined
          ? 0
          : start < 0
          ? Math.max(start + len, 0)
          : Math.min(start, len);
      let r =
        end === undefined
          ? len
          : end < 0
          ? Math.max(end + len, 0)
          : Math.min(end, len);
      const res = [];
      while (l < r) {
        res.push(this[l++]);
      }
      return res;
    };
    ```

10. 使用原生 JS 实现 ajax 请求(six)

    ```js
    let xhr = new XMLHttpRequest(); // 创建XMLHttpRequest
    let url = "https://steven.com";
    xhr.onreadystatechange = function () {
      // 监听状态码的变化，每次变化均执行
      if (xhr.readyState === 4) {
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {
          // 服务端状态码
          console.log(xhr.responseText); // 服务器返回的响应文本
        } else {
          console.error(xhr.statusText); // 状态码的文本描述，如200的statusText是ok
        }
      }
    };
    // 第三个参数表示是否异步
    xhr.open("GET", url, true);
    xhr.send(null);

    // xhr.abort() 用于取消请求
    ```

11. 模拟实现构造函数 new 的过程(six)

    ```javascript
    function myNew(func, ...args) {
      // 1. 判断方法体
      if (typeof func !== "function") {
        throw "第一个参数必须是方法体";
      }

      // 2. 创建新对象
      const obj = {};

      // 3. 这个对象的 __proto__ 指向 func 这个类的原型对象
      // 即实例可以访问构造函数原型（constructor.prototype）所在原型链上的属性
      obj.__proto__ = Object.create(func.prototype);

      // 为了兼容 IE 可以让步骤 2 和 步骤 3 合并
      // const obj = Object.create(func.prototype);

      // 4. 通过 apply 绑定 this 执行并且获取运行后的结果
      let result = func.apply(obj, args);

      // 5. 如果构造函数返回的结果是引用数据类型，则返回运行后的结果
      // 否则返回新创建的 obj
      const isObject = typeof result === "object" && result !== null;
      const isFunction = typeof result === "function";
      return isObject || isFunction ? result : obj;
    }

    // 测试
    function Person(name) {
      this.name = name;
      return function () {
        // 用来测试第 5 点
        console.log("返回引用数据类型");
      };
    }
    // 用来测试第 2 点和第 3 点
    Person.prototype.sayName = function () {
      console.log(`My name is ${this.name}`);
    };
    const me = myNew(Person, "jsliang"); // 用来测试第 4 点
    me.sayName(); // My name is jsliang
    console.log(me); // Person {name: 'jsliang'}

    // 用来测试第 1 点
    // const you = myNew({ name: 'jsliang' }, 'jsliang'); // 报错：第一个参数必须是方法体
    ```

12. 模拟实现 Object.create 方法(six)

    ```js
    // 用于创建一个新对象,被创建的对象继承另一个对象(o)的原型
    function createObj(o) {
      //传入的参数o为返回实例的__porto__,也就是实例构造函数的显示原型
      function F() {} //构造函数
      F.prototype = o;
      return new F(); // 返回实例
    }
    ```

13. 模拟实现 instanceof 的功能(six)

    ```javascript
    function myInstanceof(left, right) {
      let RP = right.prototype;
      let LP = left.__proto__;

      while (true) {
        if (LP == null) {
          return false;
        }
        if (LP == RP) {
          return true;
        }
        LP = LP.__proto__;
      }
    }
    console.log(myInstanceof([], Array));
    myInstanceof([], Array); //true
    ```

14. setTimeout 模拟实现 setInterval

    ```js
    function mySetTimeout(fn, delay) {
      let timer = null;
      function interval() {
        fn();
        timer = setTimeout(interval, delay);
      }
      interval();
      return () => {
        clearTimeout(timer);
      };
    }

    let myClear = mySetTimeout(() => {
      console.log(11);
    }, 1000);
    myClear();
    ```

15. 实现 jsonp

    - JSONP 实现流程

    1. 客户端先定义一个接收数据的全局函数，该函数要唯一
    2. 动态生成 Script 标签，发送请求，把回调函数当做参数传到服务端
    3. 服务端收到请求，返回该函数的调用，并且把数据作为参数一起返回
    4. 客户端执行回调，拿到数据

    ```js
    // 简单版本
    function handleResponse(response) {
      console.log(response.ip, response.city);
    }

    let script = document.createElement("script");

    script.src = "http://freegeoip.net/json/?callback=handleResponse";
    document.body.insertBefore(script, document.body.firstChild);
    ```

    ```js
    // 复杂版本
    function JSONP({ url, params = {}, callbackKey = "cb", callback }) {
      // 定义本地的唯一callbackId，若是没有的话则初始化为1
      JSONP.callbackId = JSONP.callbackId || 1;
      let callbackId = JSONP.callbackId;
      // 把要执行的回调加入到JSON对象中，避免污染window
      JSONP.callbacks = JSONP.callbacks || [];
      JSONP.callbacks[callbackId] = callback;
      // 把这个名称加入到参数中: 'cb=JSONP.callbacks[1]'
      params[callbackKey] = `JSONP.callbacks[${callbackId}]`;

      // 得到'id=1&cb=JSONP.callbacks[1]'
      const paramString = Object.keys(params)
        .map((key) => {
          return `${key}=${params[key]}`;
        })
        .join("&");
      // 创建 script 标签
      const script = document.createElement("script");
      script.setAttribute("src", `${url}?${paramString}`);
      document.body.appendChild(script);
      // id自增，保证唯一
      JSONP.callbackId++;
    }
    JSONP({
      url: "http://localhost:8080/api/jsonp",
      params: { id: 1 },
      callbackKey: "cb",
      callback(res) {
        console.log(res);
      },
    });
    JSONP({
      url: "http://localhost:8080/api/jsonp",
      params: { id: 2 },
      callbackKey: "cb",
      callback(res) {
        console.log(res);
      },
    });
    ```

    ```js
    //最终JSONP方案
    function JSONP({ url, params = {}, callbackKey = "cb", callback }) {
      // 定义本地的唯一callbackId，若是没有的话则初始化为1
      JSONP.callbackId = JSONP.callbackId || 1;
      let callbackId = JSONP.callbackId;
      // 把要执行的回调加入到JSON对象中，避免污染window
      JSONP.callbacks = JSONP.callbacks || [];
      JSONP.callbacks[callbackId] = callback;
      // 把这个名称加入到参数中: 'cb=JSONP.callbacks[1]'
      params[callbackKey] = `JSONP.callbacks[${callbackId}]`;
      // 得到'id=1&cb=JSONP.callbacks[1]'
      const paramString = Object.keys(params)
        .map((key) => {
          return `${key}=${encodeURIComponent(params[key])}`;
        })
        .join("&");
      // 创建 script 标签
      const script = document.createElement("script");
      script.setAttribute("src", `${url}?${paramString}`);
      document.body.appendChild(script);
      // id自增，保证唯一
      JSONP.callbackId++;
    }
    JSONP({
      url: "http://localhost:8080/api/jsonps",
      params: {
        a: "2&b=3",
        b: "4",
      },
      callbackKey: "cb",
      callback(res) {
        console.log(res);
      },
    });
    JSONP({
      url: "http://localhost:8080/api/jsonp",
      params: {
        id: 1,
      },
      callbackKey: "cb",
      callback(res) {
        console.log(res);
      },
    });
    ```

16. promise 实现 sleep 函数

    ```js
    async function test() {
      console.log("start");
      await sleep(4000);
      console.log("end");
    }

    function sleep(ms) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    }

    test();
    ```

17. LRU 算法
    LRU 最近最少使用缓存机制。支持获取数据 get 和写入数据 put

    ```js
    /**
     * @param {number} capacity
     */
    var LRUCache = function (capacity) {
      this.cache = new Map();
      // capacity表示缓存容量
      this.capacity = capacity;
    };

    /**
     * @param {number} key
     * @return {number}
     */
    LRUCache.prototype.get = function (key) {
      if (!this.cache.has(key)) {
        return -1;
      }
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    };

    /**
     * @param {number} key
     * @param {number} value
     * @return {void}
     */
    LRUCache.prototype.put = function (key, value) {
      if (this.cache.has(key)) {
        this.cache.delete(key);
      }
      // 当缓存容量达到上限时，删除最久未使用的数据值
      if (this.cache.size === this.capacity) {
        const iterator = this.cache.keys();
        this.cache.delete(iterator.next().value);
      }
      this.cache.set(key, value);
    };

    /**
     * Your LRUCache object will be instantiated and called as such:
     * var obj = new LRUCache(capacity)
     * var param_1 = obj.get(key)
     * obj.put(key,value)
     */
    ```

18. 数据双向绑定(six)

    ```javascript
    let number = 18

    let person = {
      name: '小六',
      height: 180,
    }

    Object.defineProperty(person, 'age' , {
      value: 18,
      enumerable: true,  //控制属性是否可以枚举
      writable: true,  //控制属性是否可以修改
      configurable(可配置的): true,  //控制属性是否可以被删除

      //当有人读取person的age属性时， get函数就会被调用， 且返回值就是age值
      get: function() {
        return number
      },
      //当有人读取person的age属性时， set函数(setter)就会被调用， 且会收到修改的具体值
      set: function(value) {
        // 把number修改掉
        number = value
      }
    })

    let name = '番茄炒小六'
    const obj = {
      age = 11
    }
    ```

19. 手写字符串方法 trim()

    ```js
    function Trim() {
      let str = this;
      let i = 0;
      let j = str.length - 1;
      while (str[i] === "") {
        i += 1;
      }
      while (str[j] === " ") {
        j -= 1;
      }
      let res = "";
      for (let c = i; c <= j; c++) {
        res += str[c];
      }
      return res;
    }
    ```

20. 懒加载(six)

    (1).将需要懒加载的 img 标签的 src 设置缩略图或者不设置 src，这里的占位图可以是缺省图，loading 图；
    (2).判断该 img 标签是否在浏览器可视区域，如果在可视区域，则将真实的图片 url 设置到 img 标签的 src 属性；
    (3).用户滚动浏览器，遍历需要懒加载的标签，根据步骤 2 判断并执行；

    ```javascript
    var imgs = document.getElementsByTagName("img");

    var num = document.getElementsByTagName("img").length;
    var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历

    lazyload(); //页面载入完毕加载可是区域内的图片

    window.onscroll = lazyload;

    function lazyload() {
      //监听页面滚动事件
      var seeHeight = document.documentElement.clientHeight; //可见区域高度
      var scrollTop =
        document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度
      for (var i = n; i < num; i++) {
        if (imgs[i].offsetTop < seeHeight + scrollTop) {
          if (imgs[i].getAttribute("src") == "default.jpg") {
            imgs[i].src = imgs[i].getAttribute("data-src");
          }
          n = i + 1;
        }
      }
    }
    ```

21. 函数柯里化(six)
    柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数。

    ```js
    function currying(fn, ...args) {
      const length = fn.length;
      var allArgs = args || [];
      const res = (...newArgs) => {
        allArgs = [...allArgs, ...newArgs];
        if (allArgs.length === length) {
          return fn(...allArgs);
        } else {
          return res;
        }
      };
      return res;
    }

    const add = (a, b, c) => a + b + c;
    const a = currying(add, 1);
    console.log(a(2, 3));
    ```

22. 实现 add()

    ```js
    function add() {
      var args = Array.prototype.slice.call(arguments);
      var fn = function () {
        var newArgs = args.concat(Array.prototype.slice.call(arguments));
        return add.apply(this, newArgs);
      };
      fn.toString = function () {
        return args.reduce(function (a, b) {
          return a + b;
        });
      };
      return fn;
    }
    // 需要手动调用toString()
    let sum = add(1)(2)(3, 4, 5).toString();
    console.log(sum);
    //或者
    console.log(+add(1)(2, 3));
    ```

    ```js
    function add() {
      let args = [...arguments];
      let fn = function () {
        return add.apply(null, args.concat([...arguments]));
      };
      fn.toString = () => args.reduce((a, b) => a + b);
      return fn;
    }

    let sum = add(1)(2)(3, 4, 5).toString();
    console.log(sum);
    ```

23. `setTimeout`输出 1，2，3，4，5

    ```javascript
    // 闭包的使用
    for (var i = 1; i < 6; i++) {
      (function (j) {
        setTimeout(function timer() {
          console.log(j);
        }, 1000 * j);
      })(i);
    }

    // 利用setTimeout第三个参数
    for (var i = 1; i < 6; i++) {
      setTimeout(
        function timer(j) {
          console.log(j);
        },
        1000 * i,
        i
      );
    }

    // 利用let形成块级作用域
    for (let i = 1; i < 6; i++) {
      setTimeout(function () {
        console.log(i);
      }, 1000 * i);
    }
    ```

24. 数组去重(six)

    1. 利用 ES6 Set 去重

       ```js
       function unique(arr) {
         return Array.from(new Set(arr)); // return [... new Set(arr)]
       }
       ```

    2. 利用 indexOf 去重

       ```javascript
       function unique(arr) {
         if (!Array.isArray(arr)) {
           console.log("type error!");
           return;
         }
         let res = [];
         for (let i = 0; i < arr.length; i++) {
           if (res.indexOf(arr[i]) === -1) {
             arr.push(arr[i]);
           }
         }
         return res;
       }
       ```

    3. 利用 includes

       ```javascript
       function unique(arr) {
         if (!Array.isArray(arr)) {
           console.log("type error!");
           return;
         }
         let res = [];
         for (let i = 0; i < arr.length; i++) {
           if (!res.includes(arr[i])) {
             // includes 检测数组是否有某个值
             res.push(arr[i]);
           }
         }

         return res;
       }
       ```

    4. indexOf + filter

       ```js
       let arr = [1, 2, 2, 3, 3, 4, 4, 5];
       // 数组去重
       function unique(array) {
         var res = array.filter(function (item, index, array) {
           return array.indexOf(item) === index;
         });
         return res;
       }
       console.log(unique(arr));
       ```

    5. 利用 sort()

       ```javascript
       function unique(arr) {
         if (!Array.isArray(arr)) {
           console.log("type error!");
           return;
         }
         arr.sort();
         // 不要忘记把第一个元素放入res中
         let res = [arr[0]];
         for (let i = 1; i < arr.length; i++) {
           if (arr[i - 1] !== arr[i]) {
             res.push(arr[i]);
           }
         }
         return res;
       }
       ```

    6. for 循环 + Object

       ```javascript
       function unique(arr) {
         let result = [];
         let obj = {};
         for (let i of arr) {
           if (!obj[i]) {
             result.push(i);
             obj[i] = 1;
           }
         }
         return result;
       }
       ```

    7. Map

       ```javascript
       function unique(arr) {
         let result = []
         let map = new Map()

         for (map i of arr) {
           if (!obj.has(i)) {
             result.push(i)
             map.set(i, 1)
           }
         }
         return result
       }
       ```

    8. 双层 for 循环 + splice

       ```javascript
       function unique(arr) {
         for (var i = 0; i < arr.length; i++) {
           for (var j = i + 1; j < arr.length; j++) {
             if (arr[i] == arr[j]) {
               arr.splice(j, 1);
               j--;
             }
           }
         }
         return arr;
       }
       ```

    9. JSON.stringify()

       ```javascript
       function unique(array) {
         var obj = {};
         return array.filter(function (item, index, array) {
           console.log(typeof item + JSON.stringify(item));
           return obj.hasOwnProperty(typeof item + JSON.stringify(item))
             ? false
             : (obj[typeof item + JSON.stringify(item)] = true);
         });
       }
       ```

25. 遍历对象的方法(six)

    (1). 使用`Object.keys()`遍历

    - Object.values() 方法返回一个数组

    ```js
    Object.keys(obj).forEach(function (key)) {
        console.log(key, obj[key])
    }
    ```

    - Object.values() 方法返回一个数组

    ```js
    const obj = { foo: "bar", baz: 42 };
    Object.values(obj); // ["bar", 42]
    ```

    - Object.entries() 方法返回一个数组

    ```js
    const obj = { foo: "bar", baz: 42 };
    Object.entries(obj); // [ ["foo", "bar"], ["baz", 42] ]
    ```

    (2). for...in...遍历

    ```js
    // i表示键值对中的键
    // 不可以使用 for ... of遍历
    for (var i in obj) {
      console.log(i, ":", obj[i]);
    }
    ```

    (3). `Object.getOwnPropertyNames(obj)`

    ```js
    Object.getOwnPropertyNames(obj).forEach(function (key) {
      console.log(key, obj[key]);
    });
    ```

    (4). `Reflect.ownKeys(obj)`遍历

    ```js
    Reflect.ownKeys(obj).forEach(function (key) {
      console.log(key, obj[key]);
    });
    ```

26. 类数组转化为数组(six)

    1. Array.from()
    2. Array.prototype.slice.call()  
       `Array.prototype.slice.call(arguments)`
    3. [].slice.call()
    4. 扩展运算符 [...arguments]
    5. 利用 concat

27. 封装 axios(six)
    文档：https://blog.csdn.net/weixin_44972008/article/details/114368528

    视频：https://www.bilibili.com/video/BV1NJ41197u6?p=13&spm_id_from=pageDriver

        ```js
        /*
        1. 函数返回的值为promise, 成功的结果为response, 失败的结果为error
        2. 能处理多种类型的请求：GET/POST/PUT/DELETE
        3. 函数的参数为一个配置对象
            {
              url: '',
              method: '',
              params: {}，
              data: {}
            }
        4. 响应json数据自动解析为js
        */
        function axios({
          url,
          method='GET',
          params={},
          data={}
        }) {
          // 返回一个Promise对象
          return new Promise((resolve, reject) => {

            // 处理method大小写
            method = method.toUpperCase()


            // 处理params参数(拼接到url上) id=1&×××=abc
            /*
            {
              id:1,
              xxx: 'abc'
            }
            */
            let queryString=''
            Object.keys(params).forEach(key => {
              queryString += `${key}=${params[key]}&`
            })
            if (queryString) {
              // 去除最后的&
              queryString = queryString.substring(0, queryString.length-1)
              // 拼接到url
              url += '?' + queryString
            }


            // 1. 执行异步ajax请求
            // 创建xhr对象
            const request = new XMLHttpRequest()
            // 打开连接(初始化请求，没有请求)
            request.open(method, url, true)
            // 发送请求 GET/delete
            if (method === 'GET' || method === 'DELETE') {
              request.send()

            // 发送请求 POST/PUT
            } else if (method === 'POST' || method === 'PUT') {
              // 告诉服务器请求体的格式是json
              request.setRequestHeader('Content-Type', 'application/json;charset=utf-8')
              // post 发送json格式请求体参数
              request.send(JSON.stringify(data))
            }


            // 绑定状态改变的监听
            request.onreadystatechange = function() {
              // 如果请求没有完成，直接结束
              if (request.readyState !== 4) {
                return
              }
              // 如果响应状态码在[200,300)之间，代表成功，否则失败
              const {status, statusText} = request
              // 2.1 如果请求成功了，调用resolve()
              if (status >= 200 && status <= 299) {
                const response = {
                  data: JSON.parse(request.response)
                  status,
                  statusText
                }
                resolve(response)
              // 2.2 如果失败了，调用reject()
              } else {
                reject(new Error('request error status is' + status))
              }
            }
          })
        }

        // 发送get请求
        axios({
          url: 'http://localhost:3000/posts',
          method: 'GET',
          params: {
            id: '1',
            xxx: 'abc'
          }
        }).then(response => {
            console.log(response)
          },
          error => {
            alert(error.message)
          })

        // 发送post请求
        axios({
          url: 'http://localhost:3000/posts',
          method: 'POST',
          data: {
            'title': '番茄炒小六正在学习中',
            'author': '番茄炒小六'
          }
        })

        // 发送PUT请求
        axios({
          url: 'http://localhost:3000/posts/1',
          method: 'PUT',
          data: {
            'title': '番茄炒小六正在学习中',
            'author': '番茄炒小六'
          }
        }).then(
          response => {
            console.log(response)
          },
          error => {
            alert(error.message)
          }
        )

        // DELETE请求 删除数据
        axios({
          url: 'http://localhost:3000/posts/2',
          method: 'DELETE',
          data: {
            'title': '番茄炒小六正在学习中',
            'author': '番茄炒小六'
          }
        }).then(
          response => {
            console.log(response)
          },
          error => {
            alert(error.message)
          }
        )

        ```

28. 模拟实现 Promise(six)

    ```javascript
    let p = new Promise((resolve,reject) => {
        resolve('OK')
    });
    p.then(value =>{
        console.log(value);
    },reason =>{
        console.log(reason)
    })
    ----------------------------------------------------
    //声明构造函数
    function Promise(executor){
        //添加属性,状态及结果
        this.promiseState = 'pending'
        this.promiseResult = null
        //保存实例对象的this值
        const self = this

        //resolve函数
        function resolve(data){
            //判断状态，保证一经修改不能再改变
            if (self.promiseState !== 'pending') return

            //1.修改对象状态（promiseState）
            self.promiseState = 'funfilled';
            //2.设置对象结果值(promiseResult)
            self.promiseResult = data;
        }

        //reject函数
        function reject(data){
            //判断状态，保证一经修改不能再改变
            if (self.promiseState !== 'pending') return

            //1.修改对象状态（promiseState）
            self.promiseState = 'rejected'
            //2.设置对象结果值(promiseResult)
            self.promiseResult = data
        }

        //同步调用执行器函数
        try{
            executor(resolve,reject);
        }catch(e){
            //修改promise对象状态为失败
            reject(e);
        }
    }

    //Promise.then实现
    Promise.prototype.then = function(onResolved,onRejected){

        //调用回调函数
        if(this.promiseState === 'fulfilled'){
            onResolved(this.promiseResult);
        }
        if(this.promiseState === 'rejected'){
            onRejected(this.promiseResult);
        }
    }




    --------------------------------------------------------
    //异步完善

    //声明构造函数
    function Promise(executor){

        //添加属性
        this.promiseState = 'pending'
        this.promiseResult = null
        //声明回调属性
        this.callbacks =[]
        //保存实例对象的this值
        const self = this

        //resolve函数
        function resolve(data){
            //判断状态，保证一经修改不能再改变
            if (self.promiseState !== 'pending') return

            //1.修改对象状态（promiseState）
            self.promiseState = 'funfilled';
            //2.设置对象结果值(promiseResult)
            self.promiseResult = data;

            //调用成功的回调函数(指定多个)
            self.callbacks.forEach(item =>{
                item.onResolved(data)
            })
        }

        //reject函数
        function reject(data){
            //判断状态，保证一经修改不能再改变
            if (self.promiseState !== 'pending') return

            //1.修改对象状态（promiseState）
            self.promiseState = 'rejected'
            //2.设置对象结果值(promiseResult)
            self.promiseResult = data

            //执行失败的回调函数(指定多个回调)
            self.callbacks.forEach(item =>{
                item.onRejected(data)
            })

        }

        //同步调用执行器函数
        try{
            executor(resolve,reject);
        }catch(e){
            reject(e);
        }
    }

    //Promise.then实现
    Promise.prototype.then = function(onResolved,onRejected){

        //调用回调函数
        if(this.promiseState === 'fulfilled'){
            onResolved(this.promiseResult);
        }
        if(this.promiseState === 'rejected'){
            onRejected(this.promiseResult);
        }

        //判断pending状态
        if(this.promiseState === 'pending'){
            //保存回调函数
            this.callbacks.push({
                onResolved: onResolved,
                onRejected: onRejected
            })
        }
    }


    ---------------------------------------------------------
    //promise的all方法封装
    Promise.all = function(promise){
        return new Promise((resolve, reject) =>{
            let count = 0
            let arr = []
            //遍历
            for (let i=0; i<promise.length; i++){
                promise[i].then(v =>{
                    //得知对象的状态是成功,且每个promise都是成功的
                    count++
                    //将当前promise对象成功的结果 存入到数组中
                    arr[i] = v
                    //判断 如果count值等于Promise的长度，说明每个promise都成功
                    if(count === promise.length){
                        resolve(arr)
                    }
                },r =>{
                    reject(r)
                })
            }
        })
    }


    -------------------------------------------------------------
    //promise的race方法封装
    Promise.race = function(promise){
        return new Promise((resolve,reject) =>{
            for(let i=0; i<promise.length; i++){
                promise[i].then(v=>{
                    resolve(v)
                },r =>{
                    reject(r)
                })
            }
        });
    }

    //添加 resolve 方法
    Promise.resolve = function(value){
        //返回promise对象
        return new Promise((resolve, reject) => {
            if(value instanceof Promise){
                value.then(v=>{
                    resolve(v);
                }, r=>{
                    reject(r);
                })
            }else{
                //状态设置为成功
                resolve(value);
            }
        });
    }

    //添加 reject 方法
    Promise.reject = function(reason){
        return new Promise((resolve, reject)=>{
            reject(reason);
        });
    }


    //添加 catch 方法
    Promise.prototype.catch = function(onRejected){
        return this.then(undefined, onRejected);
    }

    ```

29. promise 题目封装

    1. setTimeout 封装成 promise(sleep)

       ```js
       function timeout(delay) {
         return new Promise((resolve, reject) => {
           setTimeout(resolve, delay);
         });
       }

       timeout(2000).then(() => {
         console.log("hello");
       });
       ```

    2. fs.readFile 封装 Promise

30. 实现有并行限制的 Promise 调度器
    实现一个带并发限制的异步调度器 Schedule, 保证同时运行的任务最多有两个

    ```js
    class Scheduler {
      constructor(limit) {
        this.queue = [];
        this.maxCount = limit;
        this.runCounts = 0;
      }
      add(time, order) {
        const promiseCreator = () => {
          return new Promise((resolve, reject) => {
            setTimeout(() => {
              console.log(order);
              resolve();
            }, time);
          });
        };
        this.queue.push(promiseCreator);
      }
      taskStart() {
        for (let i = 0; i < this.maxCount; i++) {
          this.request();
        }
      }
      request() {
        if (
          !this.queue ||
          !this.queue.length ||
          this.runCounts >= this.maxCount
        ) {
          return;
        }
        this.runCounts++;
        this.queue
          .shift()()
          .then(() => {
            this.runCounts--;
            this.request();
          });
      }
    }
    const scheduler = new Scheduler(2);
    const addTask = (time, order) => {
      scheduler.add(time, order);
    };
    addTask(1000, "1");
    addTask(500, "2");
    addTask(300, "3");
    addTask(400, "4");
    scheduler.taskStart(); // 2 3 1 4
    ```

31. 所有继承方式(8 种)

    1. 原型链继承

       ```js
       function Child(name) {
         this.name = name;
       }

       function Parent() {}

       // 子类原型指向父类实例
       Child.prototype = new Parent();
       ```

       - 缺点:

         1. 子类实例共享父类引用对象

    2. 构造继承

       ```js
       function Child() {
         // 在子类构造函数内部使用call或apply来调用父类构造函数
         // 复制父类的实例属性给子类
         Parent.call(this, ...arguments);
       }
       ```

       - 优点:

         1. 解决原型链继承中子类实例共享父类引用对象的问题
         2. 创建子类实例时，可以向父类传递参数

       - 缺点:
         1. 只能继承父类的实例属性和方法，不能继承父类原型的属性和方法
         2. 实例不是父类的实例，只是子类的实例

    3. 组合继承

       ```js
       function Child() {
         Parent.call(this, ...arguments);
       }

       Child.prototype = new Parent();
       Child.prototype.constructor = Child;
       ```

       - 优点:

         1. 可以继承父类实例属性和方法，也能够继承父类原型属性和方法
         2. 弥补了原型链继承中引用属性共享的问题
         3. 可传参，可复用

       - 缺点:

         1. 父类构造函数会被调用两次 new Parent()和 Parent.call()
         2. 生成了两个实例 new Parent() 和 new Child()，子类实例中的属性和方法会覆盖子类原型(父类实例)上的属性和方法，所以增加了不必要的内存

       - constructor 总结

         1. constructor 它是构造函数原型对象中的一个属性，正常情况下它指向的是原型对象。

         2. 它并不会影响任何 JS 内部属性，只是用来标示一下某个实例是由哪个构造函数产生的而已。
         3. 如果我们使用了原型链继承或者组合继承无意间修改了 constructor 的指向，那么出于编程习惯，我们最好将它修改为正确的构造函数。

    4. 寄生组合继承

       ```js
       function Child() {
         Parent.call(this, ...arguments);
       }
       // Object.create(Parent.prototype)创建了一个空对象，并且这个对象的__proto__属性指向Parent.prototype
       Child.prototype = Object.create(Parent.prototype);
       Child.prototype.constructor = Child;
       ```

    5. 原型式继承-即使用 Object.create()实现

       原理: 创建一个构造函数，构造函数的原型指向对象，然后调用 new 操作符创建实例，并返回这个实例

       ```js
       function create(obj) {
         function F() {}
         F.prototype = obj;
         F.prototype.constructor = F;
         return new F();
       }
       var cat = {
         heart: '心'，
         colors: 'white'
       }

       var guaiguai = create(cat)
       // 或者
       var guaiguai = Object.create(cat)
       ```

    6. 寄生式继承
       原理: 在原型式继承的基础上再封装一层，来增强对象

       ```js
       function create(original) {
         var clone = Object.create(original); //创建一个新对象
         clone.fn = function () {}; //以某种方式来增强对象
         return clone; //返回这个对象
       }
       ```

    7. 混入式继承(和寄生组合继承类似， 可以继承多个父类)
       原理: 一个子类继承多个父类， 用 Object.assign()方法

       ```js
       function Child() {
         Parent.call(this);
         // call 来赋值构造函数OtherParent上的属性和方法
         OtherParent.call(this);
       }
       Child.prototype = Object.create(Parent.prototype);
       // 使用Object.assign()浅拷贝OtherParent.prototype上的属性和方法
       // Object.assign的作用是把多个对象的属性和方法拷贝到目标对象中
       Object.assign(Child.prototype, OtherParent.prototype);
       Child.prototype.constructor = Child;
       ```

    8. class 继承 (extends + super)

32. 解决 for 循环打印问题

    ```js
    for (var i = 0; i < 4; i++) {
      btn[i].onclick = function () {
        console.log("111");
        console.log(i + "个按钮"); // 4
      };
    }

    // 1. 利用立即执行函数，立即执行函数需要用()包裹起来，被浏览器认作是一个表达式
    for (var i = 0; i < btn.length; i++) {
      (function (j) {
        btn[j].onclick = function () {
          console.log("111");
          console.log(j + "个按钮");
        };
      })(i);
    }

    // 2. 使用let
    for (let i = 0; i < btn.length; i++) {
      btn[i].onclick = function () {
        console.log(i);
      };
    }
    ```

33. 手写双向绑定

    ```html
    <input type="text" />
    <p></p>
    ```

    ```js
    const input = document.querySelector("input");
    const p = document.querySelector("p");
    // 双向绑定
    const obj = {};
    Object.defineProperty(obj, "txt", {
      set(value) {
        document.querySelector("input").value = value;
        document.querySelector("p").innerHTML = value;
      },
    });
    document.addEventListener("keyup", (e) => {
      obj.txt = e.target.value;
    });
    ```

34. 事件总线手写

35. 观察者模式 | 发布订阅模式手写

    ```js
    class EventEmitter {
      constructor() {
        this.events = {};
      }
      // 实现订阅
      on(type, callBack) {
        if (!this.events[type]) {
          this.events[type] = [callBack];
        } else {
          this.events[type].push(callBack);
        }
      }
      // 删除订阅
      off(type, callBack) {
        if (!this.events[type]) return;
        this.events[type] = this.events[type].filter((item) => {
          return item !== callBack;
        });
      }
      // 只执行一次订阅事件
      once(type, callBack) {
        function fn() {
          callBack();
          this.off(type, fn);
        }
        this.on(type, fn);
      }
      // 触发事件
      emit(type, ...rest) {
        this.events[type] &&
          this.events[type].forEach((fn) => fn.apply(this, rest));
      }
    }

    // 使用如下
    const event = new EventEmitter();
    var sayHello = function (name) {
      console.log(name + " 你好啊");
    };

    // 订阅
    event.on("click", sayHello);

    // 发布
    event.emit("click", "tomatosix"); // tomatosix你好啊

    // 删除该订阅
    event.off("click", sayHello);
    event.emit("click", "没有名字"); // 没有输出

    event.once("dbClick", () => {
      console.log(123456);
    });
    event.emit("dbClick");
    event.emit("dbClick");
    ```

36. array 性能对比
    for -> for of -> forEach -> filter -> map -> for in

37. 实现 `a == 1 && a == 2 && a == 3`和`a === 1 && a === 2 && a === 3`

    1.  使用运算时会自动调用 valueOf,进行 valueOf 重写

        ```js
        class A {
          constructor(value) {
            this.value = value;
          }
          valueOf() {
            return this.value++;
          }
        }
        const a = new A(1);
        if (a == 1 && a == 2 && a == 3) {
          console.log("==成功了"); // ==成功了
        }
        // 下面这个式子不会调用 valueOf()
        console.log(a == 1 && a == 2 && a == 3); // false
        ```

    2.  === 不会进行隐式转换, 可以通过数据劫持的方式
        ```js
        let value = 1;
        Object.defineProperty(window, "a", {
          get() {
            return value++;
          },
        });
        if (a === 1 && a === 2 && a === 3) {
          console.log("=== 成功了");
        }
        ```

38. 每三位添加一个逗号

39. js 创建对象的几种方式

40. 列表转树形结构
    https://juejin.cn/post/6983904373508145189

    ```js
    let arr = [
      { id: 1, name: "部门1", pid: 0 },
      { id: 2, name: "部门2", pid: 1 },
      { id: 3, name: "部门3", pid: 1 },
      { id: 4, name: "部门4", pid: 3 },
      { id: 5, name: "部门5", pid: 4 },
    ];
    var obj = [
      {
        id: 1,
        name: "部门1",
        pid: 0,
        children: [
          {
            id: 2,
            name: "部门2",
            pid: 1,
            children: [],
          },
          {
            id: 3,
            name: "部门3",
            pid: 1,
            children: [
              {
                id: 4,
                name: "部门4",
                pid: 3,
                children: [
                  {
                    id: 5,
                    name: "部门5",
                    pid: 4,
                    children: [],
                  },
                ],
              },
            ],
          },
        ],
      },
    ];

    const getChildren = function (data, result, pid) {
      for (const item of data) {
        if (item.pid === pid) {
          const newItem = { ...item, children: [] };
          result.push(newItem);
          getChildren(data, newItem.children, item.id);
        }
      }
    };
    const arrayToTree = function (data, pid) {
      const result = [];
      getChildren(data, result, pid);
      return result;
    };
    let res = arrayToTree(arr, 0);
    console.log(res, "res");
    ```

41. 树形结构转成列表

    ```js
    var tree = [
      {
        id: 1,
        text: "节点1",
        parentId: 0,
        children: [
          {
            id: 2,
            text: "节点1_1",
            parentId: 1,
          },
        ],
      },
    ];
    var arr = [
      {
        id: 1,
        text: "节点1",
        parentId: 0, //这里用0表示为顶级节点
      },
      {
        id: 2,
        text: "节点1_1",
        parentId: 1, //通过这个字段来确定子父级
      },
    ];

    function treeToList(data) {
      let res = [];
      const dfs = (tree) => {
        tree.forEach((item) => {
          if (item.children) {
            dfs(item.children);
            delete item.children;
          }
          res.push(item);
        });
      };
      dfs(data);
      return res;
    }
    ```

42. 大数相加

    ```js
    let a = "9007199254740991";
    let b = "1234567899999999999";

    function add(a, b) {
      //取两个数字的最大长度
      let maxLength = Math.max(a.length, b.length);
      //用0去补齐长度
      a = a.padStart(maxLength, 0); //"0009007199254740991"
      b = b.padStart(maxLength, 0); //"1234567899999999999"
      //定义加法过程中需要用到的变量
      let t = 0;
      let f = 0; //"进位"
      let sum = "";
      for (let i = maxLength - 1; i >= 0; i--) {
        t = parseInt(a[i]) + parseInt(b[i]) + f;
        f = Math.floor(t / 10);
        sum = (t % 10) + sum;
      }
      if (f !== 0) {
        sum = "" + f + sum;
      }
      return sum;
    }
    ```

43. 对象扁平化
    https://juejin.cn/post/6894577333630418958
    https://juejin.cn/post/6968713283884974088#heading-33

    ```js
    const obj = {
      a: 1,
      b: [1, 2, { c: true }],
      c: { e: 2, f: 3 },
      g: null,
    };
    let objRes = {
      a: 1,
      "b[0]": 1,
      "b[1]": 2,
      "b[2].c": true,
      "c.e": 2,
      "c.f": 3,
      g: null,
    };
    // 是不是对象
    function isObject(val) {
      return typeof val === "object" && val !== null;
    }

    function flatten(obj) {
      // 如果不是对象, 直接返回
      if (!isObject(obj)) {
        return;
      }
      let res = {};
      const dfs = (cur, prefix) => {
        if (isObject(cur)) {
          // 如果是数组
          if (Array.isArray(cur)) {
            cur.forEach((item, index) => {
              dfs(item, `${prefix}[${index}]`);
            });
          } else {
            // 如果是对象
            for (let key in cur) {
              let item = cur[key];
              dfs(item, `${prefix}${prefix ? "." : ""}${key}`);
            }
          }
        } else {
          // 不是对象就直接输出
          res[prefix] = cur;
        }
      };
      dfs(obj, "");

      return res;
    }
    console.log(flatten(obj), "res");
    ```

44. 有效的括号

    ```js
    var isValid = function (s) {
      let stack = [];
      for (let val of s) {
        if (val === "(" || val === "[" || val === "{") {
          stack.push(val);
        } else {
          if (stack.length === 0) return false;
          if (val === ")" && stack.pop() !== "(") return false;
          if (val === "]" && stack.pop() !== "[") return false;
          if (val === "}" && stack.pop() !== "{") return false;
        }
      }
      return !stack.length;
    };
    ```

45. DOM2JSON 函数

    ```html
    <div>
      <span>
        <a></a>
      </span>
      <span>
        <a></a>
        <a></a>
      </span>
    </div>
    ```

    把上诉 dom 结构转成下面的 JSON 格式

    ```js
    let jsonObj = {
      tag: "DIV",
      children: [
        {
          tag: "SPAN",
          children: [{ tag: "A", children: [] }],
        },
        {
          tag: "SPAN",
          children: [
            { tag: "A", children: [] },
            { tag: "A", children: [] },
          ],
        },
      ],
    };
    ```

    ```js
    function dom2Json(domTree) {
      let obj = {};
      obj.name = domTree.tagName;
      obj.children = [];
      domTree.childNodes.forEach((child) => obj.children.push(dom2Json(child)));
      return obj;
    }
    ```

46. JSON2DOM 函数-虚拟 DOM 转为真实 DOM

    ```js
    const obj = {
      tag: "DIV",
      attrs: {
        id: "app",
      },
      children: [
        {
          tag: "SPAN",
          children: [{ tag: "A", children: [] }],
        },
        {
          tag: "SPAN",
          children: [
            { tag: "A", children: [] },
            { tag: "A", children: [] },
          ],
        },
      ],
    };
    ```

    把上诉虚拟 Dom 转化成下方真实 Dom

    ```html
    <div id="app">
      <span>
        <a></a>
      </span>
      <span>
        <a></a>
        <a></a>
      </span>
    </div>
    ```

    ```js
    // 真正的渲染函数

    function render(vnode) {
      // 如果是数字类型转化为字符串
      if (typeof vnode === "number") {
        vnode = String(vnode);
      }
      // 字符串类型直接就是文本节点
      if (typeof vnode === "string") {
        return document.createTextNode(vnode);
      }
      // 普通 DOM
      const dom = document.createElement(vnode.tag);
      if (vnode.attrs) {
        // 遍历属性
        Object.keys(vnode.attrs).forEach((key) => {
          const value = vnode.attrs[key];
          dom.setAttribute(key, value);
        });
      }
      // 子数组进行递归操作
      vnode.children.forEach((child) => dom.appendChild(render(child)));
      return dom;
    }
    ```

47. 实现版本号排序的方法
    有一组版本号如下['0.1.1', '2.3.3', '0.302.1', '4.2', '4.3.5', '4.3.4.5']。现在需要对其进行排序，排序的结果为 ['4.3.5','4.3.4.5','2.3.3','0.302.1','0.1.1']

    ```js
    let arr = ["0.1.1", "2.3.3", "0.302.1", "4.2", "4.3.5", "4.3.4.5"];
    arr.sort((a, b) => {
      let i = 0;
      const arr1 = a.split(".");
      const arr2 = b.split(".");

      while (true) {
        const s1 = arr1[i];
        const s2 = arr2[i];
        i++;
        // 先判断长度不相等的情况
        if (s1 === undefined || s2 === undefined) {
          return arr2.length - arr1.length;
        }
        // 如果字符相等则比较下一字符
        if (s1 === s2) continue;
        // 最后比较字符大小
        return s2 - s1;
      }
    });
    console.log(arr);
    ```

48. 怎么在制定数据源里面生成一个长度为 n 的不重复随机数组 能有几种方法 时间复杂度多少（字节）
    https://juejin.cn/post/7004638318843412493#heading-33

49. vue reactive

    ```js
    /*
    const obj = {
      name: 'why',
      age:18
    }
    
    function foo() {
      const newName = obj.name
      console.log('123');
      console.log(obj.name);
    }
    function demo() {
      console.log(obj.name)
    }
    function bar() {
      console.log('普通的其它函数');
      console.log('该函数不需要有任何响应式');
    }
    // 要求：修改obj.name时使得foo、demo函数自动执行
    obj.name= 'kobe'
    */

    // 封装一个响应式的函数
    // let reactiveFns = []
    // 当前需要收集的响应式函数

    /* 
    1. 使用set来保存依赖函数，而不是数组
    */
    let activeReactiveFn = null;

    // 定义函数收集的类
    class Depend {
      constructor() {
        this.reactiveFns = new Set();
      }

      // addDepend(reactiveFn) {
      //   this.reactiveFns.push(reactiveFn)
      // }

      notify() {
        this.reactiveFns.forEach((fn) => {
          fn();
        });
      }

      depend() {
        if (activeReactiveFn) {
          this.reactiveFns.add(activeReactiveFn);
        }
      }
    }
    const depend = new Depend();

    // 封装一个收集需要调用的函数
    function watchFn(fn) {
      // 把需要响应的函数放入正确的依赖中
      // 1. 找到depend对象
      activeReactiveFn = fn;
      fn();
      activeReactiveFn = null;
    }

    // 封装一个获取depend的函数
    const targetMap = new WeakMap();
    function getDepend(target, key) {
      // 根据target获取Map
      let map = targetMap.get(target);
      if (!map) {
        // 初次使用不存在map
        map = new Map();
        targetMap.set(target, map);
      }

      let depend = map.get(key);
      if (!depend) {
        depend = new Depend();
        map.set(key, depend);
      }
      return depend;
    }

    function reactive(obj) {
      return new Proxy(obj, {
        get: function (target, key, receiver) {
          // 根据target和key获取对应的depend
          const depend = getDepend(target, key);
          // 给depend添加对应的函数
          // depend.addDepend(activeReactiveFn)
          depend.depend();

          return Reflect.get(target, key, receiver);
        },
        set: function (target, key, newValue, receiver) {
          Reflect.set(target, key, newValue, receiver);
          // 监听自动调用notify
          // depend.notify()
          let depend = getDepend(target, key);
          // console.log(depend.reactiveFns);
          depend.notify();
        },
      });
    }

    //对象的响应式
    const obj = {
      name: "why", // 每一个属性都有一个depend对象
      age: 18,
    };
    const objProxy = reactive(obj);

    watchFn(() => {
      // 不需要执行两次
      console.log(objProxy.name, "----");
      console.log(objProxy.name, "----");
    });
    objProxy.name = "000";

    const info = {
      address: "杭州市",
    };
    const infoProxy = reactive(info);
    watchFn(function () {
      console.log(infoProxy.address, "监听address变化");
    });
    watchFn(function () {
      console.log("address属性调用该方法");
    });
    ```

50. 说出下面的运行结果
    https://juejin.cn/post/6844903974378668039#heading-1

    ```js
    function test(person) {
      person.age = 26;
      person = {
        name: "hzj",
        age: 18,
      };
      return person;
    }
    const p1 = {
      name: "fyq",
      age: 19,
    };
    const p2 = test(p1);
    console.log(p1); // -> ?
    console.log(p2); // -> ?
    ```

51. '1'.toString()为什么可以调用
