# 其它

1.  和为 s 的连续正数序列

    ```javascript
    /**
     * @param {number} target
     * @return {number[][]}
     */
    // 利用滑动窗口
    var findContinuousSequence = function (target) {
      let result = [];

      let i = 1,
        j = 1,
        sum = 0; // i表示左指针，j表示右指针
      while (i <= Math.floor(target / 2)) {
        if (sum < target) {
          sum += j;
          j++;
        } else if (sum > target) {
          sum -= i;
          i++;
        } else {
          const arr = [];
          for (let k = i; k < j; k++) {
            arr.push(k);
          }
          result.push(arr);
          sum -= i;
          i++;
        }
      }
      return result;
    };
    ```

2.  最长回文子串

    ```javascript
    var longestPalindrome = function (s) {
      if (s.length < 2) return s;

      let res = "";
      for (let i = 0; i < s.length; i++) {
        helper(i, i);
        helper(i, i + 1);
      }

      function helper(m, n) {
        while (m >= 0 && n < s.length && s[n] === s[m]) {
          m--;
          n++;
        }

        if (n - m - 1 > res.length) {
          res = s.slice(m + 1, n);
        }
      }
      return res;
    };
    ```

# 二分查找

https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/

1. 二分查找

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number}
    */
   var search = function (nums, target) {
     let left = 0,
       right = nums.length - 1;
     while (left <= right) {
       let midIndex = Math.floor((right - left) / 2) + left;
       let mid = nums[midIndex];
       if (mid === target) {
         return midIndex;
       } else if (mid < target) {
         left = midIndex + 1;
       } else {
         right = midIndex - 1;
       }
     }
     return -1;
   };
   ```

2. 在排序数组中查找元素的第一个和最后一个位置

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number[]}
    */
   var searchRange = function (nums, target) {
     //二分查找
     let find = (isLeft) => {
       let left = 0,
         right = nums.length - 1;

       while (left <= right) {
         let mid = Math.floor((left + right) / 2);

         if (target < nums[mid]) {
           right = mid - 1;
         } else if (target > nums[mid]) {
           left = mid + 1;
         } else {
           if (isLeft) {
             if (nums[mid] === nums[mid - 1]) {
               right = mid - 1;
             } else {
               return mid;
             }
           } else {
             if (nums[mid] === nums[mid + 1]) {
               left = mid + 1;
             } else {
               return mid;
             }
           }
         }
       }
       return -1;
     };
     let left = find(true),
       right = find(false);
     return [left, right];
   };
   ```

3. 寻找峰值 |

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findPeakElement = function (nums) {
     let left = 0,
       right = nums.length - 1;

     while (left < right) {
       let mid = Math.floor((left + right) / 2);
       if (nums[mid] < nums[mid + 1]) {
         left = mid + 1;
       } else {
         right = mid;
       }
     }
     return left;
   };
   ```

4. 旋转数组的最小数字

   ```js
   /**
    * @param {number[]} numbers
    * @return {number}
    */
   var minArray = function (numbers) {
     let left = 0,
       right = numbers.length - 1;
     while (left < right) {
       let mid = left + Math.floor((right - left) / 2);
       if (numbers[mid] > numbers[right]) {
         left = mid + 1;
       } else if (numbers[mid] < numbers[right]) {
         right = mid;
       } else {
         right--;
       }
     }
     return numbers[left];
   };
   ```

5. 山峰数组的顶部

   ```js
   /**
    * @param {number[]} arr
    * @return {number}
    */
   var peakIndexInMountainArray = function (arr) {
     let left = 1,
       right = arr.length - 2;
     while (left < right) {
       let mid = Math.floor((left + left) / 2);
       if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1]) {
         return mid;
       } else if (arr[mid - 1] < arr[mid]) {
         left = mid + 1;
       } else {
         right = mid - 1;
       }
     }
     return left;
   };
   ```

6. 查找插入位置

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number}
    */
   var searchInsert = function (nums, target) {
     for (let i = 0; i < nums.length; i++) {
       if (target <= nums[i]) {
         return i;
       }
     }
     return nums.length;
   };
   ```

# 排序

https://juejin.cn/post/6856546833025237006#heading-9

## 分类

- 按排序依据的原则
  插入排序： 直接插入排序、希尔排序
  交换排序： 冒泡排序、快速排序
  选择排序: 直接选择排序、堆排序
  归并排序： 2-录归并排序
  基数排序

- 根据排序的稳定性：关键字相同的记录在排序过程中是否保持前后次序不变
  不变则为稳定排序，变化则为不稳定排序

稳定排序： 直接插入排序、冒泡排序、归并排序、计数排序
不稳定排序：希尔排序、直接选择排序、堆排序、快速排序

- 时间复杂度

1.  冒泡排序-稳定 O(n\*n)

    ```javascript
    let bubbleSort = function (arr, flag = 0) {
      let len = arr.length;

      // 最外层for循环表示循环次数，需循环len - 1次
      for (let i = 0; i < len - 1; i++) {
        for (let j = 0; j < len - 1 - i; j++) {
          //比较相邻两者之间的关系大小
          if (arr[j] > arr[j + 1]) {
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
          }
        }
      }
      return flag ? arr.reverse() : arr;
    };
    let arr = [2, 10, 8, 3, 0, 5];
    console.log(bubbleSort(arr, 1)); //flag 0-正序 1-倒序
    ```

2.  快速排序- 不稳定 O(nlog2n)
    基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

    - 方法一

    ```javascript
    let quickSort = function (arr) {
      // 递归出口就是数组长度为1
      if (arr.length <= 1) return arr;
      // 获取中间值的索引，使用Math.floor向下取整
      let index = Math.floor(arr.length / 2);
      // 使用splice截取中间值
      let pivot = arr.splice(index, 1)[0],
        left = [],
        right = [];
      for (let i = 0; i < arr.length; i++) {
        // 如果中间值更大，则将arr[i] push左边数组
        if (pivot > arr[i]) {
          left.push(arr[i]);
        } else {
          // 否则，将arr[i] push右边数组
          right.push(arr[i]);
        }
      }
      return quickSort(left).concat([pivot], quickSort(right));
    };
    ```

    - 方法二

    ```javascript
    function quickSort(array) {
      if (array.length < 2) return array;
      let pivot = array[array.length - 1];
      let left = array.filter(
        (item, index) => item <= pivot && index !== array.length - 1
      );
      let right = array.filter((item) => item > pivot);
      return [...quickSort(left), pivot, ...quickSort(right)];
    }
    ```

3.  直接插入排序-稳定
    基本原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

    ```javascript
    let insertSort = function (arr) {
      // 取数组长度
      let len = arr.length;

      for (let i = 1; i < len; i++) {
        // cur 表示当前要插入比较的元素
        let curValue = arr[i];
        let j = i - 1;
        // 若前面的数字比当前值cur大，则前面的数字向后移动一位，继续向前一位与当前值比较
        // preIndex >= 0 是为了保证第一个元素认为被排序
        while (j >= 0 && curValue < arr[j]) {
          arr[j + 1] = arr[j];
          j--;
        }
        // 如果小，则放入当前数字的后面
        arr[j + 1] = curValue;
      }
      return arr;
    };
    ```

4.  归并排序-稳定 O(nlog2n)
    https://juejin.cn/post/6844903937242300430
    归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后 将数组排序合并，最终合并为排序好的数组。

    ```js
    function merge(left, right) {
      let result = [];
      let i = 0,
        j = 0;
      while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
          result.push(left[i++]);
        } else {
          result.push(right[j++]);
        }
      }
      if (i < left.length) {
        result.push(...left.slice(i));
      } else {
        result.push(...right.slice(j));
      }
      return result;
    }

    function mergeSort(array) {
      if (array.length < 2) {
        return array;
      }
      let m = Math.floor(array.length / 2);
      let left = mergeSort(array.slice(0, m));
      let right = mergeSort(array.slice(m));
      return merge(left, right);
    }

    let arr = [1, 8, 9, 5, 4, 3, 6, 2];
    console.log(mergeSort(arr));
    ```

5.  计数排序
    所谓“计数”，就是数一数，统计每个元素重复出现的次数。

    ```js
    function countingSort(arr) {
      let min = Infinity;
      for (let v of arr) {
        if (v < min) {
          min = v;
        }
      }
      let counts = [];
      for (let v of arr) {
        counts[v - min] = (counts[v - min] || 0) + 1;
      }
      let index = 0;
      for (let i = 0; i < counts.length; i++) {
        let count = counts[i];
        while (count > 0) {
          arr[index] = i + min;
          count--;
          index++;
        }
      }
      return arr;
    }
    ```

6.  希尔排序
    通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。

    ```js
    function shellSort(arr) {
      let len = arr.length;
      // 初始步数
      let gap = parseInt(len / 2);
      // 逐渐缩小步数
      while (gap) {
        // 从第gap个元素开始遍历
        for (let i = gap; i < len; i++) {
          // 逐步其和前面其他的组成员进行比较和交换
          for (let j = i - gap; j >= 0; j -= gap) {
            if (arr[j] > arr[j + gap]) {
              [arr[j], arr[j + gap]] = [arr[j + gap], arr[j]];
            } else {
              break;
            }
          }
        }
        gap = parseInt(gap / 2);
      }
      return arr;
    }
    ```

7.  直接选择排序 - 不稳定 - O(n\*n)

    ```javascript
    // 基本原理：每一次从待排序的数组元素中选择最大的一个元素作为首元素，直到排完为止
    let selectSort = function (arr) {
      let len = arr.length,
        curMinIndex = 0;
      // 一共需要排序len-1次, 即循环次数
      for (let i = 0; i < len - 1; i++) {
        curMinIndex = i;
        // 取出后续数字中最小数字的索引
        for (let j = i + 1; j < len; j++) {
          if (arr[j] < arr[curMinIndex]) {
            curMinIndex = j;
          }
        }
        // 每一趟保证第i位为最小值, 此时的temp为后续最小数字的索引
        [arr[i], arr[curMinIndex]] = [arr[curMinIndex], arr[i]];
      }
      return arr;
    };
    let arr = [2, 9, 6, 7, 4, 3, 1, 7, 0, -1, -2];
    console.log(selectSort(arr));
    ```

8.  堆排序
    https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/xie-gei-qian-duan-tong-xue-de-ti-jie-yi-kt5p2/

        ```javascript
        /**
         * @param {number[]} nums
        * @param {number} k
        * @return {number}
        */
        // 整个流程就是上浮下沉
        var findKthLargest = function(nums, k) {
          let heapSize=nums.length
            buildMaxHeap(nums,heapSize) // 构建好了一个大顶堆
            // 进行下沉 大顶堆是最大元素下沉到末尾
            for(let i=nums.length-1;i>=nums.length-k+1;i--){
                swap(nums,0,i)
                --heapSize // 下沉后的元素不参与到大顶堆的调整
                // 重新调整大顶堆
                maxHeapify(nums, 0, heapSize);
            }
            return nums[0]
          // 自下而上构建一颗大顶堆
          function buildMaxHeap(nums,heapSize){
            for(let i=Math.floor(heapSize/2)-1;i>=0;i--){
                maxHeapify(nums,i,heapSize)
            }
          }
          // 从左向右，自上而下的调整节点
          function maxHeapify(nums,i,heapSize){
              let l=i*2+1
              let r=i*2+2
              let largest=i
              if(l < heapSize && nums[l] > nums[largest]){
                  largest=l
              }
              if(r < heapSize && nums[r] > nums[largest]){
                  largest=r
              }
              if(largest!==i){
                  swap(nums,i,largest) // 进行节点调整
                  // 继续调整下面的非叶子节点
                  maxHeapify(nums,largest,heapSize)
              }
          }
          function swap(a,  i,  j){
              let temp = a[i];
              a[i] = a[j];
              a[j] = temp;
          }
        };

        ```

# 二叉树

## 二叉树的深度

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
  return !root ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};
```

## 二叉树的遍历

DLR--前序遍历-中左右（根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面 ）

LDR--中序遍历-左中右（根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）

LRD--后序遍历-左右中（根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面）

### 二叉树的先序遍历

1. 非递归实现

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function (root) {
  let res = [];
  let stack = [];
  if (root) stack.push(root);
  while (stack.length > 0) {
    let node = stack.pop();
    res.push(node.val);
    if (node.right) stack.push(node.right);
    if (node.left) stack.push(node.left);
  }
  return res;
};
```

2. 递归实现

```javascript
var preorderTraversal = function (root, array = []) {
  if (root) {
    array.push(root.val);
    preorderTraversal(root.left, array);
    preorderTraversal(root.right, array);
  }
  return array;
};

var preorderTraversal = function (root) {
  let res = [];

  var preorder = function (root) {
    if (!root) return;
    res.push(root.val);
    preorder(root.left);
    preorder(root.right);
  };
  preorder(root);
  return res;
};
```

### 二叉树的中序遍历

1. 非递归实现

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
  let res = [];
  let stack = [];
  let cur = root;
  while (stack.length || cur) {
    if (cur) {
      stack.push(cur);
      cur = cur.left;
    } else {
      cur = stack.pop();
      res.push(cur.val);
      cur = cur.right;
    }
  }
  return res;
};
```

2. 递归实现

```javascript
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function (root) {
  let res = [];
  var inorder = function (root) {
    if (root) {
      inorder(root.left);
      res.push(root.val);
      inorder(root.right);
    }
  };
  inorder(root);
  return res;
};
```

### 二叉树的后序遍历

1. 非递归遍历

```js
const inorderTraversal = (root) => {
  if (!root) return [];
  const res = [];
  const stack = [];
  while (root || stack.length) {
    while (root) {
      stack.push(root);
      root = root.left;
    }
    root = stack.pop();
    res.push(root.val);
    root = root.right;
  }
  return res;
};

// 方法二
var postorderTraversal = function (root) {
  let res = [];
  let stack = [];
  if (!root) return res;
  stack.push(root);
  let cur = null;
  while (stack.length) {
    cur = stack.pop();
    res.push(cur.val);
    if (cur.left) stack.push(cur.left);
    if (cur.right) stack.push(cur.right);
  }
  return res.reverse();
};
```

### 二叉树的层序遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function (root) {
  const res = [];
  if (!root) return res;

  let seq = [];
  seq.push(root);

  while (seq.length !== 0) {
    let len = seq.length;
    res.push([]);

    for (let i = 1; i <= len; i++) {
      let node = seq.shift();
      res[res.length - 1].push(node.val);
      if (node.left) seq.push(node.left);
      if (node.right) seq.push(node.right);
    }
  }

  return res;
};

// 二叉树的锯齿形层序遍历
var zigzagLevelOrder = function (root) {
  if (!root) return [];
  let res = [];
  let seq = [];
  seq.push(root);
  let flag = true;
  while (seq.length) {
    let len = seq.length;
    res.push([]);
    for (let i = 1; i <= len; i++) {
      let node = seq.shift();
      if (flag) {
        res[res.length - 1].push(node.val);
      } else {
        res[res.length - 1].unshift(node.val);
      }
      if (node.left) seq.push(node.left);
      if (node.right) seq.push(node.right);
    }
    flag = !flag;
  }
  return res;
};
```

### N 叉树

1. N 叉树的层序遍历

```js
var levelOrder = function (root) {
  if (!root) return [];
  let res = [];
  let seq = [];
  seq.push(root);
  while (seq.length) {
    let len = seq.length;
    let curArr = [];
    while (len--) {
      let node = seq.shift();
      curArr.push(node.val);
      for (let item of node.children) {
        if (item) seq.push(item);
      }
    }
    res.push(curArr);
  }
  return res;
};
```

2. N 叉树的前序遍历

```js
// 递归
/**
 * // Definition for a Node.
 * function Node(val, children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node|null} root
 * @return {number[]}
 */
var preorder = function (root) {
  let res = [];
  var preCheck = function (root) {
    if (root) {
      res.push(root.val);
      for (let item of root.children) {
        preCheck(item);
      }
    }
  };
  preCheck(root);
  return res;
};
```

3. N 叉树的后序遍历

```js
// 递归
var postorder = function (root) {
  let res = [];
  var postCheck = function (node) {
    if (node) {
      for (let i = 0; i < node.children.length; i++) {
        postCheck(node.children[i]);
      }
      res.push(node.val);
    }
  };
  postCheck(root);
  return res;
};
```

## 确定一棵二叉树

```js
// 前序和中序确定一棵二叉树
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function (preorder, inorder) {
  if (!preorder.length) return null;

  let root = new TreeNode(preorder[0]);

  let index = inorder.findIndex((item) => item === root.val);

  root.left = buildTree(preorder.slice(1, index + 1), inorder.slice(0, index));
  root.right = buildTree(
    preorder.slice(index + 1, preorder.length),
    inorder.slice(index + 1, preorder.length)
  );
  return root;
};
```

```js
// 后序和中序确定一棵二叉树
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function (inorder, postorder) {
  if (!postorder.length) return null;

  let root = new TreeNode(postorder[postorder.length - 1]);

  let index = inorder.findIndex((item) => item === root.val);

  root.left = buildTree(inorder.slice(0, index), postorder.slice(0, index));
  root.right = buildTree(
    inorder.slice(index + 1, index.length),
    postorder.slice(index, postorder.length - 1)
  );
  return root;
};
```

## 最大二叉树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function (nums) {
  if (nums.length == 0) return null;
  var big = Math.max(...nums);
  var root = new TreeNode(big);
  root.left = constructMaximumBinaryTree(nums.slice(0, nums.indexOf(big)));
  root.right = constructMaximumBinaryTree(nums.slice(nums.indexOf(big) + 1));
  return root;
};
```

## 是否为对称二叉树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
  var check = function (left, right) {
    if (!left && !right) return true;
    if (!left || !right) return false;
    return (
      left.val === right.val &&
      check(left.left, right.right) &&
      check(left.right, right.left)
    );
  };
  return check(root, root);
};
```

## 二叉树的最小深度和最大深度

```js
// 最小深度
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {
  var getDepth = function (root) {
    if (!root) return 0;
    if (!root.left && !root.right) return 1;
    if (!root.left) return 1 + getDepth(root.right);
    if (!root.right) return 1 + getDepth(root.left);
    return 1 + Math.min(getDepth(root.left), getDepth(root.right));
  };
  return getDepth(root);
};
```

```js
// 最大深度
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
  var getDepth = function (root) {
    if (!root) return 0;
    return 1 + Math.max(getDepth(root.left), getDepth(root.right));
  };
  return getDepth(root);
};
```

## 合并二叉树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function (root1, root2) {
  var preOrder = function (root1, root2) {
    if (!root1 && !root2) return null;
    if (!root1) return root2;
    if (!root2) return root1;
    root1.val += root2.val;
    root1.left = mergeTrees(root1.left, root2.left);
    root1.right = mergeTrees(root1.right, root2.right);
    return root1;
  };
  return preOrder(root1, root2);
};
```

## 完全二叉树的节点个数

层序遍历

## 树的子结构

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} A
 * @param {TreeNode} B
 * @return {boolean}
 */
var isSubStructure = function (A, B) {
  // 约定空树不是任意一个树的子结构
  if (!A || !B) return false;
  return (
    isSameTree(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B)
  );
};
var isSameTree = function (A, B) {
  if (!B) return true;
  if (!A) return false;
  if (A.val !== B.val) return false;
  return isSameTree(A.left, B.left) && isSameTree(A.right, B.right);
};
```

## 二叉树的所有路径

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function (root) {
  if (!root) return [];
  let res = [];

  var getPath = function (node, curPath) {
    // 确定终止条件，到叶子结点就终止
    if (!node.left && !node.right) {
      curPath += node.val;
      res.push(curPath);
      return;
    }

    curPath += node.val + "->";

    if (node.left) getPath(node.left, curPath);
    if (node.right) getPath(node.right, curPath);
  };
  getPath(root, "");
  return res;
};
```

## 二叉搜索树中的搜索

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var searchBST = function (root, val) {
  if (!root || root.val === val) {
    return root;
  }
  if (root.val < val) {
    return searchBST(root.right, val);
  }
  if (root.val > val) {
    return searchBST(root.left, val);
  }
  // return null
};
```

## 左叶子之和

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function (root) {
  if (!root) return null;
  let sum = 0;
  let seq = [];
  seq.push(root);

  while (seq.length) {
    let len = seq.length;
    for (let i = 1; i <= len; i++) {
      let node = seq.shift();
      if (node.left && !node.left.left && !node.left.right) {
        sum += node.left.val;
      }
      if (node.left) seq.push(node.left);
      if (node.right) seq.push(node.right);
    }
  }
  return sum;
};

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function (root) {
  let res = 0;
  var getSum = function (root, value) {
    if (!root.left && !root.right && value === 1) {
      res += root.val;
      return;
    }
    if (root.left) getSum(root.left, 1);
    if (root.right) getSum(root.right, 2);
  };
  getSum(root, 2);
  return res;
};
```

## 找树左下角的值

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var findBottomLeftValue = function (root) {
  if (!root) return null;
  let res = 0;
  let seq = [];
  seq.push(root);

  while (seq.length) {
    let len = seq.length;

    for (let i = 1; i <= len; i++) {
      let node = seq.shift();
      if (i === 1) {
        res = node.val;
      }
      if (node.left) seq.push(node.left);
      if (node.right) seq.push(node.right);
    }
  }

  return res;
};
```

## 二叉树中和为某一值的路径(难)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} target
 * @return {number[][]}
 */
//  方法一
var pathSum = function (root, target) {
  if (!root) return [];
  var getPath = function (sum, path, node) {
    if (node.val === sum && !node.left && !node.right) {
      res.push(path);
    }
    path.push(node.val);
    if (node.left) getPath(sum - node.val, path.slice(), node.left);
    if (node.right) getPath(sum - node.val, path.slice(), node.right);
  };
  let res = [];
  getPath(target, [], root);
  return res;
};

// 方法二
var pathSum = function (root, target) {
  if (!root) return [];
  let res = [];
  let path = [];
  var getPath = function (node, sum) {
    if (sum + node.val === target && !node.left && !node.right) {
      res.push([...path, node.val]);
      return;
    }
    path.push(node.val);
    if (node.left) getPath(node.left, sum + node.val, path);
    if (node.right) getPath(node.right, sum + node.val, path);
    path.pop();
  };
  getPath(root, 0);
  return res;
};
```

## 路径总和

https://leetcode-cn.com/problems/path-sum-ii/

```js
//路径总和I
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function (root, targetSum) {
  if (!root) return false;
  if (!root.left && !root.right) {
    return targetSum - root.val === 0;
  }
  return (
    hasPathSum(root.left, targetSum - root.val) ||
    hasPathSum(root.right, targetSum - root.val)
  );
};

//路径总和II
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number[][]}
 */
var pathSum = function (root, targetSum) {
  if (!root) return [];
  let res = [];
  var getPath = function (node, curPath, sum) {
    if (sum === 0 && !node.left && !node.right) {
      res.push([...curPath]);
      return;
    }
    if (!node.left && !node.right) return;
    if (node.left) {
      curPath.push(node.left.val);
      getPath(node.left, curPath, sum - node.left.val);
      curPath.pop();
    }
    if (node.right) {
      curPath.push(node.right.val);
      getPath(node.right, curPath, sum - node.right.val);
      curPath.pop();
    }
    return;
  };
  getPath(root, [root.val], targetSum - root.val);
  return res;
};
```

## 翻转二叉树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {
  if (!root) return null;
  var invert = function (left, right) {
    let temp = left;
    left = right;
    right = temp;
    root.left = left;
    root.right = right;
  };
  invert(root.left, root.right);
  invertTree(root.left);
  invertTree(root.right);
  return root;
};
```

## 二叉搜索树

1. 二叉搜索树中的搜索

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} val
    * @return {TreeNode}
    */
   var searchBST = function (root, val) {
     if (!root || root.val === val) return root;
     if (root.val > val) {
       return searchBST(root.left, val);
     }
     if (root.val < val) {
       return searchBST(root.right, val);
     }
     return null;
   };
   ```

2. 验证二叉搜索树

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {boolean}
    */
   //  中序遍历
   var isValidBST = function (root) {
     let arr = [];
     var inorder = function (node) {
       if (node) {
         inorder(node.left);
         arr.push(node.val);
         inorder(node.right);
       }
     };
     inorder(root);
     for (let i = 1; i < arr.length; i++) {
       if (arr[i] <= arr[i - 1]) {
         return false;
       }
     }
     return true;
   };

   // 递归
   var isValidBST = function (root) {
     var isCheck = function (root, min = -Infinity, max = Infinity) {
       if (!root) return true;
       if (root.val <= min || root.val >= max) return false;
       return (
         isCheck(root.left, min, root.val) && isCheck(root.right, root.val, max)
       );
     };
     return isCheck(root);
   };
   ```

3. 二叉搜索树中的众数

   ```js
   var findMode = function (root) {
     let map = new Map();
     var inorder = function (node) {
       if (node) {
         inorder(node.left);
         map.set(node.val, map.has(node.val) ? map.get(node.val) + 1 : 1);
         inorder(node.right);
       }
     };
     inorder(root);

     let maxValue = map.get(root.val);
     let res = [];
     for (let [key, value] of map) {
       if (value === maxValue) {
         res.push(key);
       }
       if (value > maxValue) {
         res = [];
         maxValue = value;
         res.push(key);
       }
     }
     return res;
   };
   ```

# 链表

1.  反转链表

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @return {ListNode}
     */
    var reverseList = function (head) {
      let prev = null;
      let curr = head;
      //如果curr为null,则其已经成为最后一个节点，链表已经反转完成
      while (curr) {
        //先用next保存下一个节点
        let next = curr.next;
        //将curr指向prev前面一个节点
        curr.next = prev;
        //prev节点后移
        prev = curr;
        //curr节点也后移
        curr = next;
      }
      return prev;
    };
    ```

2.  合并两个排序的链表

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} l1
     * @param {ListNode} l2
     * @return {ListNode}
     */
    var mergeTwoLists = function (l1, l2) {
      if (!l1) {
        return l2;
      }
      if (!l2) {
        return l1;
      }
      let head;
      if (l1.val < l2.val) {
        head = l1;
        head.next = mergeTwoLists(l1.next, l2);
      } else {
        head = l2;
        head.next = mergeTwoLists(l1, l2.next);
      }
      return head;
    };
    ```

3.  删除链表中的节点

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} val
     * @return {ListNode}
     */

    var deleteNode = function (head, val) {
      if (head.val === val) {
        return head.next;
      }
      head.next = deleteNode(head.next, val);
      return head;
    };

    // 方法二
    var removeElements = function (head, val) {
      // 设置虚拟节点
      let dummyHead = new ListNode(0, head);
      let temp = dummyHead;
      while (temp.next) {
        if (temp.next.val === val) {
          // 如果节点值相等，temp节点就指向temp.next.next
          temp.next = temp.next.next;
        } else {
          // 否则temp就一项下一节点
          temp = temp.next;
        }
      }
      // 返回头结点
      return dummyHead.next;
    };
    ```

4.  两两交换链表中的节点

5.  设计链表

6.  从尾到头打印链表

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @return {number[]}
     */
    var reversePrint = function (head) {
      let res = [];
      while (head) {
        res.unshift(head.val);
        head = head.next;
      }
      return res;
    };
    ```

7.  链表中倒数第 k 个节点

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} k
     * @return {ListNode}
     */
    var getKthFromEnd = function (head, k) {
      let total = 0,
        node = head;
      while (node) {
        total++;
        node = node.next;
      }
      let index = total - k;
      while (index) {
        head = head.next;
        index--;
      }
      return head;
    };
    ```

8.  相交链表

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */

    /**
     * @param {ListNode} headA
     * @param {ListNode} headB
     * @return {ListNode}
     */
    var getIntersectionNode = function (headA, headB) {
      var getListLen = function (head) {
        let len = 0,
          cur = head; // 不能直接使用head，否则head会被修改
        while (cur) {
          len++;
          cur = cur.next;
        }
        return len;
      };

      let curA = headA,
        curB = headB,
        lenA = getListLen(headA),
        lenB = getListLen(headB);
      if (lenA < lenB) {
        [curA, curB] = [curB, curA]; //这里的分号一定要加
        [lenA, lenB] = [lenB, lenA];
      }
      let i = lenA - lenB;
      while (i-- > 0) {
        curA = curA.next;
      }
      while (curA && curA !== curB) {
        curA = curA.next;
        curB = curB.next;
      }
      return curA;
    };
    ```

9.  删除排序链表中的重复元素

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} head
     * @return {ListNode}
     */
    var deleteDuplicates = function (head) {
      if (!head) return head; //不能返回[]

      let pre = head;
      while (pre.next) {
        if (pre.val === pre.next.val) {
          pre.next = pre.next.next; // 最后可以指向Null
        } else {
          pre = pre.next;
        }
      }
      return head;
    };
    ```

10. 环形链表

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */

    /**
     * @param {ListNode} head
     * @return {boolean}
     */
    var hasCycle = function (head) {
      const map = new Map();
      while (head) {
        if (map.has(head)) return true;
        map.set(head, true);
        head = head.next;
      }
      return false;
    };
    ```

    ```js
    var hasCycle = function (head) {
      //设置快慢指针
      let slow = head;
      let fast = head;
      //如果没有环，则快指针会抵达终点，否则继续移动双指针
      while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        //快慢指针相遇，说明含有环
        if (slow == fast) {
          return true;
        }
      }

      return false;
    };
    ```

11. 回文链表

12. 两数相加

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} l1
     * @param {ListNode} l2
     * @return {ListNode}
     */
    var addTwoNumbers = function (l1, l2) {
      let dummy = new ListNode();
      let cur = dummy;
      let carry = 0;
      while (l1 || l2) {
        const x = l1 ? l1.val : 0;
        const y = l2 ? l2.val : 0;

        let sum = x + y + carry;
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        carry = Math.floor(sum / 10);

        if (l1) l1 = l1.next;
        if (l2) l2 = l2.next;
      }
      if (carry) cur.next = new ListNode(carry);
      return dummy.next;
    };
    ```

# 数组

```js
//找出数组中重复数字
/**
 * @param {number[]} nums
 * @return {number}
 */
var findRepeatNumber = function (nums) {
  let map = new Map();
  for (let i of nums) {
    if (map.has(i)) return i;
    map.set(i, 1);
  }
  return null;
};

//最大子序和
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
  let pre = 0;
  let maxSum = nums[0];
  nums.forEach((x) => {
    //如果之前的和加上当前元素值还没有当前元素值大，则丢弃
    pre = Math.max(pre + x, x);
    maxSum = Math.max(pre, maxSum);
  });
  return maxSum;
};

//动态规划
var maxSubArray = function (nums) {
  const dp = new Array(nums.length);
  dp[0] = nums[0];
  let result = dp[0];
  for (let i = 1; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);

    if (result < dp[i]) {
      result = dp[i];
    }
  }
  return result;
};

//数组变整数加一
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function (digits) {
  for (let i = digits.length - 1; i >= 0; i--) {
    digits[i]++;
    digits[i] = digits[i] % 10;
    if (digits[i] != 0) {
      return digits;
    }
  }
  digits.unshift(1);
  return digits;
};

//有序数组的平方
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function (nums) {
  let newNum = nums.map((x) => {
    return (x = x * x);
  });
  newNum.sort((x, y) => x - y);
  return newNum;
};
```

# 哈希表

1. 两数之和

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number[]}
    */

   //  时间复杂度O(n)
   // 空间复杂度O(n)
   var twoSum = function (nums, target) {
     const map = {};
     if (Array.isArray(nums)) {
       for (let i = 0; i < nums.length; i++) {
         // 有可能存在0的情况
         if (map[target - nums[i]] != undefined) {
           return [map[target - nums[i]], i];
         } else {
           map[nums[i]] = i;
         }
       }
     }
   };
   ```

2. 三数之和

   ```js
   // 方法一
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var threeSum = function (nums) {
     let res = [];
     let len = nums.length;
     if (nums == null || len < 3) {
       return res;
     }
     // 数组中有数字重复，sort一定要写全
     nums.sort((a, b) => a - b);
     for (let i = 0; i < len; i++) {
       if (nums[i] > 0) break;
       if (i > 0 && nums[i] == nums[i - 1]) continue;
       let L = i + 1;
       let R = len - 1;
       while (L < R) {
         let sum = nums[i] + nums[L] + nums[R];
         if (sum === 0) {
           res.push([nums[i], nums[L], nums[R]]);
           while (L < R && nums[L] === nums[L + 1]) L++;
           while (L < R && nums[R] === nums[R - 1]) R--;
           L++;
           R--;
         } else if (sum < 0) L++;
         else if (sum > 0) R--;
       }
     }
     return res;
   };
   ```

3. 四数之和

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number[][]}
    */
   var fourSum = function (nums, target) {
     if (nums.length < 4) return [];
     let res = [];
     nums.sort((a, b) => a - b);

     for (let i = 0; i < nums.length; i++) {
       if (i > 0 && nums[i] === nums[i - 1]) continue;
       for (let j = i + 1; j < nums.length; j++) {
         if (j > i + 1 && nums[j] === nums[j - 1]) continue;
         let L = j + 1,
           R = nums.length - 1;
         while (L < R) {
           let sum = nums[i] + nums[j] + nums[L] + nums[R];
           if (sum === target) {
             res.push([nums[i], nums[j], nums[L], nums[R]]);
             while (L < R && nums[L] === nums[R]) L++;
             while (L < R && nums[R] === nums[R - 1]) R--;
             L++;
             R--;
           } else if (sum < target) L++;
           else if (sum > target) R--;
         }
       }
     }
     return res;
   };
   ```

4. 四数之和二

   ```js
   /**
    * @param {number[]} nums1
    * @param {number[]} nums2
    * @param {number[]} nums3
    * @param {number[]} nums4
    * @return {number}
    */
   var fourSumCount = function (nums1, nums2, nums3, nums4) {
     let res = 0;
     let map1 = new Map();

     for (let key1 of nums1) {
       for (let key2 of nums2) {
         let sum = key1 + key2;
         map1.set(sum, map1.has(sum) ? map1.get(sum) + 1 : 1);
       }
     }
     for (let key1 of nums3) {
       for (let key2 of nums4) {
         let sum2 = key1 + key2;
         res += map1.has(0 - sum2) ? map1.get(0 - sum2) : 0;
       }
     }
     return res;
   };
   ```

5. 两个数组的交集

   ```js
   /**
    * @param {number[]} nums1
    * @param {number[]} nums2
    * @return {number[]}
    */
   var intersection = function (nums1, nums2) {
     let numberA = new Set(nums1);
     let numberB = new Set(nums2);
     let res = [];
     if (numberA.length > numberB.length) {
       let temp = numberA;
       numberA = numberB;
       numberB = temp;
     }
     for (let value of numberA) {
       if (numberB.has(value)) {
         res.push(value);
       }
     }
     return res;
   };
   ```

6. 快乐数

   ```js
   /**
    * @param {number} n
    * @return {boolean}
    */
   var isHappy = function (n) {
     let map = new Map();
     var getSum = function (n) {
       let res = 0;
       while (n) {
         number = n % 10;
         res += number * number;
         n = Math.floor(n / 10);
       }
       return res;
     };

     while (true) {
       if (map.has(n)) return false;
       if (n === 1) return true;
       map.set(n, 1);
       n = getSum(n);
     }
   };
   ```

# 动态规划

1. 使用最小花费爬楼梯

   ```js
   /**
    * @param {number[]} cost
    * @return {number}
    */
   var minCostClimbingStairs = function (cost) {
     // fill(0)可以不加
     let dp = new Array(cost.length).fill(0);
     dp[0] = cost[0];
     dp[1] = cost[1];
     for (let i = 2; i < cost.length; i++) {
       dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
     }

     return Math.min(dp[cost.length - 1], dp[cost.length - 2]);
   };
   ```

2. 整数拆分

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var integerBreak = function (n) {
     let dp = new Array(n + 1).fill(0);
     dp[2] = 1;
     for (let i = 3; i <= n; i++) {
       for (let j = 1; j < i; j++) {
         dp[i] = Math.max(dp[i], dp[i - j] * j, (i - j) * j);
       }
     }
     return dp[n];
   };
   ```

3. 不同的二叉搜索树

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var numTrees = function (n) {
     // fill(0)一定要加
     let dp = new Array(n + 1).fill(0);
     dp[0] = 1;
     dp[1] = 1;
     // 注意i的初始值， 从2开始， 从1开始的话dp[i]会重新计算变为2
     for (let i = 2; i <= n; i++) {
       for (let j = 1; j <= i; j++) {
         dp[i] += dp[j - 1] * dp[i - j];
       }
     }
     return dp[n];
   };
   ```

- 0-1 背包

  ```js
  for (let i = 0; i < weight.length; i++) {
    for (let j = bagWeight; j >= weight[i]; j++) {
      dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
    }
  }
  ```

- 完全背包

  1. 完全背包

     ```js
     // 先遍历物品，再遍历背包
     for(int i = 0; i < weight.size(); i++) { // 遍历物品
       for(int j = weight[i]; j < bagWeight ; j++) { // 遍历背包容量
           dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

       }
     }
     ```

  2. 求组合个数

     ```js
     for (int i = 0; i < coins.size(); i++) { // 遍历物品
       for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
           dp[j] += dp[j - coins[i]];
       }
     }
     ```

  3. 求排列个数

     ```js
     for (int j = 0; j <= amount; j++) { // 遍历背包容量
       for (int i = 0; i < coins.size(); i++) { // 遍历物品
           if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
       }
     }
     ```

4. 分割等和子集

   ```js
   /**
    * @param {number[]} nums
    * @return {boolean}
    */
   var canPartition = function (nums) {
     let sum = nums.reduce((pre, cur) => {
       return pre + cur;
     });
     if (sum % 2 === 1) return false;
     let average = sum / 2;

     var dp = new Array(average + 1).fill(0);

     for (let i = 0; i < nums.length; i++) {
       for (let j = average; j >= nums[i]; j--) {
         dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
         if (dp[j] === average) {
           return true;
         }
       }
     }
     return dp[sum / 2] === sum / 2;
   };
   ```

5. 最后一块石头的重量二

6. 目标和

   ```js
   // 方法一: 回溯法
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number}
    */
   var findTargetSumWays = function (nums, target) {
     let count = 0;

     var getRes = function (sum, index) {
       if (index === nums.length) {
         if (sum === target) {
           count++;
         }
       } else {
         getRes(sum + nums[index], index + 1);
         getRes(sum - nums[index], index + 1);
       }
     };
     getRes(0, 0);
     return count;
   };
   ```

7. 1 和 0

8. 零钱兑换 2

   ```js
   /**
    * @param {number} amount
    * @param {number[]} coins
    * @return {number}
    */
   var change = function (amount, coins) {
     let dp = new Array(amount + 1).fill(0);
     dp[0] = 1;

     for (let i = 0; i < coins.length; i++) {
       for (let j = coins[i]; j <= amount; j++) {
         dp[j] += dp[j - coins[i]];
       }
     }
     return dp[amount];
   };
   ```

9. 组合总和四
   回溯法容易超出时间限制

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number}
    */
   var combinationSum4 = function (nums, target) {
     // 先遍历背包，再遍历物品
     let dp = new Array(target + 1).fill(0);
     dp[0] = 1;
     for (let i = 0; i <= target; i++) {
       for (let j = 0; j < nums.length; j++) {
         if (i >= nums[j]) dp[i] += dp[i - nums[j]];
       }
     }
     return dp[target];
   };
   ```

10. 零钱兑换

    ```js
    /**
     * @param {number[]} coins
     * @param {number} amount
     * @return {number}
     */
    var coinChange = function (coins, amount) {
      if (!amount) return 0;
      let dp = new Array(amount + 1).fill(Infinity);
      dp[0] = 0;

      for (let i = 0; i < coins.length; i++) {
        for (let j = coins[i]; j <= amount; j++) {
          dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
        }
      }
      return dp[amount] === Infinity ? -1 : dp[amount];
    };
    ```

11. 完全平方数

12. 单词拆分

13. 打家劫舍一二三

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var rob = function (nums) {
      let dp = new Array(nums.length + 1).fill(0);
      (dp[0] = nums[0]), (dp[1] = Math.max(nums[0], nums[1]));
      for (let i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
      }

      return dp[nums.length - 1];
    };
    ```

14. 买卖股票的最佳时机 一二三四

15. 最长递增(上升)子序列

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var lengthOfLIS = function (nums) {
      // 注意初始值
      let dp = new Array(nums.length).fill(1);
      let res = 1;
      for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
          if (nums[i] > nums[j]) {
            // 位置i的最长上升子序列等于j从i-1各个位置的最长升序子序列 + 1的最大值
            dp[i] = Math.max(dp[i], dp[j] + 1);
          }
        }
        if (res < dp[i]) {
          res = dp[i];
        }
      }
      return res;
    };
    ```

16. 最长连续递增序列

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var findLengthOfLCIS = function (nums) {
      let dp = new Array(nums.length).fill(1);
      let result = 1;
      for (let i = 0; i < nums.length - 1; i++) {
        if (nums[i + 1] > nums[i]) {
          dp[i + 1] = dp[i] + 1;
        }
        if (result < dp[i + 1]) {
          result = dp[i + 1];
        }
      }
      return result;
    };
    ```

17. 最长重复子数组

    ```js
    /**
     * @param {number[]} nums1
     * @param {number[]} nums2
     * @return {number}
     */
    var findLength = function (nums1, nums2) {
      // 注意长度
      let dp = new Array(nums1.length + 1)
        .fill(0)
        .map((x) => new Array(nums2.length + 1).fill(0));
      let result = 0;
      for (let i = 1; i <= nums1.length; i++) {
        for (let j = 1; j <= nums2.length; j++) {
          if (nums1[i - 1] === nums2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          }
          if (result < dp[i][j]) {
            result = dp[i][j];
          }
        }
      }
      return result;
    };
    ```

18. 最长公共子序列

    ```js
    /**
     * @param {string} text1
     * @param {string} text2
     * @return {number}
     */
    var longestCommonSubsequence = function (text1, text2) {
      let dp = new Array(text1.length + 1)
        .fill(0)
        .map((x) => new Array(text2.length + 1).fill(0));

      for (let i = 1; i <= text1.length; i++) {
        for (let j = 1; j <= text2.length; j++) {
          if (text1[i - 1] === text2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
          }
        }
      }
      return dp[text1.length][text2.length];
    };
    ```

19. 最大子数组和(最大子序和)

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var maxSubArray = function (nums) {
      let dp = new Array(nums.length).fill(0);
      // 注意result初始值，[1]的情况
      let result = nums[0];
      dp[0] = nums[0];
      for (let i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);

        if (result < dp[i]) {
          result = dp[i];
        }
      }
      return result;
    };
    ```

20. 判断子序列

    ```js
    /**
     * @param {string} s
     * @param {string} t
     * @return {boolean}
     */
    var isSubsequence = function (s, t) {
      let index = 0;
      for (let i = 0; i < t.length; i++) {
        if (s[index] === t[i]) {
          index++;
        }
      }
      return index >= s.length;
    };
    ```

    ```js
    var isSubsequence = function (s, t) {
      let [m, n] = [s.length, t.length];
      let dp = new Array(m + 1).fill().map((item) => new Array(n + 1).fill(0));

      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (s[i - 1] === t[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = dp[i][j - 1];
          }
        }
      }
      return dp[m][n] === m;
    };
    ```

21. 回文子串

    ```js
    /**
     * @param {string} s
     * @return {number}
     */
    var countSubstrings = function (s) {
      var isHW = function (str, l, r) {
        for (let i = l, j = r; i < j; i++, j--) {
          if (str[i] !== str[j]) {
            return false;
          }
        }
        return true;
      };
      let res = 0;
      for (let i = 0; i < s.length; i++) {
        for (let j = i; j < s.length; j++) {
          if (isHW(s, i, j)) {
            res += 1;
          }
        }
      }
      return res;
    };
    ```

22. 最长回文子序列

    ```js

    ```

23. 不相交的线

    ```js
    /**
     * @param {number[]} nums1
     * @param {number[]} nums2
     * @return {number}
     */
    var maxUncrossedLines = function (nums1, nums2) {
      let [m, n] = [nums1.length, nums2.length];
      let dp = new Array(m + 1).fill().map((item) => new Array(n + 1).fill(0));

      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (nums1[i - 1] === nums2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
          }
        }
      }
      return dp[m][n];
    };
    ```

24. 最小路径和

    ```js
    /**
     * @param {number[][]} grid
     * @return {number}
     */
    var minPathSum = function (grid) {
      if (grid.length === 0 || grid[0].length === 0) return 0;
      let rows = grid.length,
        columns = grid[0].length;
      // 定义二维数组
      const dp = new Array(rows);
      for (let i = 0; i < rows; i++) {
        dp[i] = new Array(columns);
      }
      dp[0][0] = grid[0][0];
      for (let i = 1; i < rows; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
      }
      for (let j = 1; j < columns; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
      }

      for (let i = 1; i < rows; i++) {
        for (let j = 1; j < columns; j++) {
          dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
        }
      }

      return dp[rows - 1][columns - 1];
    };
    ```

25. 三角形最小路径和

    ```js
    /**
     * @param {number[][]} triangle
     * @return {number}
     */
    var minimumTotal = function (triangle) {
      let dp = new Array(triangle.length)
        .fill()
        .map((item, index) => new Array(triangle[index].length).fill(0));
      let len = triangle.length;

      // 这里倒序
      for (let i = len - 1; i >= 0; i--) {
        // 这里正序
        for (let j = 0; j < triangle[i].length; j++) {
          if (i === len - 1) {
            // 最后一行初始化写在里面
            dp[i][j] = triangle[i][j];
          } else {
            dp[i][j] =
              Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j];
          }
        }
      }
      return dp[0][0];
    };
    ```

26. 礼物的最大价值

    ```js
    /**
     * @param {number[][]} grid
     * @return {number}
     */
    var maxValue = function (grid) {
      let m = grid.length,
        n = grid[0].length;

      let dp = new Array(m).fill().map((item) => Array(n).fill(0));
      dp[0][0] = grid[0][0];
      for (let i = 1; i < m; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
      }

      for (let i = 1; i < n; i++) {
        dp[0][i] = dp[0][i - 1] + grid[0][i];
      }

      for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
          dp[i][j] = Math.max(
            dp[i - 1][j] + grid[i][j],
            dp[i][j - 1] + grid[i][j]
          );
        }
      }
      return dp[m - 1][n - 1];
    };
    ```

27. 最长连续序列

# 回溯

- for 循环横向遍历， 递归纵向遍历
- 题目分类: 组合(1,2)，子集(3,4,5)， 排列(6,7,8)， 分割(9,10)， 棋盘问题， 其它(递增子序列， 重新安排行程)

1. T77 组合

   ```js
   /**
    * @param {number} n
    * @param {number} k
    * @return {number[][]}
    */
   var combine = function (n, k) {
     let res = [],
       path = [];

     var getPath = function (index) {
       if (path.length === k) {
         res.push([...path]);
         return;
       }
       for (let i = index; i <= n; i++) {
         path.push(i);
         getPath(i + 1);
         path.pop();
       }
     };
     getPath(1);
     return res;
   };
   ```

2. T216 组合

   ```js
   /**
    * @param {number} k
    * @param {number} n
    * @return {number[][]}
    */
   var combinationSum3 = function (k, n) {
     let res = [],
       path = [];
     var getPath = function (sum, index) {
       if (sum > n) return;
       if (sum === n && path.length === k) {
         res.push([...path]);
         return;
       }
       for (let i = index; i <= 9; i++) {
         path.push(i);
         getPath(sum + i, i + 1);
         path.pop();
       }
     };
     getPath(0, 1);
     return res;
   };
   ```

3. T39 允许重复选择元素的组合

   ```js
   var combinationSum = function (candidates, target) {
     candidates.sort();
     let res = [];
     var getPath = function (sum, path, j) {
       // if (sum > target) return
       if (sum === target) {
         res.push([...path]);
         return;
       }
       for (let i = j; i < candidates.length; i++) {
         let number = candidates[i];
         if (number > target - sum) continue;
         path.push(number);

         sum += number;
         // 不能写sum+candidates[i], 否则 sum-=number改的就是原来的sum, 不是加过number后的sum
         getPath(sum, path, i);
         path.pop();
         sum -= number;
       }
     };
     getPath(0, [], 0);
     return res;
   };
   ```

4. T40 || 含有重复元素集合的组合(难)

   ```js
   var combinationSum2 = function (candidates, target) {
     const res = [],
       path = [];
     candidates.sort(); // 排序
     backtracking(0, 0);
     return res;
     function backtracking(j, sum) {
       if (sum > target) return;
       if (sum === target) {
         res.push(Array.from(path));
         return;
       }
       let f = -1;
       for (let i = j; i < candidates.length; i++) {
         const n = candidates[i];
         if (n > target - sum || f === n) continue;
         path.push(n);
         sum += n;
         backtracking(i + 1, sum);
         f = n;
         path.pop();
         sum -= n;
       }
     }
   };
   ```

5. 递增子序列

   ```js
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var findSubsequences = function (nums) {
     let res = [];

     var getPath = function (path, j) {
       if (path.length > 1) {
         res.push([...path]);
       }
       let uset = [];
       for (let i = j; i < nums.length; i++) {
         if (
           (path.length > 0 && nums[i] < path[path.length - 1]) ||
           uset[nums[i] + 100]
         )
           continue;
         uset[nums[i] + 100] = true;
         path.push(nums[i]);
         getPath(path, i + 1);
         path.pop();
       }
     };
     getPath([], 0);
     return res;
   };
   ```

6. 全排列

   ```js
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var permute = function (nums) {
     let res = [];
     var getPath = function (path, used) {
       if (path.length === nums.length) {
         res.push([...path]);
         return;
       }
       for (let i = 0; i < nums.length; i++) {
         if (used[i]) continue;
         path.push(nums[i]);
         used[i] = true;
         getPath(path, used);
         path.pop();
         used[i] = false;
       }
     };
     getPath([], []);
     return res;
   };
   ```

7. 全排列(含有重复数字) - 可以用 f

   ```js
   // 方法一
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var permuteUnique = function (nums) {
     nums.sort((a, b) => a - b);
     let res = [];
     var getPath = function (path, used) {
       if (path.length === nums.length) {
         res.push([...path]);
         return;
       }
       let f = "";
       for (let i = 0; i < nums.length; i++) {
         if (used[i] || f === nums[i]) continue;
         path.push(nums[i]);
         f = nums[i];
         used[i] = true;
         getPath(path, used);
         path.pop();
         used[i] = false;
       }
     };
     getPath([], []);
     return res;
   };
   ```

8. 字符串的排列(难)

   ```js
   var permutation = function (s) {
     s = s.split("").sort().join("");
     let n = s.length;

     let res = [],
       path = [];
     backtrack([]);
     return res;

     function backtrack(used) {
       if (path.length === n) {
         res.push(path.slice());
         return;
       }

       for (let i = 0; i < n; i++) {
         if (used[i]) continue;
         if (i > 0 && s[i] === s[i - 1] && !used[i - 1]) continue;

         used[i] = 1;
         path = path + s[i];
         backtrack(used);
         used[i] = 0;
         path = path.slice(0, path.length - 1);
       }
     }
   };
   ```

   ```js
   /**
    * @param {string} s
    * @return {string[]}
    */
   var permutation = function (s) {
     s = s.split("").sort(); //字符排序时不需要加 (a,b) => a-b ,会出错
     let res = [];
     let len = s.length;
     var getPath = function (path, used) {
       if (path.length === len) {
         res.push(path.join(""));
         return;
       }
       let f = "";
       for (let i = 0; i < len; i++) {
         if (used[i] || f === s[i]) continue;
         path.push(s[i]);
         used[i] = true;
         f = s[i];
         getPath(path, used);
         path.pop();
         used[i] = false;
       }
     };
     getPath([], []);
     return res;
   };
   ```

9. 分割回文子字符串

   ```js
   /**
    * @param {string} s
    * @return {string[][]}
    */
   var partition = function (s) {
     let res = [],
       len = s.length;

     var isHW = function (s, l, r) {
       for (let i = l, j = r; i < j; i++, j--) {
         if (s[i] !== s[j]) return false;
       }
       return true;
     };

     var getPath = function (path, i) {
       if (i >= len) {
         res.push([...path]);
         return;
       }
       for (let j = i; j < s.length; j++) {
         if (!isHW(s, i, j)) continue;
         path.push(s.substr(i, j - i + 1));
         getPath(path, j + 1);
         path.pop();
       }
     };
     getPath([], 0);
     return res;
   };
   ```

10. 复原 IP

    ```js
    /**
     * @param {string} s
     * @return {string[]}
     */
    var restoreIpAddresses = function (s) {
      let res = [];

      var getPath = function (path, i) {
        let len = path.length;
        if (len > 4) return;
        if (len === 4 && i === s.length) {
          res.push(path.join("."));
          return;
        }
        for (let j = i; j < s.length; j++) {
          let str = s.substr(i, j - i + 1);
          if (str.length > 3 || +str > 255) break;
          if (str.length > 1 && str[0] === "0") break;
          path.push(str);
          getPath(path, j + 1);
          path.pop();
        }
      };
      getPath([], 0);
      return res;
    };
    ```

11. 加减的目标值 | 目标和

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var findTargetSumWays = function (nums, target) {
      let res = 0;
      var getRes = function (sum, index) {
        if (index === nums.length) {
          if (sum === target) {
            res++;
          }
        } else {
          getRes(sum + nums[index], index + 1);
          getRes(sum - nums[index], index + 1);
        }
      };
      getRes(0, 0);
      return res;
    };
    ```

12. 所有路径

13. 生成匹配的括号 | 括号生成

14. 矩阵中的路径 | 单词搜索

# 贪心算法

1. 分发饼干

   ```js
   /**
    * @param {number[]} g
    * @param {number[]} s
    * @return {number}
    */
   var findContentChildren = function (g, s) {
     g.sort((a, b) => a - b);
     s.sort((a, b) => a - b);
     let res = 0;
     let index = s.length - 1;
     for (let i = g.length - 1; i >= 0; i--) {
       if (index >= 0 && s[index] >= g[i]) {
         res++;
         index--;
       }
     }
     return res;
   };
   ```

2. 摆动序列

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var wiggleMaxLength = function (nums) {
     if (nums.length <= 1) return 1;
     let result = 1;
     let pre = 0;
     let cur = 0;
     for (let i = 0; i < nums.length; i++) {
       cur = nums[i + 1] - nums[i];
       if ((pre >= 0 && cur < 0) || (pre <= 0 && cur > 0)) {
         result++;
         pre = cur;
       }
     }
     return result;
   };
   ```

# 滑动窗口

https://leetcode-cn.com/problems/2VG8Kg/solution/shua-chuan-jian-zhi-offer-day06-shu-zu-i-d5ne/

如何识别滑动窗口的题目？一般题目中都会有明确的“连续子数组”、“连续子串”等关键字，另外可能会附带最大、最小的限定词进行补充。

```
初始化左边界 left = 0
初始化返回值 ret = 最小值 or 最大值
for 右边界 in 可迭代对象:
  更新窗口内部信息
  while 根据题意进行调整：
    比较并更新ret(收缩场景时)
    扩张或收缩窗口大小
  比较并更新ret(扩张场景时)
返回 ret
```

1. 和大于等于 target 的最短子数组 | 长度最小的子数组

   ```js
   /**
    * @param {number} target
    * @param {number[]} nums
    * @return {number}
    */
   var minSubArrayLen = function (target, nums) {
     let left = 0;
     let sum = 0,
       res = nums.length + 1;
     for (let right = 0; right < nums.length; right++) {
       sum += nums[right];

       while (sum >= target && left <= right) {
         res = Math.min(res, right - left + 1);

         sum -= nums[left];
         left++;
       }
     }
     return res === nums.length + 1 ? 0 : res;
   };
   ```

2. 乘积小于 k 的子数组

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var numSubarrayProductLessThanK = function (nums, k) {
     let left = 0;
     let res = 0,
       sum = 1;
     for (let right = 0; right < nums.length; right++) {
       sum *= nums[right];

       while (sum >= k && left <= right) {
         sum /= nums[left];
         left++;
       }
       res += right >= left ? right - left + 1 : 0;
     }
     return res;
   };
   ```

3. 和为 k 的子数组
   思路: 使用前缀和
   https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&idx=1&sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var subarraySum = function (nums, k) {
     let res = 0,
       sum = 0;
     let map = new Map();
     map.set(0, 1);

     for (let i = 0; i < nums.length; i++) {
       sum += nums[i];
       res += map.get(sum - k) || 0;
       map.set(sum, (map.get(sum) || 0) + 1);
     }
     return res;
   };
   ```

4. 0 和 1 个数相同的子数组
   思路: 使用前缀和

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findMaxLength = function (nums) {
     const n = nums.length;
     const map = new Map();
     map.set(0, -1);
     // 前缀和
     let pre = 0;
     let res = 0;
     for (let i = 0; i < n; i++) {
       pre += nums[i] == 0 ? -1 : 1;
       // 如果存在的话，则将当前索引和之前存入的索引值相减  取题目要求的最大值
       if (map.has(pre)) {
         res = Math.max(res, i - map.get(pre));
       } else {
         // 记录前缀和索引
         map.set(pre, i);
       }
     }
     return res;
   };
   ```

# 深度优先遍历和广度优先遍历

# 前缀和

1. 和为 k 的子数组
   思路: 使用前缀和
   https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&idx=1&sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var subarraySum = function (nums, k) {
     let res = 0,
       sum = 0;
     let map = new Map();
     map.set(0, 1);

     for (let i = 0; i < nums.length; i++) {
       sum += nums[i];
       res += map.get(sum - k) || 0;
       map.set(sum, (map.get(sum) || 0) + 1);
     }
     return res;
   };
   ```

2. 0 和 1 个数相同的子数组
   思路: 使用前缀和

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findMaxLength = function (nums) {
     const n = nums.length;
     const map = new Map();
     map.set(0, -1);
     // 前缀和
     let pre = 0;
     let res = 0;
     for (let i = 0; i < n; i++) {
       pre += nums[i] == 0 ? -1 : 1;
       // 如果存在的话，则将当前索引和之前存入的索引值相减  取题目要求的最大值
       if (map.has(pre)) {
         res = Math.max(res, i - map.get(pre));
       } else {
         // 记录前缀和索引
         map.set(pre, i);
       }
     }
     return res;
   };
   ```

# 剑指 offer II

## 简单

1. 整数除法

2. 加一

   ```js
   /**
    * @param {number[]} digits
    * @return {number[]}
    */
   var plusOne = function (digits) {
     for (let i = digits.length - 1; i >= 0; i--) {
       digits[i]++;
       digits[i] = digits[i] % 10;
       if (digits[i]) return digits;
     }
     digits.unshift(1);
     return digits;
   };
   ```

3. 数组形式的整数加法

   ```js
   /**
    * @param {number[]} num
    * @param {number} k
    * @return {number[]}
    */
   var addToArrayForm = function (num, k) {
     let res = [];
     let len1 = num.length - 1,
       carry = 0;
     while (len1 >= 0 || k !== 0) {
       const x = len1 >= 0 ? num[len1] : 0;
       const y = k !== 0 ? k % 10 : 0;

       let sum = x + y + carry;
       res.push(sum % 10);
       carry = Math.floor(sum / 10);

       len1--;
       k = Math.floor(k / 10);
     }
     if (carry) {
       res.push(carry);
     }
     return res.reverse();
   };
   ```

4. 字符串相加

   ```js
   /**
    * @param {string} num1
    * @param {string} num2
    * @return {string}
    */
   var addStrings = function (num1, num2) {
     let i = num1.length - 1,
       j = num2.length - 1;
     let res = "",
       carry = 0;
     while (i >= 0 || j >= 0) {
       const x = i >= 0 ? num1[i] - 0 : 0;
       const y = j >= 0 ? num2[j] - 0 : 0;

       const sum = x + y + carry;
       res += sum % 10;
       carry = Math.floor(sum / 10);

       i--;
       j--;
     }
     if (carry) res += carry;
     return res.split("").reverse().join("");
   };
   ```

5. 二进制求和

   ```js
   /**
    * @param {string} a
    * @param {string} b
    * @return {string}
    */
   var addBinary = function (a, b) {
     let res = "";
     let i = a.length - 1,
       j = b.length - 1;
     let carry = 0;

     while (i >= 0 || j >= 0) {
       const x = i >= 0 ? a[i] - "0" : 0;
       const y = j >= 0 ? b[j] - "0" : 0;

       let sum = x + y + carry;
       res += sum % 2;
       carry = Math.floor(sum / 2);

       i--;
       j--;
     }
     if (carry) res += carry;
     return res.split("").reverse().join("");
   };
   ```

6. 两数相加

   ```js
   /**
    * Definition for singly-linked list.
    * function ListNode(val, next) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.next = (next===undefined ? null : next)
    * }
    */
   /**
    * @param {ListNode} l1
    * @param {ListNode} l2
    * @return {ListNode}
    */
   var addTwoNumbers = function (l1, l2) {
     let dummy = new ListNode();
     let cur = dummy;
     let carry = 0;
     while (l1 || l2) {
       const x = l1 ? l1.val : 0;
       const y = l2 ? l2.val : 0;

       let sum = x + y + carry;
       cur.next = new ListNode(sum % 10);
       cur = cur.next;
       carry = Math.floor(sum / 10);

       if (l1) l1 = l1.next;
       if (l2) l2 = l2.next;
     }
     if (carry) cur.next = new ListNode(carry);
     return dummy.next;
   };
   ```

7. 排序数组中两个数字之和
   https://leetcode-cn.com/problems/kLl5u1/solution/jian-dan-yi-dong-javac-pythonjs-liang-sh-et4y/

   ```js
   /**
    * @param {number[]} numbers
    * @param {number} target
    * @return {number[]}
    */
   var twoSum = function (numbers, target) {
     let left = 0,
       right = numbers.length - 1;

     while (left < right) {
       let sum = numbers[left] + numbers[right];
       if (sum < target) {
         left++;
       } else if (sum > target) {
         right--;
       } else {
         return [left, right];
       }
     }
     return [];
   };
   ```

8. 爬楼梯的最少成本

   ```js
   /**
    * @param {number[]} cost
    * @return {number}
    */
   var minCostClimbingStairs = function (cost) {
     let len = cost.length;
     let dp = new Array(len + 1);
     (dp[0] = cost[0]), (dp[1] = cost[1]);
     for (let i = 2; i <= len; i++) {
       dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
     }
     return Math.min(dp[len - 1], dp[len - 2]);
   };
   ```

9. 左右两边子数组的和相等

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var pivotIndex = function (nums) {
     let total = nums.reduce((a, b) => a + b);
     let sum = 0;
     for (let i = 0; i < nums.length; i++) {
       if (sum === total - sum - nums[i]) {
         return i;
       }
       sum += nums[i];
     }
     return -1;
   };
   ```

10. 分割等和子集

    ```js
    /**
     * @param {number[]} nums
     * @return {boolean}
     */
    var canPartition = function (nums) {
      let sum = nums.reduce((pre, cur) => pre + cur);
      if (sum % 2 !== 0) return false;

      let number = sum / 2;
      let dp = new Array(number + 1).fill(0);

      for (let i = 0; i < nums.length; i++) {
        for (let j = number; j >= nums[i]; j--) {
          dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
          if (dp[j] === number) {
            return true;
          }
        }
      }
      return false;
    };
    ```

11. 有效的回文

    ```js
    /**
     * @param {string} s
     * @return {boolean}
     */
    var isPalindrome = function (s) {
      let str = s.toLowerCase();
      let res = [];
      for (let i = 0; i < str.length; i++) {
        if (str.charCodeAt(i) >= 97 && str.charCodeAt(i) <= 122)
          res.push(str[i]);
        if (str.charCodeAt(i) >= 48 && str.charCodeAt(i) <= 57)
          res.push(str[i]);
      }
      let resL = res.join("");
      let resR = res.reverse().join("");
      if (resL === resR) return true;
      return false;
    };
    ```

12. 山峰数组的顶部

    ```js
    /**
     * @param {number[]} arr
     * @return {number}
     */
    var peakIndexInMountainArray = function (arr) {
      let left = 1,
        right = arr.length - 2;
      while (left < right) {
        let mid = Math.floor((left + left) / 2);
        if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1]) {
          return mid;
        } else if (arr[mid - 1] < arr[mid]) {
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      return left;
    };
    ```

13. 有效的变位词

    ```js
    /**
     * @param {string} s
     * @param {string} t
     * @return {boolean}
     */
    var isAnagram = function (s, t) {
      let len1 = s.length,
        len2 = t.length;
      if (len1 !== len2 || s === t) return false;

      let map1 = new Map(),
        map2 = new Map();
      for (let i = 0; i < s.length; i++) {
        map1.set(s[i], map1.has(s[i]) ? map1.get(s[i]) + 1 : 1);
      }
      for (let i = 0; i < t.length; i++) {
        map2.set(t[i], map2.has(t[i]) ? map2.get(t[i]) + 1 : 1);
      }
      for (let [key, value] of map1) {
        if (!map2.has(key) || map2.get(key) !== value) {
          return false;
        }
      }
      return true;
    };
    ```

## 中等

1. 只出现一次的数字(其余元素均出现两次)
   用异或
   https://leetcode-cn.com/problems/single-number/solution/hua-jie-suan-fa-136-zhi-chu-xian-yi-ci-de-shu-zi-b/

   https://leetcode-cn.com/problems/single-number-ii/solution/ti-yi-lei-jie-wei-yun-suan-yi-wen-dai-ni-50dc/

   ```js
   var singleNumber = function (nums) {
     let res = 0;
     for (let num of nums) {
       res ^= num;
     }
     return res;
   };
   ```

2. 只出现一次的数字(两个元素出现一次，其余均出现两次)

   ```js
   /**
    * @param {number[]} nums
    * @return {number[]}
    */
   var singleNumbers = function (nums) {
     let res1 = 0,
       res2 = 0;
     let diff = 0,
       bit = 1;
     // 异或运算， 目的是找到两个落单数值，便于后面分类
     for (let num of nums) {
       diff ^= num;
     }
     // 左移运算，找到二者某一位的不同，将这1定位分类依据，分开落单数值
     while ((diff & bit) === 0) {
       bit <<= 1;
     }
     for (let num of nums) {
       if (num & bit) {
         res1 ^= num;
       } else {
         res2 ^= num;
       }
     }
     return [res1, res2];
   };
   ```

3. 只出现一次的数字(其余元素均出现三次)
   将所有 nums[i]对应的二进制数的对应位求和，将每一对应位的和值与 3 进行取模运算，得到的余数就是答案的对应二进制位的数值。

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var singleNumber = function (nums) {
     let res = 0;
     for (let i = 0; i < 32; i++) {
       let sum = 0;
       for (let num of nums) {
         sum += (num >> i) & 1;
       }
       if (sum % 3 === 1) {
         res |= 1 << i;
       }
     }
     return res;
   };
   ```

4. 单词长度的最大乘积
   https://leetcode-cn.com/problems/aseY1I/

   ```js
   /**
    * @param {string[]} words
    * @return {number}
    */
   var maxProduct = function (words) {
     let res = 0;
     var isSame = function (a, b) {
       for (let i = 0; i < a.length; i++) {
         if (b.indexOf(a[i]) !== -1) {
           return false;
         }
       }
       return true;
     };
     for (let i = 0; i < words.length - 1; i++) {
       for (let j = i + 1; j < words.length; j++) {
         if (isSame(words[i], words[j])) {
           let sum = words[i].length * words[j].length;
           if (res < sum) {
             res = sum;
           }
         }
       }
     }
     return res;
   };
   ```

   ```js
   /**
    * @param {string[]} words
    * @return {number}
    */
   var maxProduct = function (words) {
     let res = 0;
     let mask = new Array(words.length);

     for (let i = 0; i < words.length; i++) {
       let bitMask = 0;
       for (let c of words[i]) {
         bitMask |= 1 << (c.charCodeAt() - "a".charCodeAt());
       }
       mask[i] = bitMask;
     }

     for (let i = 0; i < words.length; i++) {
       for (let j = i + 1; j < words.length; j++) {
         // ===优先 所以一定要加()
         if ((mask[i] & mask[j]) === 0) {
           res = Math.max(res, words[i].length * words[j].length);
         }
       }
     }
     return res;
   };
   ```

5. 和大于等于 target 的最短子数组

   ```js
   /**
    * @param {number} target
    * @param {number[]} nums
    * @return {number}
    */
   var minSubArrayLen = function (target, nums) {
     let left = 0;
     let sum = 0,
       res = nums.length + 1;
     for (let right = 0; right < nums.length; right++) {
       sum += nums[right];

       while (sum >= target && left <= right) {
         res = Math.min(res, right - left + 1);

         sum -= nums[left];
         left++;
       }
     }
     return res === nums.length + 1 ? 0 : res;
   };
   ```

6. 乘积小于 k 的子数组

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var numSubarrayProductLessThanK = function (nums, k) {
     let left = 0;
     let res = 0,
       sum = 1;
     for (let right = 0; right < nums.length; right++) {
       sum *= nums[right];

       while (sum >= k && left <= right) {
         sum /= nums[left];
         left++;
       }
       res += right >= left ? right - left + 1 : 0;
     }
     return res;
   };
   ```

7. 和为 k 的子数组
   思路: 使用前缀和
   https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&idx=1&sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var subarraySum = function (nums, k) {
     let res = 0,
       sum = 0;
     let map = new Map();
     map.set(0, 1);

     for (let i = 0; i < nums.length; i++) {
       sum += nums[i];
       res += map.get(sum - k) || 0;
       map.set(sum, (map.get(sum) || 0) + 1);
     }
     return res;
   };
   ```

8. 0 和 1 个数相同的子数组
   思路: 使用前缀和

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findMaxLength = function (nums) {
     const n = nums.length;
     const map = new Map();
     map.set(0, -1);
     // 前缀和
     let pre = 0;
     let res = 0;
     for (let i = 0; i < n; i++) {
       pre += nums[i] == 0 ? -1 : 1;
       // 如果存在的话，则将当前索引和之前存入的索引值相减  取题目要求的最大值
       if (map.has(pre)) {
         res = Math.max(res, i - map.get(pre));
       } else {
         // 记录前缀和索引
         map.set(pre, i);
       }
     }
     return res;
   };
   ```

9. 二维子矩阵的和

10. 字符串中的变位词

11. 字符串中的所有变位词

12. 不含重复字符的最长子字符串

13. 回文子字符串的个数

# 面试题

```js
//翻转单词顺序
var reverseWords = function (s) {
  //将两个单词多余的空格减少到一个
  s = s.replace(/ +/g, " ");
  return s.split(" ").reverse().join(" ").trim();
};
```
