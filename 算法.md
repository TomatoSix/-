https://github.com/sl1673495/leetcode-javascript

代码随想录
https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC.html

# 排序

https://juejin.cn/post/6856546833025237006#heading-9

## 分类

- 按排序依据的原则
  插入排序： 直接插入排序、希尔排序
  交换排序： 冒泡排序、快速排序
  选择排序: 直接选择排序、堆排序
  归并排序： 2-录归并排序
  基数排序

- 根据排序的稳定性：关键字相同的记录在排序过程中是否保持前后次序不变
  不变则为稳定排序，变化则为不稳定排序

稳定排序： 直接插入排序、冒泡排序、归并排序、计数排序
不稳定排序：希尔排序、直接选择排序、堆排序、快速排序

- 时间复杂度

1.  冒泡排序-稳定 O(n²)

    ```javascript
    let bubbleSort = function (arr, flag = 0) {
      let len = arr.length;

      // 最外层for循环表示循环次数，需循环len - 1次
      for (let i = 0; i < len - 1; i++) {
        for (let j = 0; j < len - 1 - i; j++) {
          //比较相邻两者之间的关系大小
          if (arr[j] > arr[j + 1]) {
            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
          }
        }
      }
      return flag ? arr.reverse() : arr;
    };
    let arr = [2, 10, 8, 3, 0, 5];
    console.log(bubbleSort(arr, 1)); //flag 0-正序 1-倒序
    ```

2.  快速排序- 不稳定 O(nlog2n)
    基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

    1. 方法一

       ```javascript
       let quickSort = function (arr) {
         // 递归出口就是数组长度为1
         if (arr.length <= 1) return arr;
         // 获取中间值的索引，使用Math.floor向下取整
         let index = Math.floor(arr.length / 2);
         // 使用splice截取中间值
         let pivot = arr.splice(index, 1)[0],
           left = [],
           right = [];
         for (let i = 0; i < arr.length; i++) {
           // 如果中间值更大，则将arr[i] push左边数组
           if (pivot > arr[i]) {
             left.push(arr[i]);
           } else {
             // 否则，将arr[i] push右边数组
             right.push(arr[i]);
           }
         }
         return quickSort(left).concat([pivot], quickSort(right));
       };
       ```

    2. 方法二

       ```javascript
       function quickSort(array) {
         if (array.length < 2) return array;
         let pivot = array[array.length - 1];
         let left = array.filter(
           (item, index) => item <= pivot && index !== array.length - 1
         );
         let right = array.filter((item) => item > pivot);
         return [...quickSort(left), pivot, ...quickSort(right)];
       }
       ```

3.  直接插入排序-稳定 O(n²)
    基本原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

    ```javascript
    let insertSort = function (arr) {
      // 取数组长度
      let len = arr.length;

      for (let i = 1; i < len; i++) {
        // cur 表示当前要插入比较的元素
        let curValue = arr[i];
        let j = i - 1;
        // 若前面的数字比当前值cur大，则前面的数字向后移动一位，继续向前一位与当前值比较
        // preIndex >= 0 是为了保证第一个元素认为被排序
        while (j >= 0 && curValue < arr[j]) {
          arr[j + 1] = arr[j];
          j--;
        }
        // 如果小，则放入当前数字的后面
        arr[j + 1] = curValue;
      }
      return arr;
    };
    ```

4.  归并排序-稳定 O(nlog2n)
    https://juejin.cn/post/6844903937242300430
    归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。

    1. 将序列中带排序数字分为若干组，每个数字分为一组
    2. 将若干个组两两合并，保证合并后的组是有序的
    3. 重复第二步操作直到只剩下一组，排序完成

    ```js
    function merge(left, right) {
      let result = [];
      let i = 0,
        j = 0;
      while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
          // 一定不要忘记i++
          result.push(left[i++]);
        } else {
          result.push(right[j++]);
        }
      }
      if (i < left.length) {
        result.push(...left.slice(i));
      } else {
        result.push(...right.slice(j));
      }
      return result;
    }

    function mergeSort(array) {
      if (array.length < 2) {
        return array;
      }
      let m = Math.floor(array.length / 2);
      let left = mergeSort(array.slice(0, m));
      let right = mergeSort(array.slice(m));
      return merge(left, right);
    }

    let arr = [1, 8, 9, 5, 4, 3, 6, 2];
    console.log(mergeSort(arr));
    ```

5.  计数排序
    所谓“计数”，就是数一数，统计每个元素重复出现的次数。

    ```js
    function countingSort(arr) {
      let min = Infinity;
      for (let v of arr) {
        if (v < min) {
          min = v;
        }
      }
      let counts = [];
      for (let v of arr) {
        counts[v - min] = (counts[v - min] || 0) + 1;
      }
      let index = 0;
      for (let i = 0; i < counts.length; i++) {
        let count = counts[i];
        while (count > 0) {
          arr[index] = i + min;
          count--;
          index++;
        }
      }
      return arr;
    }
    ```

6.  希尔排序
    通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。

    ```js
    function shellSort(arr) {
      let len = arr.length;
      // 初始步数
      let gap = parseInt(len / 2);
      // 逐渐缩小步数
      while (gap) {
        // 从第gap个元素开始遍历
        for (let i = gap; i < len; i++) {
          // 逐步其和前面其他的组成员进行比较和交换
          for (let j = i - gap; j >= 0; j -= gap) {
            if (arr[j] > arr[j + gap]) {
              [arr[j], arr[j + gap]] = [arr[j + gap], arr[j]];
            } else {
              break;
            }
          }
        }
        gap = parseInt(gap / 2);
      }
      return arr;
    }
    ```

7.  直接选择排序 - 不稳定 - O(n²)

    ```javascript
    // 基本原理：每一次从待排序的数组元素中选择最大的一个元素作为首元素，直到排完为止
    let selectSort = function (arr) {
      let len = arr.length,
        curMinIndex = 0;
      // 一共需要排序len-1次, 即循环次数
      for (let i = 0; i < len - 1; i++) {
        curMinIndex = i;
        // 取出后续数字中最小数字的索引
        for (let j = i + 1; j < len; j++) {
          if (arr[j] < arr[curMinIndex]) {
            curMinIndex = j;
          }
        }
        // 每一趟保证第i位为最小值, 此时的temp为后续最小数字的索引
        [arr[i], arr[curMinIndex]] = [arr[curMinIndex], arr[i]];
      }
      return arr;
    };
    let arr = [2, 9, 6, 7, 4, 3, 1, 7, 0, -1, -2];
    console.log(selectSort(arr));
    ```

8.  堆排序
    https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/xie-gei-qian-duan-tong-xue-de-ti-jie-yi-kt5p2/

    ```javascript
    /**
     * @param {number[]} nums
     * @param {number} k
     * @return {number}
     */
    // 整个流程就是上浮下沉
    var findKthLargest = function (nums, k) {
      let heapSize = nums.length;
      buildMaxHeap(nums, heapSize); // 构建好了一个大顶堆
      // 进行下沉 大顶堆是最大元素下沉到末尾
      for (let i = nums.length - 1; i >= nums.length - k + 1; i--) {
        swap(nums, 0, i);
        --heapSize; // 下沉后的元素不参与到大顶堆的调整
        // 重新调整大顶堆
        maxHeapify(nums, 0, heapSize);
      }
      return nums[0];
      // 自下而上构建一颗大顶堆
      function buildMaxHeap(nums, heapSize) {
        for (let i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {
          maxHeapify(nums, i, heapSize);
        }
      }
      // 从左向右，自上而下的调整节点
      function maxHeapify(nums, i, heapSize) {
        let l = i * 2 + 1;
        let r = i * 2 + 2;
        let largest = i;
        if (l < heapSize && nums[l] > nums[largest]) {
          largest = l;
        }
        if (r < heapSize && nums[r] > nums[largest]) {
          largest = r;
        }
        if (largest !== i) {
          swap(nums, i, largest); // 进行节点调整
          // 继续调整下面的非叶子节点
          maxHeapify(nums, largest, heapSize);
        }
      }
      function swap(a, i, j) {
        let temp = a[i];
        a[i] = a[j];
        a[j] = temp;
      }
    };
    ```

# 链表

1.  从尾到头打印链表

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @return {number[]}
     */
    var reversePrint = function (head) {
      let res = [];
      while (head) {
        res.unshift(head.val);
        head = head.next;
      }
      return res;
    };
    ```

2.  反转链表

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @return {ListNode}
     */
    var reverseList = function (head) {
      // prev必须要声明为null
      let prev = null;
      let curr = head;
      //如果curr为null,则其已经成为最后一个节点，链表已经反转完成
      while (curr) {
        //先用next保存下一个节点
        let next = curr.next;
        //将curr指向prev前面一个节点
        curr.next = prev;
        //prev节点后移
        //下面两行不能交换
        prev = curr;
        //curr节点也后移
        curr = next;
      }
      return prev;
    };
    ```

3.  合并两个排序的链表

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} l1
     * @param {ListNode} l2
     * @return {ListNode}
     */
    var mergeTwoLists = function (l1, l2) {
      if (!l1) {
        return l2;
      }
      if (!l2) {
        return l1;
      }
      let head;
      if (l1.val < l2.val) {
        head = l1;
        head.next = mergeTwoLists(l1.next, l2);
      } else {
        head = l2;
        head.next = mergeTwoLists(l1, l2.next);
      }
      return head;
    };
    ```

4.  删除链表中的节点

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} val
     * @return {ListNode}
     */

    var deleteNode = function (head, val) {
      if (head.val === val) {
        return head.next;
      }
      head.next = deleteNode(head.next, val);
      return head;
    };

    // 方法二
    var removeElements = function (head, val) {
      // 设置虚拟节点
      let dummyHead = new ListNode(0, head);
      let temp = dummyHead;
      while (temp.next) {
        if (temp.next.val === val) {
          // 如果节点值相等，temp节点就指向temp.next.next
          temp.next = temp.next.next;
        } else {
          // 否则temp就一项下一节点
          temp = temp.next;
        }
      }
      // 返回头结点
      return dummyHead.next;
    };
    ```

5.  链表中倒数第 k 个节点

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} k
     * @return {ListNode}
     */
    var getKthFromEnd = function (head, k) {
      let total = 0,
        node = head;
      while (node) {
        total++;
        node = node.next;
      }
      let index = total - k;
      while (index) {
        head = head.next;
        index--;
      }
      return head;
    };
    ```

6.  两个链表的第一个公共节点 | 两个链表的第一个重合节点

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */

    /**
     * @param {ListNode} headA
     * @param {ListNode} headB
     * @return {ListNode}
     */
    var getIntersectionNode = function (headA, headB) {
      var getListLen = function (head) {
        let len = 0,
          cur = head; // 不能直接使用head，否则head会被修改
        while (cur) {
          len++;
          cur = cur.next;
        }
        return len;
      };

      let curA = headA,
        curB = headB,
        lenA = getListLen(headA),
        lenB = getListLen(headB);
      if (lenA < lenB) {
        [curA, curB] = [curB, curA]; //这里的分号一定要加
        [lenA, lenB] = [lenB, lenA];
      }
      let i = lenA - lenB;
      while (i-- > 0) {
        curA = curA.next;
      }
      while (curA && curA !== curB) {
        curA = curA.next;
        curB = curB.next;
      }
      return curA;
    };
    ```

7.  复杂链表的复制(offer1 中)

    ```js
    /**
     * // Definition for a Node.
     * function Node(val, next, random) {
     *    this.val = val;
     *    this.next = next;
     *    this.random = random;
     * };
     */

    /**
     * @param {Node} head
     * @return {Node}
     */
    var copyRandomList = function (head) {
      if (!head) return null;
      let m = new Map();
      let node = head;
      while (node) {
        m.set(node, new Node(node.val));
        node = node.next;
      }
      node = head;
      while (node) {
        m.get(node).next = node.next ? m.get(node.next) : null;
        m.get(node).random = node.random ? m.get(node.random) : null;
        node = node.next;
      }
      return m.get(head);
    };
    ```

8.  两两交换链表中的节点

9.  设计链表

10. 删除链表的倒数第 N 个节点(中)-需要设置虚拟节点

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} n
     * @return {ListNode}
     */
    var removeNthFromEnd = function (head, n) {
      let dummyNode = new ListNode(0, head);
      let fast = dummyNode,
        slow = dummyNode;
      while (n--) fast = fast.next;
      while (fast.next !== null) {
        fast = fast.next;
        slow = slow.next;
      }
      slow.next = slow.next.next;
      return dummyNode.next;
    };
    ```

11. 删除排序链表中的重复元素

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} head
     * @return {ListNode}
     */
    var deleteDuplicates = function (head) {
      if (!head) return head; //不能返回[]

      let pre = head;
      while (pre.next) {
        if (pre.val === pre.next.val) {
          pre.next = pre.next.next; // 最后可以指向Null
        } else {
          pre = pre.next;
        }
      }
      return head;
    };
    ```

12. 环形链表

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */

    /**
     * @param {ListNode} head
     * @return {boolean}
     */
    var hasCycle = function (head) {
      const map = new Map();
      while (head) {
        if (map.has(head)) return true;
        map.set(head, true);
        head = head.next;
      }
      return false;
    };
    ```

    ```js
    var hasCycle = function (head) {
      //设置快慢指针
      let slow = head;
      let fast = head;
      //如果没有环，则快指针会抵达终点，否则继续移动双指针
      while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        //快慢指针相遇，说明含有环
        if (slow == fast) {
          return true;
        }
      }

      return false;
    };
    ```

13. 链表中环的入口节点(中)

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */

    /**
     * @param {ListNode} head
     * @return {ListNode}
     */
    var detectCycle = function (head) {
      // 快慢指针初始化指向 head
      let slow = head;
      let fast = head;
      // 快指针走到末尾时停止
      while (fast && fast.next) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
        // 快慢指针相遇，说明含有环
        if (slow == fast) {
          // 任一一节点指向头节点
          fast = head;
          // 同步向前进
          while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
          }
          // 返回入口节点
          return fast;
        }
      }
      // 不包含环
      return null;
    };
    ```

14. 回文链表

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} head
     * @return {boolean}
     */
    var isPalindrome = function (head) {
      let res = [];
      let node = head;
      while (node) {
        res.push(node.val);
        node = node.next;
      }
      for (let i = 0, j = res.length - 1; i < j; i++, j--) {
        if (res[i] !== res[j]) {
          return false;
        }
      }
      return true;
    };
    ```

15. 两数相加(中)

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} l1
     * @param {ListNode} l2
     * @return {ListNode}
     */
    var addTwoNumbers = function (l1, l2) {
      let dummy = new ListNode();
      let cur = dummy;
      let carry = 0;
      while (l1 || l2) {
        const x = l1 ? l1.val : 0;
        const y = l2 ? l2.val : 0;

        let sum = x + y + carry;
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        carry = Math.floor(sum / 10);

        if (l1) l1 = l1.next;
        if (l2) l2 = l2.next;
      }
      if (carry) cur.next = new ListNode(carry);
      return dummy.next;
    };
    ```

16. 链表中的两数相加(中)

    ```js
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    /**
     * @param {ListNode} l1
     * @param {ListNode} l2
     * @return {ListNode}
     */
    var addTwoNumbers = function (l1, l2) {
      var reverseNode = function (head) {
        let pre = null,
          cur = head;
        while (cur) {
          let next = cur.next;
          cur.next = pre;
          pre = cur;
          cur = next;
        }
        return pre;
      };
      l1 = reverseNode(l1);
      l2 = reverseNode(l2);
      let dummy = new ListNode();
      let cur = dummy;
      let carry = 0;
      while (l1 || l2) {
        const x = l1 ? l1.val : 0;
        const y = l2 ? l2.val : 0;

        let sum = x + y + carry;
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        carry = Math.floor(sum / 10);

        // 不要忘记
        if (l1) l1 = l1.next;
        if (l2) l2 = l2.next;
      }
      if (carry) cur.next = new ListNode(carry);
      return reverseNode(dummy.next);
    };
    ```

17. 链表排序(中)

    ```js
    var sortList = function (head) {
      if (!head || !head.next) return head;
      let slow = head,
        fast = head;
      let preSlow = null;
      // 寻找中间节点
      while (fast && fast.next) {
        preSlow = slow;
        slow = slow.next;
        fast = fast.next.next;
      }
      // 为什么要这一步?
      preSlow.next = null;
      const l = sortList(head);
      const r = sortList(slow);
      return merge(l, r);
    };

    function merge(l1, l2) {
      const dummy = new ListNode(0);
      let cur = dummy;
      while (l1 && l2) {
        if (l1.val < l2.val) {
          cur.next = l1;
          l1 = l1.next;
        } else {
          cur.next = l2;
          l2 = l2.next;
        }
        cur = cur.next;
      }
      if (l1) cur.next = l1;
      if (l2) cur.next = l2;
      return dummy.next;
    }
    ```

18. 重排链表(中)

19. 展平多级双向链表(中)

20. 排序的循环链表(中)

# 二叉树

## 二叉树的遍历

DLR--前序遍历-中左右（根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面 ）

LDR--中序遍历-左中右（根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面）

LRD--后序遍历-左右中（根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面）

1. 二叉树的先序遍历

   1. 非递归实现

      ```javascript
      /**
       * Definition for a binary tree node.
       * function TreeNode(val, left, right) {
       *     this.val = (val===undefined ? 0 : val)
       *     this.left = (left===undefined ? null : left)
       *     this.right = (right===undefined ? null : right)
       * }
       */
      /**
       * @param {TreeNode} root
       * @return {number[]}
       */
      var preorderTraversal = function (root) {
        let res = [];
        let stack = [];
        if (root) stack.push(root);
        while (stack.length > 0) {
          let node = stack.pop();
          res.push(node.val);
          if (node.right) stack.push(node.right);
          if (node.left) stack.push(node.left);
        }
        return res;
      };
      ```

   2. 递归实现

      ```javascript
      var preorderTraversal = function (root, array = []) {
        if (root) {
          array.push(root.val);
          preorderTraversal(root.left, array);
          preorderTraversal(root.right, array);
        }
        return array;
      };

      var preorderTraversal = function (root) {
        let res = [];

        var preorder = function (root) {
          if (!root) return;
          res.push(root.val);
          preorder(root.left);
          preorder(root.right);
        };
        preorder(root);
        return res;
      };
      ```

2. 二叉树的中序遍历

   1. 非递归实现

      ```javascript
      /**
       * Definition for a binary tree node.
       * function TreeNode(val, left, right) {
       *     this.val = (val===undefined ? 0 : val)
       *     this.left = (left===undefined ? null : left)
       *     this.right = (right===undefined ? null : right)
       * }
       */
      /**
       * @param {TreeNode} root
       * @return {number[]}
       */
      var inorderTraversal = function (root) {
        let res = [];
        let stack = [];
        let cur = root;
        while (stack.length || cur) {
          if (cur) {
            stack.push(cur);
            cur = cur.left;
          } else {
            cur = stack.pop();
            res.push(cur.val);
            cur = cur.right;
          }
        }
        return res;
      };
      ```

   2. 递归实现

      ```javascript
      /**
       * @param {TreeNode} root
       * @return {number[]}
       */
      var inorderTraversal = function (root) {
        let res = [];
        var inorder = function (root) {
          if (root) {
            inorder(root.left);
            res.push(root.val);
            inorder(root.right);
          }
        };
        inorder(root);
        return res;
      };
      ```

3. 二叉树的后序遍历

   1. 非递归遍历

      ```js
      const inorderTraversal = (root) => {
        if (!root) return [];
        const res = [];
        const stack = [];
        while (root || stack.length) {
          while (root) {
            stack.push(root);
            root = root.left;
          }
          root = stack.pop();
          res.push(root.val);
          root = root.right;
        }
        return res;
      };

      // 方法二
      var postorderTraversal = function (root) {
        let res = [];
        let stack = [];
        if (!root) return res;
        stack.push(root);
        let cur = null;
        while (stack.length) {
          cur = stack.pop();
          res.push(cur.val);
          if (cur.left) stack.push(cur.left);
          if (cur.right) stack.push(cur.right);
        }
        return res.reverse();
      };
      ```

4. 二叉树的层序遍历

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {number[][]}
    */
   var levelOrder = function (root) {
     const res = [];
     if (!root) return res;

     let seq = [];
     seq.push(root);

     while (seq.length !== 0) {
       let len = seq.length;
       res.push([]);

       for (let i = 1; i <= len; i++) {
         let node = seq.shift();
         res[res.length - 1].push(node.val);
         if (node.left) seq.push(node.left);
         if (node.right) seq.push(node.right);
       }
     }

     return res;
   };

   // 二叉树的锯齿形层序遍历
   var zigzagLevelOrder = function (root) {
     if (!root) return [];
     let res = [];
     let seq = [];
     seq.push(root);
     let flag = true;
     while (seq.length) {
       let len = seq.length;
       res.push([]);
       for (let i = 1; i <= len; i++) {
         let node = seq.shift();
         if (flag) {
           res[res.length - 1].push(node.val);
         } else {
           res[res.length - 1].unshift(node.val);
         }
         if (node.left) seq.push(node.left);
         if (node.right) seq.push(node.right);
       }
       flag = !flag;
     }
     return res;
   };
   ```

5. N 叉树

   1. N 叉树的层序遍历

      ```js
      var levelOrder = function (root) {
        if (!root) return [];
        let res = [];
        let seq = [];
        seq.push(root);
        while (seq.length) {
          let len = seq.length;
          let curArr = [];
          while (len--) {
            let node = seq.shift();
            curArr.push(node.val);
            for (let item of node.children) {
              if (item) seq.push(item);
            }
          }
          res.push(curArr);
        }
        return res;
      };
      ```

   2. N 叉树的前序遍历

      ```js
      // 递归
      /**
       * // Definition for a Node.
       * function Node(val, children) {
       *    this.val = val;
       *    this.children = children;
       * };
       */

      /**
       * @param {Node|null} root
       * @return {number[]}
       */
      var preorder = function (root) {
        let res = [];
        var preCheck = function (root) {
          if (root) {
            res.push(root.val);
            for (let item of root.children) {
              preCheck(item);
            }
          }
        };
        preCheck(root);
        return res;
      };
      ```

   3. N 叉树的后序遍历

      ```js
      // 递归
      var postorder = function (root) {
        let res = [];
        var postCheck = function (node) {
          if (node) {
            for (let i = 0; i < node.children.length; i++) {
              postCheck(node.children[i]);
            }
            res.push(node.val);
          }
        };
        postCheck(root);
        return res;
      };
      ```

   4. N 叉树的最大深度

      ```js
      /**
       * // Definition for a Node.
       * function Node(val,children) {
       *    this.val = val;
       *    this.children = children;
       * };
       */

      /**
       * @param {Node|null} root
       * @return {number}
       */
      var maxDepth = function (root) {
        if (!root) return 0;
        let maxRes = 0;
        for (let node of root.children) {
          let depth = maxDepth(node);
          maxRes = Math.max(depth, maxRes);
        }
        return 1 + maxRes;
      };
      ```

## 其它

https://leetcode-cn.com/problems/path-sum-iii/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-smch/

1. 前序和中序确定一棵二叉树

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {number[]} preorder
    * @param {number[]} inorder
    * @return {TreeNode}
    */
   var buildTree = function (preorder, inorder) {
     if (!preorder.length) return null;

     let root = new TreeNode(preorder[0]);

     let index = inorder.findIndex((item) => item === root.val);

     root.left = buildTree(
       preorder.slice(1, index + 1),
       inorder.slice(0, index)
     );
     root.right = buildTree(
       preorder.slice(index + 1, preorder.length),
       inorder.slice(index + 1, preorder.length)
     );
     return root;
   };
   ```

2. 后序和中序确定一棵二叉树

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {number[]} inorder
    * @param {number[]} postorder
    * @return {TreeNode}
    */
   var buildTree = function (inorder, postorder) {
     if (!postorder.length) return null;

     let root = new TreeNode(postorder[postorder.length - 1]);

     let index = inorder.findIndex((item) => item === root.val);

     root.left = buildTree(inorder.slice(0, index), postorder.slice(0, index));
     root.right = buildTree(
       inorder.slice(index + 1, index.length),
       postorder.slice(index, postorder.length - 1)
     );
     return root;
   };
   ```

3. 路径总和 I

   https://leetcode-cn.com/problems/path-sum-ii/

   ```js
   //路径总和I
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} targetSum
    * @return {boolean}
    */
   var hasPathSum = function (root, targetSum) {
     if (!root) return false;
     if (!root.left && !root.right) {
       return targetSum - root.val === 0;
     }
     return (
       hasPathSum(root.left, targetSum - root.val) ||
       hasPathSum(root.right, targetSum - root.val)
     );
   };
   ```

4. 二叉树中和为某一值的路径 | 路径总和 II(中)

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} target
    * @return {number[][]}
    */
   //  方法一
   var pathSum = function (root, target) {
     if (!root) return [];
     var getPath = function (sum, path, node) {
       if (node.val === sum && !node.left && !node.right) {
         res.push(path);
       }
       path.push(node.val);
       if (node.left) getPath(sum - node.val, path.slice(), node.left);
       if (node.right) getPath(sum - node.val, path.slice(), node.right);
     };
     let res = [];
     getPath(target, [], root);
     return res;
   };

   // 方法二
   var pathSum = function (root, target) {
     // 一定要加，解决root为[]的时候
     if (!root) return [];
     let res = [];
     var getPath = function (node, sum, path) {
       if (sum + node.val === target && !node.left && !node.right) {
         // 必须这样写， 不能写path.push(node.val), res.push([...path])
         res.push([...path, node.val]);
         return;
       }
       path.push(node.val);
       if (node.left) getPath(node.left, sum + node.val, path);
       if (node.right) getPath(node.right, sum + node.val, path);
       // path.pop()一定要加
       path.pop();
     };
     getPath(root, 0, []);
     return res;
   };
   ```

5. 路径总和 III | 向下的路径节点之和(中)

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} targetSum
    * @return {number}
    */
   var pathSum = function (root, targetSum) {
     let res = 0,
       map = new Map();
     const dfs = function (node, preSum) {
       if (!node) return 0;
       map.set(preSum, (map.get(preSum) || 0) + 1);
       let target = preSum + node.val;
       res += map.get(target - targetSum) || 0;
       dfs(node.left, target);
       dfs(node.right, target);
       // 回溯撤销
       map.set(preSum, map.get(preSum) - 1);
     };
     dfs(root, 0);
     return res;
   };
   ```

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} targetSum
    * @return {number}
    */
   var pathSum = function (root, targetSum) {
     if (!root) return 0;
     // 前缀和 + 回溯 + map
     let res = 0,
       map = new Map();
     var getPath = function (node, preSum) {
       // if (!node) return 0
       map.set(preSum, (map.get(preSum) || 0) + 1);
       let sum = preSum + node.val;
       res += map.get(sum - targetSum) || 0;
       if (node.left) getPath(node.left, sum);
       if (node.right) getPath(node.right, sum);
       map.set(preSum, map.get(preSum) - 1);
     };
     getPath(root, 0);
     return res;
   };
   ```

6. 二叉树的所有路径

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {string[]}
    */
   var binaryTreePaths = function (root) {
     if (!root) return [];
     let res = [];

     var getPath = function (node, curPath) {
       // 确定终止条件，到叶子结点就终止
       if (!node.left && !node.right) {
         curPath += node.val;
         res.push(curPath);
         return;
       }

       curPath += node.val + "->";

       if (node.left) getPath(node.left, curPath);
       if (node.right) getPath(node.right, curPath);
       // 不需要pop，因为每条路径都正确
     };
     getPath(root, "");
     return res;
   };
   ```

7. 从根节点到叶节点的路径数字之和

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {number}
    */
   var sumNumbers = function (root) {
     var dfs = function (node, preSum) {
       if (!node) return 0;
       let sum = preSum * 10 + node.val;
       if (!node.left && !node.right) {
         return sum;
       } else {
         return dfs(node.left, sum) + dfs(node.right, sum);
       }
     };
     return dfs(root, 0);
   };
   ```

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {number}
    */
   var sumNumbers = function (root) {
     let res = 0;

     var getPath = function (node, path) {
       if (!node.left && !node.right) {
         path += node.val;
         res += +path;
         return;
       }
       if (node.left) getPath(node.left, path + node.val);
       if (node.right) getPath(node.right, path + node.val);
     };
     getPath(root, "");
     return res;
   };
   ```

8. 二叉树的最小深度

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {number}
    */
   var minDepth = function (root) {
     if (!root) return 0;
     if (!root.left && !root.right) return 1;
     if (!root.left) return 1 + minDepth(root.right);
     if (!root.right) return 1 + minDepth(root.left);
     return 1 + Math.min(minDepth(root.left), minDepth(root.right));
   };
   ```

9. 二叉树的最大深度

   ```js
   // 最大深度
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {number}
    */
   var maxDepth = function (root) {
     var getDepth = function (root) {
       if (!root) return 0;
       return 1 + Math.max(getDepth(root.left), getDepth(root.right));
     };
     return getDepth(root);
     // if (!root) return 0;
     // return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
   };
   ```

10. 最大二叉树

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {number[]} nums
     * @return {TreeNode}
     */
    var constructMaximumBinaryTree = function (nums) {
      if (nums.length == 0) return null;
      var big = Math.max(...nums);
      var root = new TreeNode(big);
      root.left = constructMaximumBinaryTree(nums.slice(0, nums.indexOf(big)));
      root.right = constructMaximumBinaryTree(
        nums.slice(nums.indexOf(big) + 1)
      );
      return root;
    };
    ```

11. 对称二叉树

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {boolean}
     */
    var isSymmetric = function (root) {
      var check = function (left, right) {
        if (!left && !right) return true;
        if (!left || !right) return false;
        return (
          left.val === right.val &&
          check(left.left, right.right) &&
          check(left.right, right.left)
        );
      };
      return check(root, root);
    };
    ```

12. 树的子结构(中等)

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} A
     * @param {TreeNode} B
     * @return {boolean}
     */
    var isSubStructure = function (A, B) {
      // 约定空树不是任意一个树的子结构
      if (!A || !B) return false;
      return (
        isSameTree(A, B) ||
        isSubStructure(A.left, B) ||
        isSubStructure(A.right, B)
      );
    };
    // 判断有没有节点重合
    var isSameTree = function (A, B) {
      // 下面两行顺序不能换
      if (!B) return true;
      if (!A) return false;
      if (A.val !== B.val) return false;
      return isSameTree(A.left, B.left) && isSameTree(A.right, B.right);
    };
    ```

13. 二叉树的镜像

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {TreeNode}
     */
    var mirrorTree = function (root) {
      var reverseNode = function (node) {
        if (node) {
          [node.left, node.right] = [node.right, node.left];
          reverseNode(node.left);
          reverseNode(node.right);
        }
      };
      reverseNode(root);
      return root;
    };
    ```

14. 合并二叉树

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root1
     * @param {TreeNode} root2
     * @return {TreeNode}
     */
    var mergeTrees = function (root1, root2) {
      var preOrder = function (root1, root2) {
        if (!root1 && !root2) return null;
        if (!root1) return root2;
        if (!root2) return root1;
        root1.val += root2.val;
        root1.left = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);
        return root1;
      };
      return preOrder(root1, root2);
    };
    ```

15. 完全二叉树的节点个数(中)

    层序遍历

16. 左叶子之和

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {number}
     */
    var sumOfLeftLeaves = function (root) {
      if (!root) return null;
      let sum = 0;
      let seq = [];
      seq.push(root);

      while (seq.length) {
        let len = seq.length;
        for (let i = 1; i <= len; i++) {
          let node = seq.shift();
          if (node.left && !node.left.left && !node.left.right) {
            sum += node.left.val;
          }
          if (node.left) seq.push(node.left);
          if (node.right) seq.push(node.right);
        }
      }
      return sum;
    };

    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {number}
     */
    var sumOfLeftLeaves = function (root) {
      let res = 0;
      var getSum = function (root, value) {
        if (!root.left && !root.right && value === 1) {
          res += root.val;
          return;
        }
        if (root.left) getSum(root.left, 1);
        if (root.right) getSum(root.right, 2);
      };
      getSum(root, 2);
      return res;
    };
    ```

17. 找树左下角的值

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {number}
     */
    var findBottomLeftValue = function (root) {
      if (!root) return null;
      let res = 0;
      let seq = [];
      seq.push(root);

      while (seq.length) {
        let len = seq.length;

        for (let i = 1; i <= len; i++) {
          let node = seq.shift();
          if (i === 1) {
            res = node.val;
          }
          if (node.left) seq.push(node.left);
          if (node.right) seq.push(node.right);
        }
      }

      return res;
    };
    ```

18. 翻转二叉树

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {TreeNode}
     */
    var invertTree = function (root) {
      if (!root) return null;
      var invert = function (left, right) {
        let temp = left;
        left = right;
        right = temp;
        root.left = left;
        root.right = right;
      };
      invert(root.left, root.right);
      invertTree(root.left);
      invertTree(root.right);
      return root;
    };
    ```

19. 二叉树的最近公共祖先

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} root
     * @param {TreeNode} p
     * @param {TreeNode} q
     * @return {TreeNode}
     */
    var lowestCommonAncestor = function (root, p, q) {
      if (!root) return null;
      // 如果节点 === p或q, 则找到节点并返回
      if (root === p || root === q) return root;
      // 寻找做子树相同的节点
      let left = lowestCommonAncestor(root.left, p, q);
      // 寻找右子树相同的节点
      let right = lowestCommonAncestor(root.right, p, q);
      // 如果左右各找到一个， 则root为根节点
      if (left && right) {
        return root;
      }
      // 只有左边找到，那么最近公共祖先在左边
      if (left) return left;
      // 只有右边找到，那么最近公共祖先在右边
      if (right) return right;
    };
    ```

20. 二叉树剪枝(中等)- 利用后序遍历

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {TreeNode}
     */
    var pruneTree = function (root) {
      if (root === null) {
        return null;
      }
      root.left = pruneTree(root.left);
      root.right = pruneTree(root.right);
      if (!root.left && !root.right && root.val === 0) {
        return null;
      }
      return root;
    };
    ```

21. 二叉树展开为链表

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {void} Do not return anything, modify root in-place instead.
     */
    var flatten = function (root) {
      let res = [];
      var preorder = function (node) {
        if (node) {
          res.push(node);
          preorder(node.left);
          preorder(node.right);
        }
      };
      preorder(root);

      for (let i = 1; i < res.length; i++) {
        const prev = res[i - 1],
          curr = res[i];
        prev.left = null;
        prev.right = curr;
      }
    };
    ```

## 二叉搜索树

1. 二叉搜索树中的搜索

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} val
    * @return {TreeNode}
    */
   var searchBST = function (root, val) {
     if (!root || root.val === val) return root;
     if (root.val > val) {
       return searchBST(root.left, val);
     }
     if (root.val < val) {
       return searchBST(root.right, val);
     }
     return null;
   };
   ```

2. 验证二叉搜索树

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {boolean}
    */
   //  中序遍历
   var isValidBST = function (root) {
     let arr = [];
     var inorder = function (node) {
       if (node) {
         inorder(node.left);
         arr.push(node.val);
         inorder(node.right);
       }
     };
     inorder(root);
     for (let i = 1; i < arr.length; i++) {
       if (arr[i] <= arr[i - 1]) {
         return false;
       }
     }
     return true;
   };

   // 递归
   var isValidBST = function (root) {
     var isCheck = function (root, min = -Infinity, max = Infinity) {
       if (!root) return true;
       if (root.val <= min || root.val >= max) return false;
       return (
         isCheck(root.left, min, root.val) && isCheck(root.right, root.val, max)
       );
     };
     return isCheck(root);
   };
   ```

3. 二叉搜索树中的众数

   ```js
   var findMode = function (root) {
     let map = new Map();
     var inorder = function (node) {
       if (node) {
         inorder(node.left);
         map.set(node.val, map.has(node.val) ? map.get(node.val) + 1 : 1);
         inorder(node.right);
       }
     };
     inorder(root);

     let maxValue = map.get(root.val);
     let res = [];
     for (let [key, value] of map) {
       if (value === maxValue) {
         res.push(key);
       }
       if (value > maxValue) {
         res = [];
         maxValue = value;
         res.push(key);
       }
     }
     return res;
   };
   ```

4. 二叉搜索树的后序遍历序列

   ```js
   /**
    * @param {number[]} postorder
    * @return {boolean}
    */
   var verifyPostorder = function (postorder) {
     const len = postorder.length;
     if (len < 2) return true;
     let root = postorder[len - 1];
     let i = 0;
     for (; i < len - 1; i++) {
       // 取出右子树的第一个index
       if (postorder[i] > root) break;
     }
     // 右子树上的所有节点大于根节点
     let res = postorder.slice(i, len - 1).every((item) => item > root);
     // 否则递归判断左右子树
     return res
       ? verifyPostorder(postorder.slice(0, i)) &&
           verifyPostorder(postorder.slice(i, len - 1))
       : false;
   };
   ```

5. 二叉搜索树与双向链表

6. 二叉搜索树的第 k 大节点(简单)

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val) {
    *     this.val = val;
    *     this.left = this.right = null;
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} k
    * @return {number}
    */
   var kthLargest = function (root, k) {
     let res = [];
     var inorder = function (node) {
       if (node) {
         inorder(node.left);
         res.push(node.val);
         inorder(node.right);
       }
     };
     inorder(root);
     return res[res.length - k];
   };
   ```

7. 二叉搜索树的最近公共祖先

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val) {
    *     this.val = val;
    *     this.left = this.right = null;
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {TreeNode} p
    * @param {TreeNode} q
    * @return {TreeNode}
    */
   var lowestCommonAncestor = function (root, p, q) {
     if (!root) return null;

     if (root.val > p.val && root.val > q.val) {
       let left = lowestCommonAncestor(root.left, p, q);
       return left;
     }
     if (root.val < p.val && root.val < q.val) {
       let right = lowestCommonAncestor(root.right, p, q);
       return right;
     }
     return root;
   };
   ```

8. 所有大于等于节点的值之和

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @return {TreeNode}
    */
   var convertBST = function (root) {
     // 利用中序遍历
     let sum = 0;
     var dfs = function (node) {
       if (!node) return;
       dfs(node.right);
       sum += node.val;
       node.val = sum;
       dfs(node.left);
     };
     dfs(root);
     return root;
   };
   ```

9. 二叉搜索树中两个节点之和

   ```js
   /**
    * Definition for a binary tree node.
    * function TreeNode(val, left, right) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.left = (left===undefined ? null : left)
    *     this.right = (right===undefined ? null : right)
    * }
    */
   /**
    * @param {TreeNode} root
    * @param {number} k
    * @return {boolean}
    */
   var findTarget = function (root, k) {
     const set = new Set();
     const getRes = function (node) {
       if (!node) return false;
       if (set.has(k - node.val)) return true;
       set.add(node.val);
       return getRes(node.left) || getRes(node.right);
     };
     return getRes(root);
   };
   ```

10. 展平二叉搜索树

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val, left, right) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.left = (left===undefined ? null : left)
     *     this.right = (right===undefined ? null : right)
     * }
     */
    /**
     * @param {TreeNode} root
     * @return {TreeNode}
     */
    var increasingBST = function (root) {
      var inorder = function (node, res) {
        if (node) {
          inorder(node.left, res);
          res.push(node.val);
          inorder(node.right, res);
        }
      };
      let res = [];
      inorder(root, res);

      let dummyNode = new TreeNode(-1);
      let cur = dummyNode;
      for (let value of res) {
        cur.right = new TreeNode(value);
        cur = cur.right;
      }
      return dummyNode.right;
    };
    ```

11. 二叉搜索树中的中序后继

    ```js
    // 利用中序遍历
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} root
     * @param {TreeNode} p
     * @return {TreeNode}
     */
    var inorderSuccessor = function (root, p) {
      let list = [];
      var inorder = function (node) {
        if (node) {
          inorder(node.left);
          list.push(node);
          inorder(node.right);
        }
      };
      inorder(root);
      for (let i = 0; i < list.length; i++) {
        if (p.val < list[i].val) {
          return list[i];
        }
      }
      return null;
    };
    ```

    ```js
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} root
     * @param {TreeNode} p
     * @return {TreeNode}
     */
    var inorderSuccessor = function (root, p) {
      let pre,
        res = null;
      var dfs = function (node) {
        if (!node) return;
        dfs(node.left);
        if (pre === p) res = node;
        pre = node;
        dfs(node.right);
      };
      dfs(root);
      return res;
    };
    ```

12. 二叉搜索树迭代器

## 平衡二叉树

# 数组

```js
//找出数组中重复数字
/**
 * @param {number[]} nums
 * @return {number}
 */
var findRepeatNumber = function (nums) {
  let map = new Map();
  for (let i of nums) {
    if (map.has(i)) return i;
    map.set(i, 1);
  }
  return null;
};

//最大子序和
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function (nums) {
  let pre = 0;
  let maxSum = nums[0];
  nums.forEach((x) => {
    //如果之前的和加上当前元素值还没有当前元素值大，则丢弃
    pre = Math.max(pre + x, x);
    maxSum = Math.max(pre, maxSum);
  });
  return maxSum;
};

//动态规划
var maxSubArray = function (nums) {
  const dp = new Array(nums.length);
  dp[0] = nums[0];
  let result = dp[0];
  for (let i = 1; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);

    if (result < dp[i]) {
      result = dp[i];
    }
  }
  return result;
};

//数组变整数加一
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function (digits) {
  for (let i = digits.length - 1; i >= 0; i--) {
    digits[i]++;
    digits[i] = digits[i] % 10;
    if (digits[i] != 0) {
      return digits;
    }
  }
  digits.unshift(1);
  return digits;
};

//有序数组的平方
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function (nums) {
  let newNum = nums.map((x) => {
    return (x = x * x);
  });
  newNum.sort((x, y) => x - y);
  return newNum;
};
```

# 哈希表

1. 两数之和

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number[]}
    */

   //  时间复杂度O(n)
   // 空间复杂度O(n)
   var twoSum = function (nums, target) {
     const map = {};
     if (Array.isArray(nums)) {
       for (let i = 0; i < nums.length; i++) {
         // 有可能存在0的情况
         if (map[target - nums[i]] != undefined) {
           return [map[target - nums[i]], i];
         } else {
           map[nums[i]] = i;
         }
       }
     }
   };
   ```

2. 三数之和

   ```js
   // 方法一
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var threeSum = function (nums) {
     let res = [];
     let len = nums.length;
     if (nums == null || len < 3) {
       return res;
     }
     // 数组中有数字重复，sort一定要写全
     nums.sort((a, b) => a - b);
     for (let i = 0; i < len; i++) {
       if (nums[i] > 0) break;
       if (i > 0 && nums[i] == nums[i - 1]) continue;
       let L = i + 1;
       let R = len - 1;
       while (L < R) {
         let sum = nums[i] + nums[L] + nums[R];
         if (sum === 0) {
           res.push([nums[i], nums[L], nums[R]]);
           while (L < R && nums[L] === nums[L + 1]) L++;
           while (L < R && nums[R] === nums[R - 1]) R--;
           L++;
           R--;
         } else if (sum < 0) L++;
         else if (sum > 0) R--;
       }
     }
     return res;
   };
   ```

3. 四数之和

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number[][]}
    */
   var fourSum = function (nums, target) {
     if (nums.length < 4) return [];
     let res = [];
     nums.sort((a, b) => a - b);

     for (let i = 0; i < nums.length; i++) {
       if (i > 0 && nums[i] === nums[i - 1]) continue;
       for (let j = i + 1; j < nums.length; j++) {
         if (j > i + 1 && nums[j] === nums[j - 1]) continue;
         let L = j + 1,
           R = nums.length - 1;
         while (L < R) {
           let sum = nums[i] + nums[j] + nums[L] + nums[R];
           if (sum === target) {
             res.push([nums[i], nums[j], nums[L], nums[R]]);
             while (L < R && nums[L] === nums[R]) L++;
             while (L < R && nums[R] === nums[R - 1]) R--;
             L++;
             R--;
           } else if (sum < target) L++;
           else if (sum > target) R--;
         }
       }
     }
     return res;
   };
   ```

4. 四数之和二

   ```js
   /**
    * @param {number[]} nums1
    * @param {number[]} nums2
    * @param {number[]} nums3
    * @param {number[]} nums4
    * @return {number}
    */
   var fourSumCount = function (nums1, nums2, nums3, nums4) {
     let res = 0;
     let map1 = new Map();

     for (let key1 of nums1) {
       for (let key2 of nums2) {
         let sum = key1 + key2;
         map1.set(sum, map1.has(sum) ? map1.get(sum) + 1 : 1);
       }
     }
     for (let key1 of nums3) {
       for (let key2 of nums4) {
         let sum2 = key1 + key2;
         res += map1.has(0 - sum2) ? map1.get(0 - sum2) : 0;
       }
     }
     return res;
   };
   ```

5. 两个数组的交集

   ```js
   /**
    * @param {number[]} nums1
    * @param {number[]} nums2
    * @return {number[]}
    */
   var intersection = function (nums1, nums2) {
     let numberA = new Set(nums1);
     let numberB = new Set(nums2);
     let res = [];
     if (numberA.length > numberB.length) {
       let temp = numberA;
       numberA = numberB;
       numberB = temp;
     }
     for (let value of numberA) {
       if (numberB.has(value)) {
         res.push(value);
       }
     }
     return res;
   };
   ```

6. 快乐数

   ```js
   /**
    * @param {number} n
    * @return {boolean}
    */
   var isHappy = function (n) {
     let map = new Map();
     var getSum = function (n) {
       let res = 0;
       while (n) {
         number = n % 10;
         res += number * number;
         n = Math.floor(n / 10);
       }
       return res;
     };

     while (true) {
       if (map.has(n)) return false;
       if (n === 1) return true;
       map.set(n, 1);
       n = getSum(n);
     }
   };
   ```

# 动态规划

1. 使用最小花费爬楼梯

   ```js
   /**
    * @param {number[]} cost
    * @return {number}
    */
   var minCostClimbingStairs = function (cost) {
     // fill(0)可以不加
     let dp = new Array(cost.length).fill(0);
     dp[0] = cost[0];
     dp[1] = cost[1];
     for (let i = 2; i < cost.length; i++) {
       dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
     }

     return Math.min(dp[cost.length - 1], dp[cost.length - 2]);
   };
   ```

2. 整数拆分

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var integerBreak = function (n) {
     let dp = new Array(n + 1).fill(0);
     dp[2] = 1;
     for (let i = 3; i <= n; i++) {
       for (let j = 1; j < i; j++) {
         dp[i] = Math.max(dp[i], dp[i - j] * j, (i - j) * j);
       }
     }
     return dp[n];
   };
   ```

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var cuttingRope = function (n) {
     let dp = new Array(n + 1).fill(0);
     dp[1] = 1;
     for (let i = 2; i <= n; i++) {
       for (let j = 1; j < i; j++) {
         dp[i] = Math.max(dp[i], (i - j) * j, dp[i - j] * j);
       }
     }
     return dp[n];
   };
   ```

3. 不同的二叉搜索树

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var numTrees = function (n) {
     // fill(0)一定要加
     let dp = new Array(n + 1).fill(0);
     dp[0] = 1;
     dp[1] = 1;
     // 注意i的初始值， 从2开始， 从1开始的话dp[i]会重新计算变为2
     for (let i = 2; i <= n; i++) {
       for (let j = 1; j <= i; j++) {
         dp[i] += dp[j - 1] * dp[i - j];
       }
     }
     return dp[n];
   };
   ```

- 0-1 背包

  ```js
  for (let i = 0; i < weight.length; i++) {
    for (let j = bagWeight; j >= weight[i]; j++) {
      dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
    }
  }
  ```

- 完全背包

1. 完全背包

   ```js
   // 先遍历物品，再遍历背包
   for(int i = 0; i < weight.size(); i++) { // 遍历物品
     for(int j = weight[i]; j < bagWeight ; j++) { // 遍历背包容量
         dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

     }
   }
   ```

2. 求组合个数

   ```js
   for (int i = 0; i < coins.size(); i++) { // 遍历物品
     for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
         dp[j] += dp[j - coins[i]];
     }
   }
   ```

3. 求排列个数

   ```js
   for (int j = 0; j <= amount; j++) { // 遍历背包容量
     for (int i = 0; i < coins.size(); i++) { // 遍历物品
         if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
     }
   }
   ```

4. 分割等和子集

   ```js
   /**
    * @param {number[]} nums
    * @return {boolean}
    */
   var canPartition = function (nums) {
     let sum = nums.reduce((pre, cur) => {
       return pre + cur;
     });
     if (sum % 2 === 1) return false;
     let average = sum / 2;

     var dp = new Array(average + 1).fill(0);

     for (let i = 0; i < nums.length; i++) {
       for (let j = average; j >= nums[i]; j--) {
         dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
         if (dp[j] === average) {
           return true;
         }
       }
     }
     return dp[sum / 2] === sum / 2;
   };
   ```

5. 最后一块石头的重量二

6. 目标和

   ```js
   // 方法一: 回溯法
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number}
    */
   var findTargetSumWays = function (nums, target) {
     let count = 0;

     var getRes = function (sum, index) {
       if (index === nums.length) {
         if (sum === target) {
           count++;
         }
       } else {
         getRes(sum + nums[index], index + 1);
         getRes(sum - nums[index], index + 1);
       }
     };
     getRes(0, 0);
     return count;
   };
   ```

7. 1 和 0

8. 零钱兑换 2

   ```js
   /**
    * @param {number} amount
    * @param {number[]} coins
    * @return {number}
    */
   var change = function (amount, coins) {
     let dp = new Array(amount + 1).fill(0);
     dp[0] = 1;

     for (let i = 0; i < coins.length; i++) {
       for (let j = coins[i]; j <= amount; j++) {
         dp[j] += dp[j - coins[i]];
       }
     }
     return dp[amount];
   };
   ```

9. 组合总和四 | 排列的数目(不会)
   回溯法容易超出时间限制

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number}
    */
   var combinationSum4 = function (nums, target) {
     // 先遍历背包，再遍历物品
     let dp = new Array(target + 1).fill(0);
     dp[0] = 1;
     for (let i = 0; i <= target; i++) {
       for (let j = 0; j < nums.length; j++) {
         if (i >= nums[j]) dp[i] += dp[i - nums[j]];
       }
     }
     return dp[target];
   };
   ```

10. 零钱兑换 | 最少的硬币数目(不会)

    ```js
    /**
     * @param {number[]} coins
     * @param {number} amount
     * @return {number}
     */
    var coinChange = function (coins, amount) {
      if (!amount) return 0;
      let dp = new Array(amount + 1).fill(Infinity);
      dp[0] = 0;

      for (let i = 0; i < coins.length; i++) {
        for (let j = coins[i]; j <= amount; j++) {
          dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
        }
      }
      return dp[amount] === Infinity ? -1 : dp[amount];
    };
    ```

11. 完全平方数

12. 单词拆分

13. 打家劫舍一二三

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var rob = function (nums) {
      let dp = new Array(nums.length + 1).fill(0);
      (dp[0] = nums[0]), (dp[1] = Math.max(nums[0], nums[1]));
      for (let i = 2; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
      }

      return dp[nums.length - 1];
    };
    ```

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var rob = function (nums) {
      var robRange = function (nums, start, end) {
        if (start === end) return nums[start];
        let dp = new Array(nums.length).fill(0);
        dp[start] = nums[start];
        dp[start + 1] = Math.max(nums[start], nums[start + 1]);
        for (let i = start + 2; i <= end; i++) {
          dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
      };
      let len = nums.length;
      if (len === 0) return 0;
      if (len === 1) return nums[0];
      let res1 = robRange(nums, 0, len - 2);
      let res2 = robRange(nums, 1, len - 1);
      return Math.max(res1, res2);
    };
    ```

14. 买卖股票的最佳时机 一二三四

15. 最长递增(上升)子序列

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var lengthOfLIS = function (nums) {
      // 注意初始值
      let dp = new Array(nums.length).fill(1);
      let res = 1;
      for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
          if (nums[i] > nums[j]) {
            // 位置i的最长上升子序列等于j从i-1各个位置的最长升序子序列 + 1的最大值
            dp[i] = Math.max(dp[i], dp[j] + 1);
          }
        }
        if (res < dp[i]) {
          res = dp[i];
        }
      }
      return res;
    };
    ```

16. 最长连续递增序列

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var findLengthOfLCIS = function (nums) {
      let dp = new Array(nums.length).fill(1);
      let result = 1;
      for (let i = 0; i < nums.length - 1; i++) {
        if (nums[i + 1] > nums[i]) {
          dp[i + 1] = dp[i] + 1;
        }
        if (result < dp[i + 1]) {
          result = dp[i + 1];
        }
      }
      return result;
    };
    ```

17. 最长重复子数组

    ```js
    /**
     * @param {number[]} nums1
     * @param {number[]} nums2
     * @return {number}
     */
    var findLength = function (nums1, nums2) {
      // 注意长度
      let dp = new Array(nums1.length + 1)
        .fill(0)
        .map((x) => new Array(nums2.length + 1).fill(0));
      let result = 0;
      for (let i = 1; i <= nums1.length; i++) {
        for (let j = 1; j <= nums2.length; j++) {
          if (nums1[i - 1] === nums2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          }
          if (result < dp[i][j]) {
            result = dp[i][j];
          }
        }
      }
      return result;
    };
    ```

18. 最长公共子序列

    ```js
    /**
     * @param {string} text1
     * @param {string} text2
     * @return {number}
     */
    var longestCommonSubsequence = function (text1, text2) {
      let dp = new Array(text1.length + 1)
        .fill(0)
        .map((x) => new Array(text2.length + 1).fill(0));

      for (let i = 1; i <= text1.length; i++) {
        for (let j = 1; j <= text2.length; j++) {
          if (text1[i - 1] === text2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
          }
        }
      }
      return dp[text1.length][text2.length];
    };
    ```

19. 最大子数组和(最大子序和)

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var maxSubArray = function (nums) {
      let dp = new Array(nums.length).fill(0);
      // 注意result初始值，[1]的情况
      let result = nums[0];
      dp[0] = nums[0];
      for (let i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);

        if (result < dp[i]) {
          result = dp[i];
        }
      }
      return result;
    };
    ```

20. 判断子序列

    ```js
    /**
     * @param {string} s
     * @param {string} t
     * @return {boolean}
     */
    var isSubsequence = function (s, t) {
      let index = 0;
      for (let i = 0; i < t.length; i++) {
        if (s[index] === t[i]) {
          index++;
        }
      }
      return index >= s.length;
    };
    ```

    ```js
    var isSubsequence = function (s, t) {
      let [m, n] = [s.length, t.length];
      let dp = new Array(m + 1).fill().map((item) => new Array(n + 1).fill(0));

      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (s[i - 1] === t[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = dp[i][j - 1];
          }
        }
      }
      return dp[m][n] === m;
    };
    ```

21. 回文子串

    ```js
    /**
     * @param {string} s
     * @return {number}
     */
    var countSubstrings = function (s) {
      var isHW = function (str, l, r) {
        for (let i = l, j = r; i < j; i++, j--) {
          if (str[i] !== str[j]) {
            return false;
          }
        }
        return true;
      };
      let res = 0;
      for (let i = 0; i < s.length; i++) {
        for (let j = i; j < s.length; j++) {
          if (isHW(s, i, j)) {
            res += 1;
          }
        }
      }
      return res;
    };
    ```

22. 最长回文子序列

    ```js

    ```

23. 回文子字符串的个数
    有很多方法

    ```js
    // 动态规划
    const countSubstrings = function (s) {
      const len = s.length;
      const dp = new Array(len).fill(0).map(() => new Array(len).fill(false));
      let res = 0;
      for (let i = 0; i < len; i++) {
        for (let j = i; j >= 0; j--) {
          if (s[i] === s[j]) {
            if (i - j <= 1) {
              dp[i][j] = true;
            } else {
              dp[i][j] = dp[i - 1][j + 1];
            }
          }
          res += dp[i][j] ? 1 : 0;
        }
      }
      return res;
    };
    ```

24. 不相交的线

    ```js
    /**
     * @param {number[]} nums1
     * @param {number[]} nums2
     * @return {number}
     */
    var maxUncrossedLines = function (nums1, nums2) {
      let [m, n] = [nums1.length, nums2.length];
      let dp = new Array(m + 1).fill().map((item) => new Array(n + 1).fill(0));

      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          if (nums1[i - 1] === nums2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
          }
        }
      }
      return dp[m][n];
    };
    ```

25. 最小路径和

    ```js
    /**
     * @param {number[][]} grid
     * @return {number}
     */
    var minPathSum = function (grid) {
      if (grid.length === 0 || grid[0].length === 0) return 0;
      let rows = grid.length,
        columns = grid[0].length;
      // 定义二维数组
      const dp = new Array(rows);
      for (let i = 0; i < rows; i++) {
        dp[i] = new Array(columns);
      }
      dp[0][0] = grid[0][0];
      for (let i = 1; i < rows; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
      }
      for (let j = 1; j < columns; j++) {
        dp[0][j] = dp[0][j - 1] + grid[0][j];
      }

      for (let i = 1; i < rows; i++) {
        for (let j = 1; j < columns; j++) {
          dp[i][j] = Math.min(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];
        }
      }

      return dp[rows - 1][columns - 1];
    };
    ```

26. 三角形最小路径和

    ```js
    /**
     * @param {number[][]} triangle
     * @return {number}
     */
    var minimumTotal = function (triangle) {
      let dp = new Array(triangle.length)
        .fill()
        .map((item, index) => new Array(triangle[index].length).fill(0));
      let len = triangle.length;

      // 这里倒序
      for (let i = len - 1; i >= 0; i--) {
        // 这里正序
        for (let j = 0; j < triangle[i].length; j++) {
          if (i === len - 1) {
            // 最后一行初始化写在里面
            dp[i][j] = triangle[i][j];
          } else {
            dp[i][j] =
              Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j];
          }
        }
      }
      return dp[0][0];
    };
    ```

27. 礼物的最大价值

    ```js
    /**
     * @param {number[][]} grid
     * @return {number}
     */
    var maxValue = function (grid) {
      let m = grid.length,
        n = grid[0].length;

      let dp = new Array(m).fill().map((item) => Array(n).fill(0));
      dp[0][0] = grid[0][0];
      for (let i = 1; i < m; i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
      }

      for (let i = 1; i < n; i++) {
        dp[0][i] = dp[0][i - 1] + grid[0][i];
      }

      for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
          dp[i][j] = Math.max(
            dp[i - 1][j] + grid[i][j],
            dp[i][j - 1] + grid[i][j]
          );
        }
      }
      return dp[m - 1][n - 1];
    };
    ```

28. 粉刷房子

    ```js
    /**
     * @param {number[][]} costs
     * @return {number}
     */
    var minCost = function (costs) {
      let dp = new Array(3).fill(0);
      for (let i = 0; i < costs.length; i++) {
        let p1 = costs[i][0] + Math.min(dp[1], dp[2]);
        let p2 = costs[i][1] + Math.min(dp[0], dp[2]);
        let p3 = costs[i][2] + Math.min(dp[0], dp[1]);
        dp = [p1, p2, p3];
      }
      return Math.min(...dp);
    };
    ```

29. 翻转字符

    ```js
    /**
     * @param {string} s
     * @return {number}
     */
    var minFlipsMonoIncr = function (s) {
      // 记录1的个数
      let countOf1 = s[0] === "0" ? 0 : 1;
      let dp = new Array(s.length).fill(0);
      for (let i = 1; i < s.length; i++) {
        if (s[i] === "0") {
          // s[i] 为0, 有两种选择
          // 1) 将自己的0翻转为1
          // 2) 将前面的所有1翻转为0
          dp[i] = Math.min(dp[i - 1] + 1, countOf1);
        } else {
          // 若为1, 与前面相同
          dp[i] = dp[i - 1];
          // 记录1的个数
          countOf1++;
        }
      }
      return dp[s.length - 1];
    };
    ```

30. 最长斐波那契数列

    ```js
    /**
     * @param {number[]} arr
     * @return {number}
     */
    var lenLongestFibSubseq = function (arr) {
      let map = new Map();
      let res = 0;
      for (let i = 0; i < arr.length; i++) {
        map.set(arr[i], i);
      }

      var dfs = function (pre, cur, len) {
        let sum = arr[pre] + arr[cur];
        if (map.has(sum)) {
          dfs(cur, map.get(sum), len + 1);
          res = Math.max(res, len + 1);
        }
      };
      for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
          dfs(i, j, 2);
        }
      }
      return res;
    };
    ```

31. 字符串交织(不会)

32. 最长连续序列

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var longestConsecutive = function (nums) {
      if (!nums.length) return 0;
      let res = 1;
      nums.sort((a, b) => a - b);
      let dp = new Array(nums.length).fill(1);

      for (let i = 1; i < nums.length; i++) {
        if (nums[i] === nums[i - 1] + 1) {
          dp[i] = dp[i - 1] + 1;
        } else if (nums[i] === nums[i - 1]) {
          dp[i] = dp[i - 1];
        }
        res = Math.max(res, dp[i]);
      }
      return res;
    };
    ```

33. 矩阵中的距离(不会)

    ```js

    ```

34. 把数字翻译成字符串

    ```js
    /**
     * @param {number} num
     * @return {number}
     */
    var translateNum = function (num) {
      const str = num.toString();
      const len = str.length;
      let dp = new Array(len + 1);
      (dp[0] = 1), (dp[1] = 1);

      for (let i = 2; i <= len; i++) {
        let temp = Number(str[i - 2] + str[i - 1]);
        if (temp > 9 && temp < 26) {
          dp[i] = dp[i - 1] + dp[i - 2];
        } else {
          dp[i] = dp[i - 1];
        }
      }
      return dp[len];
    };
    ```

35. 丑数
    https://leetcode-cn.com/problems/chou-shu-lcof/solution/js-jian-zhi-offer-49-chou-shu-by-adela20-4q7p/

    ```js
    /**
     * @param {number} n
     * @return {number}
     */
    var nthUglyNumber = function (n) {
      const dp = [1];
      let p2 = 0,
        p3 = 0,
        p5 = 0;
      for (let i = 1; i < n; i++) {
        let n2 = dp[p2] * 2,
          n3 = dp[p3] * 3,
          n5 = dp[p5] * 5;
        dp[i] = Math.min(n2, n3, n5);
        dp[i] == n2 && p2++;
        dp[i] == n3 && p3++;
        dp[i] == n5 && p5++;
      }
      return dp[n - 1];
    };
    ```

36. 跳跃游戏

37. 股票的最大利润
    https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/solution/yi-ci-bian-li-javascript-by-lzxjack-su9l/

    ```js
    /**
     * @param {number[]} prices
     * @return {number}
     */
    const maxProfit = (prices) => {
      const len = prices.length;
      // 创建dp数组
      const dp = new Array(len).fill([0, 0]);
      // dp数组初始化
      dp[0] = [-prices[0], 0];
      for (let i = 1; i < len; i++) {
        // 更新dp[i]
        dp[i] = [
          Math.max(dp[i - 1][0], -prices[i]),
          Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0]),
        ];
      }
      return dp[len - 1][1];
    };
    ```

# 回溯

- for 循环横向遍历， 递归纵向遍历
- 题目分类: 组合(1,2)，子集(3,4,5)， 排列(6,7,8)， 分割(9,10)， 棋盘问题， 其它(递增子序列， 重新安排行程)

1. T77 组合

   ```js
   /**
    * @param {number} n
    * @param {number} k
    * @return {number[][]}
    */
   var combine = function (n, k) {
     let res = [],
       path = [];

     var getPath = function (index) {
       if (path.length === k) {
         res.push([...path]);
         return;
       }
       for (let i = index; i <= n; i++) {
         path.push(i);
         getPath(i + 1);
         path.pop();
       }
     };
     getPath(1);
     return res;
   };
   ```

2. T216 组合

   ```js
   /**
    * @param {number} k
    * @param {number} n
    * @return {number[][]}
    */
   var combinationSum3 = function (k, n) {
     let res = [],
       path = [];
     var getPath = function (sum, index) {
       if (sum > n) return;
       if (sum === n && path.length === k) {
         res.push([...path]);
         return;
       }
       for (let i = index; i <= 9; i++) {
         path.push(i);
         getPath(sum + i, i + 1);
         path.pop();
       }
     };
     getPath(0, 1);
     return res;
   };
   ```

3. T39 允许重复选择元素的组合

   ```js
   var combinationSum = function (candidates, target) {
     candidates.sort();
     let res = [];
     var getPath = function (sum, path, j) {
       // if (sum > target) return
       if (sum === target) {
         res.push([...path]);
         return;
       }
       for (let i = j; i < candidates.length; i++) {
         let number = candidates[i];
         // 不加会导致栈溢出
         if (number > target - sum) continue;
         path.push(number);

         sum += number;
         // 不能写sum+candidates[i], 否则 sum-=number改的就是原来的sum, 不是加过number后的sum
         getPath(sum, path, i);
         path.pop();
         sum -= number;
       }
     };
     getPath(0, [], 0);
     return res;
   };
   ```

4. T40 || 含有重复元素集合的组合(难)

   ```js
   var combinationSum2 = function (candidates, target) {
     const res = [],
       path = [];
     candidates.sort(); // 排序
     backtracking(0, 0);
     return res;
     function backtracking(j, sum) {
       if (sum > target) return;
       if (sum === target) {
         res.push(Array.from(path));
         return;
       }
       let f = -1;
       for (let i = j; i < candidates.length; i++) {
         const n = candidates[i];
         if (n > target - sum || f === n) continue;
         path.push(n);
         sum += n;
         backtracking(i + 1, sum);
         f = n;
         path.pop();
         sum -= n;
       }
     }
   };
   ```

5. 递增子序列

   ```js
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var findSubsequences = function (nums) {
     let res = [];

     var getPath = function (path, j) {
       if (path.length > 1) {
         res.push([...path]);
       }
       let uset = [];
       for (let i = j; i < nums.length; i++) {
         if (
           (path.length > 0 && nums[i] < path[path.length - 1]) ||
           uset[nums[i] + 100]
         )
           continue;
         uset[nums[i] + 100] = true;
         path.push(nums[i]);
         getPath(path, i + 1);
         path.pop();
       }
     };
     getPath([], 0);
     return res;
   };
   ```

6. 全排列

   ```js
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var permute = function (nums) {
     let res = [];
     var getPath = function (path, used) {
       if (path.length === nums.length) {
         res.push([...path]);
         return;
       }
       for (let i = 0; i < nums.length; i++) {
         if (used[i]) continue;
         path.push(nums[i]);
         used[i] = true;
         getPath(path, used);
         path.pop();
         used[i] = false;
       }
     };
     getPath([], []);
     return res;
   };
   ```

7. 全排列(含有重复数字) - 可以用 f

   ```js
   // 方法一
   /**
    * @param {number[]} nums
    * @return {number[][]}
    */
   var permuteUnique = function (nums) {
     nums.sort((a, b) => a - b);
     let res = [];
     var getPath = function (path, used) {
       if (path.length === nums.length) {
         res.push([...path]);
         return;
       }
       let f = "";
       for (let i = 0; i < nums.length; i++) {
         if (used[i] || f === nums[i]) continue;
         path.push(nums[i]);
         f = nums[i];
         used[i] = true;
         getPath(path, used);
         path.pop();
         used[i] = false;
       }
     };
     getPath([], []);
     return res;
   };
   ```

8. 字符串的排列(难)

   ```js
   var permutation = function (s) {
     s = s.split("").sort().join("");
     let n = s.length;

     let res = [],
       path = [];
     backtrack([]);
     return res;

     function backtrack(used) {
       if (path.length === n) {
         res.push(path.slice());
         return;
       }

       for (let i = 0; i < n; i++) {
         if (used[i]) continue;
         if (i > 0 && s[i] === s[i - 1] && !used[i - 1]) continue;

         used[i] = 1;
         path = path + s[i];
         backtrack(used);
         used[i] = 0;
         path = path.slice(0, path.length - 1);
       }
     }
   };
   ```

   ```js
   /**
    * @param {string} s
    * @return {string[]}
    */
   var permutation = function (s) {
     s = s.split("").sort(); //字符排序时不需要加 (a,b) => a-b ,会出错
     let res = [];
     let len = s.length;
     var getPath = function (path, used) {
       if (path.length === len) {
         res.push(path.join(""));
         return;
       }
       let f = "";
       for (let i = 0; i < len; i++) {
         if (used[i] || f === s[i]) continue;
         path.push(s[i]);
         used[i] = true;
         f = s[i];
         getPath(path, used);
         path.pop();
         used[i] = false;
       }
     };
     getPath([], []);
     return res;
   };
   ```

9. 分割回文子字符串

   ```js
   /**
    * @param {string} s
    * @return {string[][]}
    */
   var partition = function (s) {
     let res = [],
       len = s.length;

     var isHW = function (s, l, r) {
       for (let i = l, j = r; i < j; i++, j--) {
         if (s[i] !== s[j]) return false;
       }
       return true;
     };

     var getPath = function (path, i) {
       if (i >= len) {
         res.push([...path]);
         return;
       }
       for (let j = i; j < s.length; j++) {
         if (!isHW(s, i, j)) continue;
         path.push(s.substr(i, j - i + 1));
         getPath(path, j + 1);
         path.pop();
       }
     };
     getPath([], 0);
     return res;
   };
   ```

10. 复原 IP

    ```js
    /**
     * @param {string} s
     * @return {string[]}
     */
    var restoreIpAddresses = function (s) {
      let res = [];

      var getPath = function (path, i) {
        let len = path.length;
        if (len > 4) return;
        if (len === 4 && i === s.length) {
          res.push(path.join("."));
          return;
        }
        for (let j = i; j < s.length; j++) {
          let str = s.substr(i, j - i + 1);
          if (str.length > 3 || +str > 255) break;
          // str[0]为字符串'0'
          if (str.length > 1 && str[0] === "0") break;
          path.push(str);
          getPath(path, j + 1);
          path.pop();
        }
      };
      getPath([], 0);
      return res;
    };
    ```

11. 加减的目标值 | 目标和

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var findTargetSumWays = function (nums, target) {
      let res = 0;
      var getRes = function (sum, index) {
        // if else 需要判断
        if (index === nums.length) {
          if (sum === target) {
            res++;
            // return加不加都可以
            return;
          }
        } else {
          // 不是index++
          getRes(sum + nums[index], index + 1);
          getRes(sum - nums[index], index + 1);
        }
      };
      getRes(0, 0);
      return res;
    };
    ```

12. 所有路径

    ```js
    /**
     * @param {number[][]} graph
     * @return {number[][]}
     */
    var allPathsSourceTarget = function (graph) {
      let stack = [],
        res = [];

      var getPath = function (x) {
        if (x === graph.length - 1) {
          res.push([...stack]);
          return;
        }
        for (let y of graph[x]) {
          stack.push(y);
          getPath(y);
          stack.pop();
        }
      };
      stack.push(0);
      getPath(0);
      return res;
    };
    ```

13. 生成匹配的括号 | 括号生成

    ```js
    /**
     * @param {number} n
     * @return {string[]}
     */
    var generateParenthesis = function (n) {
      let res = [];

      var getPath = function (path, open, close) {
        // 剪枝
        if (open > n || close > open) return;
        if (path.length === 2 * n) {
          res.push(path);
          return;
        }
        getPath(path + "(", open + 1, close);
        getPath(path + ")", open, close + 1);
      };
      getPath("", 0, 0);
      return res;
    };
    ```

14. 矩阵中的路径 | 单词搜索

    ```js
    /**
     * @param {character[][]} board
     * @param {string} word
     * @return {boolean}
     */
    var exist = function (board, word) {
      const [m, n] = [board.length, board[0].length];

      const dfs = function (r, c, index) {
        // 越界、或者字符不匹配
        if (r < 0 || r >= m || c < 0 || c >= n || board[r][c] !== word[index])
          return false;
        // 索引等于单词长度-1，说明全匹配上了
        if (index === word.length - 1) return true;
        // 保存当前字符
        let temp = board[r][c];
        // 将当前字符设置为空，防止四个方向dfs再次遍历到
        board[r][c] = "";
        let res =
          dfs(r + 1, c, index + 1) ||
          dfs(r - 1, c, index + 1) ||
          dfs(r, c + 1, index + 1) ||
          dfs(r, c - 1, index + 1);
        // 恢复当前字符
        board[r][c] = temp;
        return res;
      };

      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          if (dfs(i, j, 0)) return true;
        }
      }
      return false;
    };
    s;
    ```

15. 不同的二叉搜索树 II

# 贪心算法

1. 分发饼干

   ```js
   /**
    * @param {number[]} g
    * @param {number[]} s
    * @return {number}
    */
   var findContentChildren = function (g, s) {
     g.sort((a, b) => a - b);
     s.sort((a, b) => a - b);
     let res = 0;
     let index = s.length - 1;
     for (let i = g.length - 1; i >= 0; i--) {
       if (index >= 0 && s[index] >= g[i]) {
         res++;
         index--;
       }
     }
     return res;
   };
   ```

2. 摆动序列

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var wiggleMaxLength = function (nums) {
     if (nums.length <= 1) return 1;
     let result = 1;
     let pre = 0;
     let cur = 0;
     for (let i = 0; i < nums.length; i++) {
       cur = nums[i + 1] - nums[i];
       if ((pre >= 0 && cur < 0) || (pre <= 0 && cur > 0)) {
         result++;
         pre = cur;
       }
     }
     return result;
   };
   ```

3. 股票的最大利润

   ```js
   /**
    * @param {number[]} prices
    * @return {number}
    */
   var maxProfit = function (prices) {
     let min = prices[0];
     let profit = 0;
     for (let i = 1; i < prices.length; i++) {
       min = Math.min(min, prices[i]);
       profit = Math.max(profit, prices[i] - min);
     }
     return profit;
   };
   ```

# 滑动窗口

https://leetcode-cn.com/problems/2VG8Kg/solution/shua-chuan-jian-zhi-offer-day06-shu-zu-i-d5ne/

如何识别滑动窗口的题目？一般题目中都会有明确的“连续子数组”、“连续子串”等关键字，另外可能会附带最大、最小的限定词进行补充。

```
初始化左边界 left = 0
初始化返回值 ret = 最小值 or 最大值
for 右边界 in 可迭代对象:
  更新窗口内部信息
  while 根据题意进行调整：
    比较并更新ret(收缩场景时)
    扩张或收缩窗口大小
  比较并更新ret(扩张场景时)
返回 ret
```

1. 和大于等于 target 的最短子数组 | 长度最小的子数组

   ```js
   /**
    * @param {number} target
    * @param {number[]} nums
    * @return {number}
    */
   var minSubArrayLen = function (target, nums) {
     let left = 0;
     let sum = 0,
       res = nums.length + 1;
     for (let right = 0; right < nums.length; right++) {
       sum += nums[right];

       while (sum >= target && left <= right) {
         res = Math.min(res, right - left + 1);

         sum -= nums[left];
         left++;
       }
     }
     return res === nums.length + 1 ? 0 : res;
   };
   ```

2. 乘积小于 k 的子数组

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var numSubarrayProductLessThanK = function (nums, k) {
     let left = 0;
     let res = 0,
       sum = 1;
     for (let right = 0; right < nums.length; right++) {
       sum *= nums[right];

       while (sum >= k && left <= right) {
         sum /= nums[left];
         left++;
       }
       res += right >= left ? right - left + 1 : 0;
     }
     return res;
   };
   ```

3. 和为 k 的子数组
   思路: 使用前缀和
   https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&idx=1&sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var subarraySum = function (nums, k) {
     let res = 0,
       sum = 0;
     let map = new Map();
     map.set(0, 1);

     for (let i = 0; i < nums.length; i++) {
       sum += nums[i];
       res += map.get(sum - k) || 0;
       map.set(sum, (map.get(sum) || 0) + 1);
     }
     return res;
   };
   ```

4. 0 和 1 个数相同的子数组
   思路: 使用前缀和

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findMaxLength = function (nums) {
     const n = nums.length;
     const map = new Map();
     map.set(0, -1);
     // 前缀和
     let pre = 0;
     let res = 0;
     for (let i = 0; i < n; i++) {
       pre += nums[i] == 0 ? -1 : 1;
       // 如果存在的话，则将当前索引和之前存入的索引值相减  取题目要求的最大值
       if (map.has(pre)) {
         res = Math.max(res, i - map.get(pre));
       } else {
         // 记录前缀和索引
         map.set(pre, i);
       }
     }
     return res;
   };
   ```

5. 不含重复字符的最长子字符串(中)
   https://leetcode-cn.com/problems/wtcaE1/solution/jian-dan-yi-dong-javac-pythonjshua-dong-dtang/

   ```js
   /**
    * @param {string} s
    * @return {number}
    */
   var lengthOfLongestSubstring = function (s) {
     // 窗口中的字符
     let window = {};
     let left = 0,
       res = 0;
     for (let right = 0; right < s.length; right++) {
       let str = s[right];
       window[str] = (window[str] || 0) + 1;
       while (window[str] > 1) {
         // 需要思考
         let strL = s[left];
         left++;
         window[strL]--;
       }
       res = Math.max(res, right - left + 1);
     }
     return res;
   };
   ```

# 深度优先遍历和广度优先遍历

1. 网格 dfs 框架代码

   ```js
   var dfs = function (grid, r, c) {
     // 判断是否超出网格范围
     if (!inArea(grid, r, c)) return;
     // 如果这个格子不是岛屿， 直接返回
     if (grid[r][c] !== 1) return;
     // 将格子标记为已遍历过
     grid[r][c] = 2;

     dfs(grid, r - 1, c);
     dfs(grid, r + 1, c);
     dfs(grid, r, c - 1);
     dfs(grid, r, c + 1);
   };

   var inArea = function (grid, r, c) {
     return 0 <= r && r < grid.length && 0 <= c && c < grid[0].length;
   };
   ```

2. 岛屿问题

   1. 岛屿数量

      ```js
      /**
       * @param {character[][]} grid
       * @return {number}
       */
      var numIslands = function (grid) {
        var inArea = function (grid, r, c) {
          return 0 <= r && r < grid.length && 0 <= c && c < grid[0].length;
        };
        var getArea = function (grid, r, c) {
          if (!inArea(grid, r, c)) return;
          if (grid[r][c] !== "1") return;
          grid[r][c] = "2";

          getArea(grid, r - 1, c);
          getArea(grid, r + 1, c);
          getArea(grid, r, c - 1);
          getArea(grid, r, c + 1);
        };
        let res = 0;
        for (let r = 0; r < grid.length; r++) {
          for (let c = 0; c < grid[0].length; c++) {
            if (grid[r][c] === "1") {
              res++;
              getArea(grid, r, c);
            }
          }
        }
        return res;
      };
      ```

   2. 岛屿的周长

      ```js
      /**
       * @param {number[][]} grid
       * @return {number}
       */
      var islandPerimeter = function (grid) {
        var getLen = function (grid, r, c) {
          // 从一个岛屿方格走向网格边界，周长加 1
          if (r >= 0 && r < grid.length && c >= 0 && c < grid[0].length) {
            return 1;
          }
          // 从一个岛屿方格走向水域方格，周长加 1
          if (grid[r][c] === 0) return 1;
          // 已遍历过， 不重复遍历，返回0
          if (grid[r][c] === 2) return 0;
          grid[r][c] = 2;
          return (
            getLen(grid, r - 1, c) +
            getLen(grid, r, c - 1) +
            getLen(grid, r, c + 1) +
            getLen(grid, r + 1, c)
          );
        };

        for (let r = 0; r < grid.length; r++) {
          for (let c = 0; c < grid[0].length; c++) {
            if (grid[r][c] === 1) {
              return getLen(grid, r, c);
            }
          }
        }
      };
      ```

   3. 岛屿的最大面积

      ```js
      /**
       * @param {number[][]} grid
       * @return {number}
       */
      var maxAreaOfIsland = function (grid) {
        var inArea = function (grid, r, c) {
          return 0 <= r && r < grid.length && c >= 0 && c < grid[0].length;
        };

        var getArea = function (grid, r, c) {
          if (!inArea(grid, r, c)) return 0;
          if (grid[r][c] !== 1) return 0;
          grid[r][c] = 2;
          return (
            1 +
            getArea(grid, r - 1, c) +
            getArea(grid, r, c - 1) +
            getArea(grid, r, c + 1) +
            getArea(grid, r + 1, c)
          );
        };

        let res = 0;
        for (let r = 0; r < grid.length; r++) {
          for (let c = 0; c < grid[0].length; c++) {
            if (grid[r][c] === 1) {
              let area = getArea(grid, r, c);
              res = Math.max(res, area);
            }
          }
        }
        return res;
      };
      ```

3. 二分图
4. 计算除法
5. 课程顺序
6. 省份数量
7. 多余的边

8. 矩阵中的路径

   ```js
   /**
    * @param {character[][]} board
    * @param {string} word
    * @return {boolean}
    */
   var exist = function (board, word) {
     const [m, n] = [board.length, board[0].length];

     const dfs = function (r, c, index) {
       // 越界、或者字符不匹配
       if (r < 0 || r >= m || c < 0 || c >= n || board[r][c] !== word[index])
         return false;
       // 索引等于单词长度-1，说明全匹配上了
       if (index === word.length - 1) return true;
       // 保存当前字符
       let temp = board[r][c];
       // 将当前字符设置为空，防止四个方向dfs再次遍历到
       board[r][c] = "";
       let res =
         dfs(r + 1, c, index + 1) ||
         dfs(r - 1, c, index + 1) ||
         dfs(r, c + 1, index + 1) ||
         dfs(r, c - 1, index + 1);
       // 恢复当前字符
       board[r][c] = temp;
       return res;
     };

     for (let i = 0; i < m; i++) {
       for (let j = 0; j < n; j++) {
         if (dfs(i, j, 0)) return true;
       }
     }
     return false;
   };
   s;
   ```

9. 机器人的运动范围

   ```js
   /**
    * @param {number} m
    * @param {number} n
    * @param {number} k
    * @return {number}
    */
   var movingCount = function (m, n, k) {
     // visited 用来记录走过的格子，避免重复
     const visited = Array(m)
       .fill(0)
       .map((item) => Array(n).fill(false));

     // 辅助函数，计算位数和
     function sum(n) {
       let res = 0;
       while (n) {
         res += n % 10;
         n = Math.floor(n / 10);
       }
       return res;
     }
     // dfs
     let res = 0;
     function dfs(x, y) {
       // 对应开头所说的三个终止条件，超过k值、到达边界、走过的格子
       if (x >= m || x < 0 || y >= n || y < 0 || visited[x][y]) return;

       // 记录当前格子已经走过，返回当前计数 1 + 后续其他两个方向的总和
       visited[x][y] = true;
       if (sum(x) + sum(y) <= k) {
         res++;
         dfs(x + 1, y);
         dfs(x - 1, y);
         dfs(x, y - 1);
         dfs(x, y + 1);
       }
     }
     dfs(0, 0);
     return res;
   };
   ```

# 二分查找

https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/

1. 二分查找

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number}
    */
   var search = function (nums, target) {
     let left = 0,
       right = nums.length - 1;
     while (left <= right) {
       let midIndex = Math.floor((right - left) / 2) + left;
       let mid = nums[midIndex];
       if (mid === target) {
         return midIndex;
       } else if (mid < target) {
         left = midIndex + 1;
       } else {
         right = midIndex - 1;
       }
     }
     return -1;
   };
   ```

2. 在排序数组中查找元素的第一个和最后一个位置

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number[]}
    */
   var searchRange = function (nums, target) {
     //二分查找
     let find = (isLeft) => {
       let left = 0,
         right = nums.length - 1;

       while (left <= right) {
         let mid = Math.floor((left + right) / 2);

         if (target < nums[mid]) {
           right = mid - 1;
         } else if (target > nums[mid]) {
           left = mid + 1;
         } else {
           if (isLeft) {
             if (nums[mid] === nums[mid - 1]) {
               right = mid - 1;
             } else {
               return mid;
             }
           } else {
             if (nums[mid] === nums[mid + 1]) {
               left = mid + 1;
             } else {
               return mid;
             }
           }
         }
       }
       return -1;
     };
     let left = find(true),
       right = find(false);
     return [left, right];
   };
   ```

3. 寻找峰值 |

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findPeakElement = function (nums) {
     let left = 0,
       right = nums.length - 1;

     while (left < right) {
       let mid = Math.floor((left + right) / 2);
       if (nums[mid] < nums[mid + 1]) {
         left = mid + 1;
       } else {
         right = mid;
       }
     }
     return left;
   };
   ```

4. 二维数组中的查找(中)

   ```js
   /**
    * @param {number[][]} matrix
    * @param {number} target
    * @return {boolean}
    */
   var findNumberIn2DArray = function (matrix, target) {
     // 存在 matrix = [] 的情况
     if (!matrix[0]) return 0;
     let left = 0,
       right = matrix[0].length - 1;

     while (left < matrix.length && right >= 0) {
       if (matrix[left][right] < target) {
         left++;
       } else if (matrix[left][right] > target) {
         right--;
       } else {
         return true;
       }
     }
     return false;
   };
   ```

5. 旋转数组的最小数字

   ```js
   /**
    * @param {number[]} numbers
    * @return {number}
    */
   var minArray = function (numbers) {
     let left = 0,
       right = numbers.length - 1;
     while (left < right) {
       let mid = left + Math.floor((right - left) / 2);
       if (numbers[mid] > numbers[right]) {
         left = mid + 1;
       } else if (numbers[mid] < numbers[right]) {
         right = mid;
       } else {
         right--;
       }
     }
     return numbers[left];
   };
   ```

6. 数字序列中某一位的数字
   https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var findNthDigit = function (n) {
     // 表示n所在的数字位数, 数字10的位数 为 2
     let digit = 1;
     // 每 digitdigit 位数的起始数字（即：1, 10, 100, \cdots1,10,100,⋯），记为 start
     let start = 1;
     // 位数的数字数量
     let count = 9;

     while (n > count) {
       n -= count;
       digit += 1;
       start *= 10;
       count = digit * start * 9;
     }
     // 找出所在的数字
     let num = start + Math.floor((n - 1) / digit);
     // 找出所在数字的第几位
     let index = (n - 1) % digit;
     return num.toString().charAt(index) - "0";
   };
   ```

7. 在排序数组中查找数字

   ```js
   /**
    * @param {number[]} nums
    * @param {number} target
    * @return {number}
    */
   var search = function (nums, target) {
     var helper = function (nums, target) {
       let left = 0,
         right = nums.length - 1;
       while (left <= right) {
         let mid = Math.floor((left + right) / 2);
         if (nums[mid] <= target) {
           left = mid + 1;
         } else {
           right = mid - 1;
         }
       }
       return left;
     };
     return helper(nums, target) - helper(nums, target - 1);
   };
   ```

8. 按权重生成随机数

9. 排序数组中两个数字之和
   https://leetcode-cn.com/problems/kLl5u1/solution/jian-dan-yi-dong-javac-pythonjs-liang-sh-et4y/

   ```js
   /**
    * @param {number[]} numbers
    * @param {number} target
    * @return {number[]}
    */
   var twoSum = function (numbers, target) {
     let left = 0,
       right = numbers.length - 1;

     while (left < right) {
       let sum = numbers[left] + numbers[right];
       if (sum < target) {
         left++;
       } else if (sum > target) {
         right--;
       } else {
         return [left, right];
       }
     }
     return [];
   };
   ```

10. 查找插入位置

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var searchInsert = function (nums, target) {
      let left = 0,
        right = nums.length - 1;
      let mid;
      while (left <= right) {
        mid = Math.floor((left + right) / 2);
        if (nums[mid] < target) {
          left = mid + 1;
        } else if (nums[mid] > target) {
          right = mid - 1;
        } else {
          return mid;
        }
      }
      return left;
    };
    ```

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var searchInsert = function (nums, target) {
      for (let i = 0; i < nums.length; i++) {
        if (target <= nums[i]) {
          return i;
        }
      }
      return nums.length;
    };
    ```

11. 山峰数组的顶部

    ```js
    /**
     * @param {number[]} arr
     * @return {number}
     */
    var peakIndexInMountainArray = function (arr) {
      let left = 1,
        right = arr.length - 2;
      while (left < right) {
        let mid = Math.floor((left + left) / 2);
        if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1]) {
          return mid;
        } else if (arr[mid - 1] < arr[mid]) {
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      return left;
    };
    ```

12. 排序数组中只出现一次的数字

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var singleNonDuplicate = function (nums) {
      let res = 0;
      for (let num of nums) {
        res ^= num;
      }
      return res;
    };
    ```

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var singleNonDuplicate = function (nums) {
      let map = new Map();
      for (let num of nums) {
        map.set(num, (map.get(num) || 0) + 1);
      }
      for (let [key, value] of map) {
        if (value === 1) {
          return key;
        }
      }
    };
    ```

13. 求平方根

    ```js
    /**
     * @param {number} x
     * @return {number}
     */
    var mySqrt = function (x) {
      let left = 0,
        right = x;
      while (left < right) {
        let mid = Math.ceil((left + right) / 2);
        if (mid * mid <= x) {
          left = mid;
        } else {
          right = mid - 1;
        }
      }
      return left;
    };
    ```

14. 狒狒吃香蕉

    ```js
    /**
     * @param {number[]} piles
     * @param {number} h
     * @return {number}
     */
    var minEatingSpeed = function (piles, h) {
      let left = 1,
        right = Math.max(...piles) + 1;

      while (left < right) {
        let mid = Math.floor((left + right) / 2);
        if (canFinish(piles, mid, h)) {
          // 因为是左闭右开区间  所以这里right = mid
          // 搜索左侧边界，则需要收缩右侧边界
          right = mid;
        } else {
          left = mid + 1;
        }
      }
      return left;
    };
    // 吃完n根香蕉以speed的速度需要多少小时
    var getTime = function (num, speed) {
      return Math.floor(num / speed) + (num % speed > 0);
    };
    // piles堆香蕉以speed的速度能否在h小时内吃完
    var canFinish = function (piles, speed, h) {
      let time = 0;
      for (let pile of piles) {
        time += getTime(pile, speed);
      }
      return time <= h;
    };
    ```

15. 搜索旋转数组
    https://leetcode-cn.com/problems/search-rotate-array-lcci/solution/xuan-zhuan-shu-zu-cong-yi-dao-nan-ge-ge-dcv7a/

# 前缀和

1. 和为 k 的子数组
   思路: 使用前缀和
   https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&idx=1&sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var subarraySum = function (nums, k) {
     let res = 0,
       sum = 0;
     let map = new Map();
     map.set(0, 1);

     for (let i = 0; i < nums.length; i++) {
       sum += nums[i];
       res += map.get(sum - k) || 0;
       map.set(sum, (map.get(sum) || 0) + 1);
     }
     return res;
   };
   ```

2. 0 和 1 个数相同的子数组
   思路: 使用前缀和

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findMaxLength = function (nums) {
     const n = nums.length;
     const map = new Map();
     map.set(0, -1);
     // 前缀和
     let pre = 0;
     let res = 0;
     for (let i = 0; i < n; i++) {
       pre += nums[i] == 0 ? -1 : 1;
       // 如果存在的话，则将当前索引和之前存入的索引值相减  取题目要求的最大值
       if (map.has(pre)) {
         res = Math.max(res, i - map.get(pre));
       } else {
         // 记录前缀和索引
         map.set(pre, i);
       }
     }
     return res;
   };
   ```

# 回文

1. 回文子字符串的个数

   有很多方法

   ```js
   // 双重for循环
   /**
    * @param {string} s
    * @return {number}
    */
   var countSubstrings = function (s) {
     let res = 0;
     var isHW = function (str, l, r) {
       for (let i = l, j = r; i <= j; i++, j--) {
         if (str[i] !== str[j]) return false;
       }
       return true;
     };
     for (let i = 0; i < s.length; i++) {
       for (let j = i; j < s.length; j++) {
         if (isHW(s, i, j)) {
           res++;
         }
       }
     }
     return res;
   };
   ```

   ```js
   // 动态规划
   const countSubstrings = function (s) {
     const len = s.length;
     const dp = new Array(len).fill(0).map(() => new Array(len).fill(false));
     let res = 0;
     for (let i = 0; i < len; i++) {
       for (let j = i; j >= 0; j--) {
         if (s[i] === s[j]) {
           // 初始化
           if (i - j <= 1) {
             // 初始化 a 和 aa 的情况
             dp[i][j] = true;
           } else {
             dp[i][j] = dp[i - 1][j + 1];
           }
         }
         res += dp[i][j] ? 1 : 0;
       }
     }
     return res;
   };
   ```

   ```js
   // 双指针法, 以某个字符串为中心向外延展
   /**
    * @param {string} s
    * @return {number}
    */
   var countSubstrings = function (s) {
     if (!s) return 0;

     var isHW = function (s, start, end) {
       let count = 0;
       while (
         start >= 0 &&
         end < s.length &&
         // 下面这句一定要写在条件里, false直接break
         s.charAt(start) === s.charAt(end)
       ) {
         count++;
         start--;
         end++;
       }
       return count;
     };
     let res = 0;
     for (let i = 0; i < s.length; i++) {
       // 长度为奇数的回文的对称中心只有一个字符
       res += isHW(s, i, i);
       // 长度为偶数的回文的对称中心只有两个字符
       res += isHW(s, i, i + 1);
     }
     return res;
   };
   ```

# 剑指 offer

## 简单

1. 数组中重复的数字

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findRepeatNumber = function (nums) {
     let map = new Map();
     for (let i of nums) {
       if (map.has(i)) return i;
       map.set(i, 1);
     }
     return null;
   };
   ```

2. 替换空格, 即实现 replaceAll 方法

   ```js
   /**
    * @param {string} s
    * @return {string}
    */
   var replaceSpace = function (s) {
     return s.replaceAll(" ", "%20");
   };
   ```

   ```js
   /**
    * @param {string} s
    * @return {string}
    */
   var replaceSpace = function (s) {
     s = s.split("");
     let len = s.length;
     let count = 0;
     for (let i = 0; i < s.length; i++) {
       if (s[i] === " ") count++;
     }
     let left = len - 1,
       right = len + count * 2 - 1;
     for (let i = left, j = right; i >= 0, j >= 0; i--, j--) {
       if (s[i] === " ") {
         s[j - 2] = "%";
         s[j - 1] = "2";
         s[j] = "0";
         j -= 2;
       } else {
         s[j] = s[i];
       }
     }
     return s.join("");
   };
   ```

3. 用两个栈实现队列

4. 旋转数组的最小数字-二分查找

   ```js
   /**
    * @param {number[]} numbers
    * @return {number}
    */
   var minArray = function (numbers) {
     let left = 0,
       right = numbers.length - 1;
     while (left < right) {
       let mid = left + Math.floor((right - left) / 2);
       if (numbers[mid] > numbers[right]) {
         left = mid + 1;
       } else if (numbers[mid] < numbers[right]) {
         right = mid;
       } else {
         right--;
       }
     }
     return numbers[left];
   };
   ```

5. 二进制中 1 的个数

   ```js
   /**
    * @param {number} n - a positive integer
    * @return {number}
    */
   var hammingWeight = function (n) {
     let sum = 0;
     for (let i = 0; i < 32; i++) {
       sum += (n >> i) & 1;
     }
     return sum;
   };
   ```

6. 打印从 1 到最大的 n 位数-考虑大数(1. 深度优先遍历 2. 位运算)
   https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/solution/4chong-jie-fa-bao-li-zi-fu-chuan-wei-yun-v2dr/

   ```js
   /**
    * @param {number} n
    * @return {number[]}
    */
   var printNumbers = function (n) {
     let res = [];
     var dfs = function (index, str) {
       if (index === n) {
         res.push(+str);
         return;
       }
       for (let i = 0; i <= 9; i++) {
         str += i.toString();
         dfs(index + 1, str);
         str = str.slice(0, str.length - 1);
       }
     };
     dfs(0, "");
     res.shift();
     return res;
   };
   ```

7. 调整数组顺序使奇数位于偶数前面

8. 顺时针打印矩阵

   https://leetcode-cn.com/problems/spiral-matrix/solution/shou-hui-tu-jie-liang-chong-bian-li-de-ce-lue-kan-/

   ```js
   /**
    * @param {number[][]} matrix
    * @return {number[]}
    */
   var spiralOrder = function (matrix) {
     let res = [];
     if (!matrix.length) return res;
     let left = 0,
       right = matrix[0].length - 1,
       top = 0,
       bottom = matrix.length - 1;

     while (left < right && top < bottom) {
       // 遵循上右下左的顺序
       for (let i = left; i < right; i++) res.push(matrix[top][i]);
       for (let i = top; i < bottom; i++) res.push(matrix[i][right]);
       for (let i = right; i > left; i--) res.push(matrix[bottom][i]);
       for (let i = bottom; i > top; i--) res.push(matrix[i][left]);
       // 四个边界同时收缩，进入内层
       left++;
       right--;
       top++;
       bottom--;
     }
     // 剩下一列， 从上到下依次添加
     if (left == right) {
       for (let i = top; i <= bottom; i++) {
         res.push(matrix[i][left]);
       }
     }
     // 剩下一行，从左到右依次添加
     else if (top == bottom) {
       for (let i = left; i <= right; i++) {
         res.push(matrix[top][i]);
       }
     }
     return res;
   };
   ```

9. 数组中出现次数超过一半的数字-摩尔投票

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var majorityElement = function (nums) {
     let res = 0,
       count = 0;
     for (let i = 0; i < nums.length; i++) {
       if (!count) {
         res = nums[i];
         count++;
       } else {
         count += nums[i] === res ? 1 : -1;
       }
     }
     return res;
   };
   ```

10. 最小的 k 个数(敲重点， 利用快排)

    ```js
    /**
     * @param {number[]} arr
     * @param {number} k
     * @return {number[]}
     */
    var getLeastNumbers = function (arr, k) {
      let res = arr.sort((a, b) => a - b);
      return res.slice(0, k);
    };
    ```

    ```js
    /**
     * @param {number[]} arr
     * @param {number} k
     * @return {number[]}
     */
    var getLeastNumbers = function (arr, k) {
      if (k >= arr.length) return arr;
      let left = 0,
        right = arr.length - 1;
      let index = partition(arr, left, right);
      while (index !== k) {
        // 如果index < k，前 k 个元素在[index + 1, right] 之间，缩小查找范围，继续查找
        if (index < k) {
          left = index + 1;
          index = partition(arr, left, right);
        }
        // 如果k < index，前 k 个元素在[left, index - 1]之间，缩小查找范围，继续查找
        else if (index > k) {
          right = index - 1;
          index = partition(arr, left, right);
        }
      }
      return arr.slice(0, k);
    };
    // 快排的Partition操作， 小的放在左边，大的放在右边
    var partition = function (arr, start, end) {
      let pivot = arr[start];
      let left = start + 1,
        right = end;
      while (true) {
        while (left <= end && arr[left] <= pivot) left++;
        while (right >= start + 1 && arr[right] > pivot) right--;

        if (left >= right) {
          break;
        }
        [arr[left], arr[right]] = [arr[right], arr[left]];
        left++;
        right--;
      }
      [arr[start], arr[right]] = [arr[right], arr[start]];
      return right;
    };
    ```

11. 连续子数组的最大和

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var maxSubArray = function (nums) {
      let dp = new Array(nums.length).fill(0);
      // 结果注意不是0
      let res = nums[0];
      dp[0] = nums[0];
      for (let i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);

        if (res < dp[i]) {
          res = dp[i];
        }
      }
      return res;
    };
    ```

12. 第一个只出现一次的字符

    ```js
    // 用哈希表
    /**
     * @param {string} s
     * @return {character}
     */
    var firstUniqChar = function (s) {
      let map = new Map();
      for (let i = 0; i < s.length; i++) {
        map.set(s[i], (map.get(s[i]) || 0) + 1);
      }
      for (let [key, value] of map) {
        if (value === 1) {
          return key;
        }
      }
      return " ";
    };
    ```

    ```js
    /**
     * @param {string} s
     * @return {character}
     */
    var firstUniqChar = function (s) {
      for (let x of s) {
        if (s.indexOf(x) === s.lastIndexOf(x)) return x;
      }
      return " ";
    };
    ```

13. 在排序数组中查找数字(二分查找)

    ```js
    /**
     * @param {number[]} nums
     * @param {number} target
     * @return {number}
     */
    var search = function (nums, target) {
      var helper = function (nums, target) {
        let left = 0,
          right = nums.length - 1;
        while (left <= right) {
          let mid = Math.floor((left + right) / 2);
          if (nums[mid] <= target) {
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }
        return left;
      };
      return helper(nums, target) - helper(nums, target - 1);
    };
    ```

14. 0-n-1 中缺失的数字

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var missingNumber = function (nums) {
      for (let i = 0; i < nums.length + 1; i++) {
        if (i !== nums[i]) {
          return i;
        }
      }
    };
    ```

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var missingNumber = function (nums) {
      let left = 0,
        right = nums.length - 1;
      while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        nums[mid] === mid ? (left = mid + 1) : (right = mid - 1);
      }
      return left;
    };
    ```

15. 和为 s 的连续正数序列

    ```js
    /**
     * @param {number} target
     * @return {number[][]}
     */
    var findContinuousSequence = function (target) {
      sum = 0;
      let res = [],
        path = [];
      for (let right = 1; right <= target; right++) {
        while (sum > target) {
          sum -= path.shift();
        }
        if (sum === target) {
          res.push([...path]);
        }
        sum += right;
        path.push(right);
      }
      return res;
    };
    ```

16. 翻转单词顺序

    ```js
    /**
     * @param {string} s
     * @return {string}
     */
    var reverseWords = function (s) {
      return s.trim().split(/\s+/).reverse().join(" ");
    };
    ```

17. 左旋转字符串

    ```js
    /**
     * @param {string} s
     * @param {number} n
     * @return {string}
     */
    var reverseLeftWords = function (s, n) {
      return s.slice(n, s.length).concat(s.slice(0, n));
    };
    ```

18. 扑克牌中的顺子

19. 圆圈中最后剩下的数字

20. 不用加减乘除做加法

## 中等

1. 数字序列中某一位的数字
   https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/solution/mian-shi-ti-44-shu-zi-xu-lie-zhong-mou-yi-wei-de-6/

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var findNthDigit = function (n) {
     // 表示n所在的数字位数, 数字10的位数 为 2
     let digit = 1;
     // 每 digitdigit 位数的起始数字（即：1, 10, 100, \cdots1,10,100,⋯），记为 start
     let start = 1;
     // 位数的数字数量
     let count = 9;

     while (n > count) {
       n -= count;
       digit += 1;
       start *= 10;
       count = digit * start * 9;
     }
     // 找出所在的数字
     let num = start + Math.floor((n - 1) / digit);
     // 找出所在数字的第几位
     let index = (n - 1) % digit;
     return num.toString().charAt(index) - "0";
   };
   ```

2. 剪绳子

3. 剪绳子 II
   https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/tan-xin-javascript-by-lzxjack-6f7w/

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var cuttingRope = function (n) {
     // 特殊情况处理
     const arr = [null, null, 1, 2, 4];
     if (n <= 4) return arr[n];
     const mod = 1000000007;
     let res = 1;
     while (n > 4) {
       // 每次减掉3
       res = (res * 3) % mod;
       n -= 3;
     }
     // 最后剩下一段小于等于4的长度
     res *= n;
     return res % mod;
   };
   ```

4. 把数字翻译成字符串

   ```js
   /**
    * @param {number} num
    * @return {number}
    */
   var translateNum = function (num) {
     const str = num.toString();
     const len = str.length;
     let dp = new Array(len + 1);
     (dp[0] = 1), (dp[1] = 1);

     for (let i = 2; i <= len; i++) {
       let temp = Number(str[i - 2] + str[i - 1]);
       if (temp > 9 && temp < 26) {
         dp[i] = dp[i - 1] + dp[i - 2];
       } else {
         dp[i] = dp[i - 1];
       }
     }
     return dp[len];
   };
   ```

5. 礼物的最大价值

   ```js
   /**
    * @param {number[][]} grid
    * @return {number}
    */
   var maxValue = function (grid) {
     let [m, n] = [grid.length, grid[0].length];

     let dp = new Array(m).fill().map((item) => Array(n).fill(0));
     dp[0][0] = grid[0][0];

     for (let i = 1; i < m; i++) {
       dp[i][0] = dp[i - 1][0] + grid[i][0];
     }
     for (let i = 1; i < n; i++) {
       dp[0][i] = dp[0][i - 1] + grid[0][i];
     }
     for (let i = 1; i < m; i++) {
       for (let j = 1; j < n; j++) {
         dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
       }
     }
     return dp[m - 1][n - 1];
   };
   ```

6. 丑数
   https://leetcode-cn.com/problems/chou-shu-lcof/solution/js-jian-zhi-offer-49-chou-shu-by-adela20-4q7p/

   ```js
   /**
    * @param {number} n
    * @return {number}
    */
   var nthUglyNumber = function (n) {
     const dp = [1];
     let p2 = 0,
       p3 = 0,
       p5 = 0;
     for (let i = 1; i < n; i++) {
       let n2 = dp[p2] * 2,
         n3 = dp[p3] * 3,
         n5 = dp[p5] * 5;
       dp[i] = Math.min(n2, n3, n5);
       dp[i] == n2 && p2++;
       dp[i] == n3 && p3++;
       dp[i] == n5 && p5++;
     }
     return dp[n - 1];
   };
   ```

# 剑指 offer II

## 简单

1. 整数除法

   ```js
   /**
    * @param {number} a
    * @param {number} b
    * @return {number}
    */
   var divide = function (a, b) {
     const MAX = Math.pow(2, 31) - 1,
       MIN = -Math.pow(2, 31);
     if (a === MIN && b == 1) return MIN;
     // 除法溢出， 返回2的31-1
     if (a === MIN && b == -1) return MAX;

     const sign = (a > 0) ^ (b > 0);
     (a = Math.abs(a)), (b = Math.abs(b));
     let res = 0;
     while (a >= b) {
       res++;
       a -= b;
     }
     return sign > 0 ? -res : res;
   };
   ```

- 满减 carry

2. 大数相加

   ```js
   function add(a, b) {
     //取两个数字的最大长度
     let maxLength = Math.max(a.length, b.length);
     //用0去补齐长度
     a = a.padStart(maxLength, 0); //"0009007199254740991"
     b = b.padStart(maxLength, 0); //"1234567899999999999"
     //定义加法过程中需要用到的变量
     let t = 0;
     let f = 0; //"进位"
     let sum = "";
     for (let i = maxLength - 1; i >= 0; i--) {
       t = parseInt(a[i]) + parseInt(b[i]) + f;
       f = Math.floor(t / 10);
       sum = (t % 10) + sum;
     }
     if (f !== 0) {
       sum = "" + f + sum;
     }
     return sum;
   }
   ```

3. 加一

   ```js
   /**
    * @param {number[]} digits
    * @return {number[]}
    */
   var plusOne = function (digits) {
     for (let i = digits.length - 1; i >= 0; i--) {
       digits[i]++;
       digits[i] = digits[i] % 10;
       if (digits[i]) return digits;
     }
     digits.unshift(1);
     return digits;
   };
   ```

4. 数组形式的整数加法

   ```js
   /**
    * @param {number[]} num
    * @param {number} k
    * @return {number[]}
    */
   var addToArrayForm = function (num, k) {
     let res = [];
     let len1 = num.length - 1,
       carry = 0;
     while (len1 >= 0 || k !== 0) {
       const x = len1 >= 0 ? num[len1] : 0;
       const y = k !== 0 ? k % 10 : 0;

       let sum = x + y + carry;
       res.push(sum % 10);
       carry = Math.floor(sum / 10);

       len1--;
       k = Math.floor(k / 10);
     }
     if (carry) {
       res.push(carry);
     }
     return res.reverse();
   };
   ```

5. 字符串相加

   ```js
   /**
    * @param {string} num1
    * @param {string} num2
    * @return {string}
    */
   var addStrings = function (num1, num2) {
     let i = num1.length - 1,
       j = num2.length - 1;
     let res = "",
       carry = 0;
     while (i >= 0 || j >= 0) {
       const x = i >= 0 ? num1[i] - 0 : 0;
       const y = j >= 0 ? num2[j] - 0 : 0;

       const sum = x + y + carry;
       res += sum % 10;
       carry = Math.floor(sum / 10);

       i--;
       j--;
     }
     if (carry) res += carry;
     return res.split("").reverse().join("");
   };
   ```

6. 二进制求和

   ```js
   /**
    * @param {string} a
    * @param {string} b
    * @return {string}
    */
   var addBinary = function (a, b) {
     let res = "";
     let i = a.length - 1,
       j = b.length - 1;
     let carry = 0;
     // 注意细节，是>=0
     while (i >= 0 || j >= 0) {
       // 注意细节，是>=0
       const x = i >= 0 ? a[i] - "0" : 0;
       const y = j >= 0 ? b[j] - "0" : 0;

       let sum = x + y + carry;
       res += sum % 2;
       carry = Math.floor(sum / 2);

       i--;
       j--;
     }
     if (carry) res += carry;
     return res.split("").reverse().join("");
   };
   ```

7. 前 n 个数字二进制中 1 的个数-位运算

   ```js
   /**
    * @param {number} n
    * @return {number[]}
    */
   var countBits = function (n) {
     let res = [];
     for (let i = 0; i <= n; i++) {
       let sum = 0;
       for (let j = 0; j < 32; j++) {
         sum += (i >> j) & 1;
       }
       res.push(sum);
     }
     return res;
   };
   ```

8. 两数相加

   ```js
   /**
    * Definition for singly-linked list.
    * function ListNode(val, next) {
    *     this.val = (val===undefined ? 0 : val)
    *     this.next = (next===undefined ? null : next)
    * }
    */
   /**
    * @param {ListNode} l1
    * @param {ListNode} l2
    * @return {ListNode}
    */
   var addTwoNumbers = function (l1, l2) {
     let dummy = new ListNode();
     let cur = dummy;
     let carry = 0;
     while (l1 || l2) {
       const x = l1 ? l1.val : 0;
       const y = l2 ? l2.val : 0;

       let sum = x + y + carry;
       cur.next = new ListNode(sum % 10);
       cur = cur.next;
       carry = Math.floor(sum / 10);

       if (l1) l1 = l1.next;
       if (l2) l2 = l2.next;
     }
     if (carry) cur.next = new ListNode(carry);
     return dummy.next;
   };
   ```

- 二分查找

9. 排序数组中两个数字之和
   https://leetcode-cn.com/problems/kLl5u1/solution/jian-dan-yi-dong-javac-pythonjs-liang-sh-et4y/

   ```js
   /**
    * @param {number[]} numbers
    * @param {number} target
    * @return {number[]}
    */
   var twoSum = function (numbers, target) {
     let left = 0,
       right = numbers.length - 1;

     while (left < right) {
       let sum = numbers[left] + numbers[right];
       if (sum < target) {
         left++;
       } else if (sum > target) {
         right--;
       } else {
         return [left, right];
       }
     }
     return [];
   };
   ```

10. 爬楼梯的最少成本

    ```js
    /**
     * @param {number[]} cost
     * @return {number}
     */
    var minCostClimbingStairs = function (cost) {
      let len = cost.length;
      let dp = new Array(len + 1);
      (dp[0] = cost[0]), (dp[1] = cost[1]);
      for (let i = 2; i <= len; i++) {
        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];
      }
      return Math.min(dp[len - 1], dp[len - 2]);
    };
    ```

11. 左右两边子数组的和相等

    ```js
    /**
     * @param {number[]} nums
     * @return {number}
     */
    var pivotIndex = function (nums) {
      let total = nums.reduce((a, b) => a + b);
      let sum = 0;
      for (let i = 0; i < nums.length; i++) {
        if (sum === total - sum - nums[i]) {
          return i;
        }
        sum += nums[i];
      }
      return -1;
    };
    ```

12. 分割等和子集

    ```js
    /**
     * @param {number[]} nums
     * @return {boolean}
     */
    var canPartition = function (nums) {
      let sum = nums.reduce((pre, cur) => pre + cur);
      if (sum % 2 !== 0) return false;

      let number = sum / 2;
      let dp = new Array(number + 1).fill(0);

      for (let i = 0; i < nums.length; i++) {
        for (let j = number; j >= nums[i]; j--) {
          dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
          if (dp[j] === number) {
            return true;
          }
        }
      }
      return false;
    };
    ```

13. 有效的回文

    ```js
    /**
     * @param {string} s
     * @return {boolean}
     */
    var isPalindrome = function (s) {
      let str = s.toLowerCase();
      let res = [];
      for (let i = 0; i < str.length; i++) {
        if (str.charCodeAt(i) >= 97 && str.charCodeAt(i) <= 122)
          res.push(str[i]);
        if (str.charCodeAt(i) >= 48 && str.charCodeAt(i) <= 57)
          res.push(str[i]);
      }
      let resL = res.join("");
      let resR = res.reverse().join("");
      if (resL === resR) return true;
      return false;
    };
    ```

14. 山峰数组的顶部

    ```js
    /**
     * @param {number[]} arr
     * @return {number}
     */
    var peakIndexInMountainArray = function (arr) {
      let left = 1,
        right = arr.length - 2;
      while (left < right) {
        let mid = Math.floor((left + left) / 2);
        if (arr[mid - 1] < arr[mid] && arr[mid] > arr[mid + 1]) {
          return mid;
        } else if (arr[mid - 1] < arr[mid]) {
          left = mid + 1;
        } else {
          right = mid - 1;
        }
      }
      return left;
    };
    ```

15. 有效的变位词 | 有效的字母异位词

    ```js
    /**
     * @param {string} s
     * @param {string} t
     * @return {boolean}
     */
    var isAnagram = function (s, t) {
      let len1 = s.length,
        len2 = t.length;
      if (len1 !== len2 || s === t) return false;

      let map1 = new Map(),
        map2 = new Map();
      for (let i = 0; i < s.length; i++) {
        map1.set(s[i], map1.has(s[i]) ? map1.get(s[i]) + 1 : 1);
      }
      for (let i = 0; i < t.length; i++) {
        map2.set(t[i], map2.has(t[i]) ? map2.get(t[i]) + 1 : 1);
      }
      for (let [key, value] of map1) {
        if (!map2.has(key) || map2.get(key) !== value) {
          return false;
        }
      }
      return true;
      // 方法二 排序后判断是否相等
      // return s.length === t.length && [...s].sort().join() == [...t].sort().join()
    };
    ```

16. 求平方根

    ```js
    /**
     * @param {number} x
     * @return {number}
     */
    var mySqrt = function (x) {
      let left = 0,
        right = x;
      while (left < right) {
        let mid = Math.ceil((left + right) / 2);
        if (mid * mid <= x) {
          left = mid;
        } else {
          right = mid - 1;
        }
      }
      return left;
    };
    ```

17. 数组相对排序

    ```js
    /**
     * @param {number[]} arr1
     * @param {number[]} arr2
     * @return {number[]}
     */
    var relativeSortArray = function (arr1, arr2) {
      let arr = Array(1001).fill(0);
      // 统计arr1数字的出现次数
      for (let num of arr1) {
        arr[num]++;
      }

      let res = [];
      for (let num of arr2) {
        // 出现次数>0，循环推入res
        while (arr[num] > 0) {
          res.push(num);
          arr[num]--;
        }
      }
      // 解决未出现元素
      for (let i = 0; i < arr.length; i++) {
        // 非0项的索引 循环推入res
        while (arr[i] > 0) {
          res.push(i);
          arr[i]--;
        }
      }
      return res;
    };
    ```

18. 最多删除一个字符得到回文

    ```js
    /**
     * @param {string} s
     * @return {boolean}
     */
    var validPalindrome = function (s) {
      var isHW = function (str, left, right) {
        for (let i = left, j = right; i < j; i++, j--) {
          if (str[i] !== str[j]) {
            return false;
          }
        }
        return true;
      };

      for (let left = 0, right = s.length - 1; left < right; left++, right--) {
        if (s[left] !== s[right]) {
          return isHW(s, left + 1, right) || isHW(s, left, right - 1);
        }
      }
      return true;
    };
    ```

## 中等

- 位运算

1. 只出现一次的数字(其余元素均出现两次)
   用异或
   https://leetcode-cn.com/problems/single-number/solution/hua-jie-suan-fa-136-zhi-chu-xian-yi-ci-de-shu-zi-b/

   https://leetcode-cn.com/problems/single-number-ii/solution/ti-yi-lei-jie-wei-yun-suan-yi-wen-dai-ni-50dc/

   ```js
   var singleNumber = function (nums) {
     let res = 0;
     for (let num of nums) {
       res ^= num;
     }
     return res;
   };
   ```

2. 只出现一次的数字(两个元素出现一次，其余均出现两次)

   ```js
   /**
    * @param {number[]} nums
    * @return {number[]}
    */
   var singleNumbers = function (nums) {
     let res1 = 0,
       res2 = 0;
     let diff = 0,
       bit = 1;
     // 异或运算， 目的是找到两个落单数值，便于后面分类
     for (let num of nums) {
       diff ^= num;
     }
     // 左移运算，找到二者某一位的不同，将这1定位分类依据，分开落单数值
     while ((diff & bit) === 0) {
       bit <<= 1;
     }
     for (let num of nums) {
       if (num & bit) {
         res1 ^= num;
       } else {
         res2 ^= num;
       }
     }
     return [res1, res2];
   };
   ```

3. 只出现一次的数字(其余元素均出现三次)
   将所有 nums[i]对应的二进制数的对应位求和，将每一对应位的和值与 3 进行取模运算，得到的余数就是答案的对应二进制位的数值。

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var singleNumber = function (nums) {
     let res = 0;
     for (let i = 0; i < 32; i++) {
       let sum = 0;
       for (let num of nums) {
         sum += (num >> i) & 1;
       }
       if (sum % 3 === 1) {
         res |= 1 << i;
       }
     }
     return res;
   };
   ```

4. 单词长度的最大乘积
   https://leetcode-cn.com/problems/aseY1I/

   ```js
   /**
    * @param {string[]} words
    * @return {number}
    */
   var maxProduct = function (words) {
     let res = 0;
     var isSame = function (a, b) {
       for (let i = 0; i < a.length; i++) {
         if (b.indexOf(a[i]) !== -1) {
           return false;
         }
       }
       return true;
     };
     for (let i = 0; i < words.length - 1; i++) {
       for (let j = i + 1; j < words.length; j++) {
         if (isSame(words[i], words[j])) {
           let sum = words[i].length * words[j].length;
           if (res < sum) {
             res = sum;
           }
         }
       }
     }
     return res;
   };
   ```

   ```js
   /**
    * @param {string[]} words
    * @return {number}
    */
   var maxProduct = function (words) {
     let res = 0;
     let mask = new Array(words.length);

     for (let i = 0; i < words.length; i++) {
       let bitMask = 0;
       for (let c of words[i]) {
         // 注意以下含义
         bitMask |= 1 << (c.charCodeAt() - "a".charCodeAt());
       }
       mask[i] = bitMask;
     }

     for (let i = 0; i < words.length; i++) {
       for (let j = i + 1; j < words.length; j++) {
         // ===优先 所以一定要加()
         if ((mask[i] & mask[j]) === 0) {
           res = Math.max(res, words[i].length * words[j].length);
         }
       }
     }
     return res;
   };
   ```

- 滑动窗口

5. 和大于等于 target 的最短子数组

   ```js
   /**
    * @param {number} target
    * @param {number[]} nums
    * @return {number}
    */
   var minSubArrayLen = function (target, nums) {
     let left = 0;
     let sum = 0,
       res = nums.length + 1;
     for (let right = 0; right < nums.length; right++) {
       sum += nums[right];
       // 注意 =
       while (sum >= target && left <= right) {
         res = Math.min(res, right - left + 1);

         sum -= nums[left];
         left++;
       }
     }
     return res === nums.length + 1 ? 0 : res;
   };
   ```

6. 乘积小于 k 的子数组

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var numSubarrayProductLessThanK = function (nums, k) {
     let left = 0;
     let res = 0,
       sum = 1;
     for (let right = 0; right < nums.length; right++) {
       sum *= nums[right];

       while (sum >= k && left <= right) {
         sum /= nums[left];
         left++;
       }
       res += right >= left ? right - left + 1 : 0;
     }
     return res;
   };
   ```

- 前缀和

7. 和为 k 的子数组
   思路: 使用前缀和
   https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484488&idx=1&sn=848f76e86fce722e70e265d0c6f84dc3&source=41#wechat_redirect

   ```js
   /**
    * @param {number[]} nums
    * @param {number} k
    * @return {number}
    */
   var subarraySum = function (nums, k) {
     let res = 0,
       sum = 0;
     let map = new Map();
     map.set(0, 1);

     for (let i = 0; i < nums.length; i++) {
       sum += nums[i];
       // 必须先求和再设置map值
       res += map.get(sum - k) || 0;
       map.set(sum, (map.get(sum) || 0) + 1);
     }
     return res;
   };
   ```

8. 0 和 1 个数相同的子数组
   思路: 使用前缀和

   ```js
   /**
    * @param {number[]} nums
    * @return {number}
    */
   var findMaxLength = function (nums) {
     let map = new Map();
     let res = 0,
       sum = 0;
     map.set(0, -1);
     for (let i = 0; i < nums.length; i++) {
       let number = nums[i] === 0 ? -1 : 1;
       sum += number;
       // 如果存在的话，则将当前索引和之前存入的索引值相减  取题目要求的最大值
       if (map.has(sum)) {
         res = Math.max(res, i - map.get(sum));
       } else {
         // 记录前缀和 和 索引
         map.set(sum, i);
       }
     }
     return res;
   };
   ```

9. 二维子矩阵的和

- 双指针

10. 字符串中的变位词

    ```js
    // 利用滑动窗口
    /**
     * @param {string} s1
     * @param {string} s2
     * @return {boolean}
     */
    var checkInclusion = function (s1, s2) {
      if (s2.length < s1.length) return false;
      const arr = new Array(26).fill(0);

      function isZero(arr) {
        for (let i = 0; i < arr.length; i++) {
          if (arr[i] !== 0) return false;
        }
        return true;
      }
      for (let i = 0; i < s1.length; i++) {
        arr[s1.charCodeAt(i) - "a".charCodeAt(0)]++;
        arr[s2.charCodeAt(i) - "a".charCodeAt(0)]--;
      }
      if (isZero(arr)) {
        return true;
      }
      for (let i = s1.length; i < s2.length; i++) {
        arr[s2.charCodeAt(i) - "a".charCodeAt(0)]--;
        arr[s2.charCodeAt(i - s1.length) - "a".charCodeAt(0)]++;
        if (isZero(arr)) {
          return true;
        }
      }
      return false;
    };
    ```

11. 字符串中的所有变位词

    ```js
    /**
     * @param {string} s
     * @param {string} p
     * @return {number[]}
     */
    var findAnagrams = function (s, p) {
      let res = [];
      if (s.length < p.length) return [];
      let arr = new Array(26).fill(0);

      function isZero(arr) {
        for (let i = 0; i < arr.length; i++) {
          if (arr[i] !== 0) return false;
        }
        return true;
      }

      for (let i = 0; i < p.length; i++) {
        arr[p.charCodeAt(i) - "a".charCodeAt(0)]++;
        arr[s.charCodeAt(i) - "a".charCodeAt(0)]--;
      }
      if (isZero(arr)) {
        res.push(0);
      }

      for (let i = p.length; i < s.length; i++) {
        arr[s.charCodeAt(i) - "a".charCodeAt(0)]--;
        arr[s.charCodeAt(i - p.length) - "a".charCodeAt(0)]++;
        if (isZero(arr)) {
          res.push(i - p.length + 1);
        }
      }
      return res;
    };
    ```

- 滑动窗口

12. 不含重复字符的最长子字符串
    https://leetcode-cn.com/problems/wtcaE1/solution/jian-dan-yi-dong-javac-pythonjshua-dong-dtang/

    ```js
    /**
     * @param {string} s
     * @return {number}
     */
    var lengthOfLongestSubstring = function (s) {
      // 窗口中的字符
      let window = {};
      let left = 0,
        res = 0;
      for (let right = 0; right < s.length; right++) {
        let str = s[right];
        window[str] = (window[str] || 0) + 1;
        while (window[str] > 1) {
          let strL = s[left];
          left++;
          window[strL]--;
        }
        res = Math.max(res, right - left + 1);
      }
      return res;
    };
    ```

13. 回文子字符串的个数
    有很多方法

    ```js
    // 双重for循环
    /**
     * @param {string} s
     * @return {number}
     */
    var countSubstrings = function (s) {
      let res = 0;
      var isHW = function (str, l, r) {
        for (let i = l, j = r; i <= j; i++, j--) {
          if (str[i] !== str[j]) return false;
        }
        return true;
      };
      for (let i = 0; i < s.length; i++) {
        for (let j = i; j < s.length; j++) {
          if (isHW(s, i, j)) {
            res++;
          }
        }
      }
      return res;
    };
    ```

    ```js
    // 动态规划
    const countSubstrings = function (s) {
      const len = s.length;
      const dp = new Array(len).fill(0).map(() => new Array(len).fill(false));
      let res = 0;
      for (let i = 0; i < len; i++) {
        for (let j = i; j >= 0; j--) {
          if (s[i] === s[j]) {
            // 初始化
            if (i - j <= 1) {
              // 初始化 a 和 aa 的情况
              dp[i][j] = true;
            } else {
              dp[i][j] = dp[i - 1][j + 1];
            }
          }
          res += dp[i][j] ? 1 : 0;
        }
      }
      return res;
    };
    ```

    ```js
    // 双指针法, 以某个字符串为中心向外延展
    /**
     * @param {string} s
     * @return {number}
     */
    var countSubstrings = function (s) {
      if (!s) return 0;

      var isHW = function (s, start, end) {
        let count = 0;
        while (
          start >= 0 &&
          end < s.length &&
          // 下面这句一定要写在条件里, false直接break
          s.charAt(start) === s.charAt(end)
        ) {
          count++;
          start--;
          end++;
        }
        return count;
      };
      let res = 0;
      for (let i = 0; i < s.length; i++) {
        // 长度为奇数的回文的对称中心只有一个字符
        res += isHW(s, i, i);
        // 长度为偶数的回文的对称中心只有两个字符
        res += isHW(s, i, i + 1);
      }
      return res;
    };
    ```

14. 最近最少使用缓存

    ```js
    /**
     * @param {number} capacity
     */
    var LRUCache = function (capacity) {
      this.cache = new Map();
      this.capacity = capacity;
    };

    /**
     * @param {number} key
     * @return {number}
     */
    LRUCache.prototype.get = function (key) {
      if (!this.cache.has(key)) {
        return -1;
      }
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    };

    /**
     * @param {number} key
     * @param {number} value
     * @return {void}
     */
    LRUCache.prototype.put = function (key, value) {
      if (this.cache.has(key)) {
        this.cache.delete(key);
      }
      // 当缓存容量达到上限时，删除最久未使用的数据值
      if (this.cache.size === this.capacity) {
        const iterator = this.cache.keys();
        this.cache.delete(iterator.next().value);
      }
      this.cache.set(key, value);
    };

    /**
     * Your LRUCache object will be instantiated and called as such:
     * var obj = new LRUCache(capacity)
     * var param_1 = obj.get(key)
     * obj.put(key,value)
     */
    ```

15. 变位词组

    ```js
    /**
     * @param {string[]} strs
     * @return {string[][]}
     */
    var groupAnagrams = function (strs) {
      let obj = {};
      strs.forEach((item) => {
        let key = item.split("").sort().join("");

        if (!(key in obj)) {
          obj[key] = [];
        }
        obj[key].push(item);
      });
      return Object.values(obj);
    };
    ```

16. 最小时间差

17. 后缀表达式

    ```js
    /**
     * @param {string[]} tokens
     * @return {number}
     */
    var evalRPN = function (tokens) {
      let numarr = [];
      let len = tokens.length;
      for (let i = 0; i < len; i++) {
        if (tokens[i] === "+") {
          let num1 = numarr.pop();
          let num2 = numarr.pop();
          numarr.push(num1 + num2);
        } else if (tokens[i] === "-") {
          let num1 = numarr.pop();
          let num2 = numarr.pop();
          numarr.push(num2 - num1);
        } else if (tokens[i] === "*") {
          let num1 = numarr.pop();
          let num2 = numarr.pop();
          numarr.push(num2 * num1);
        } else if (tokens[i] === "/") {
          let num1 = numarr.pop();
          let num2 = numarr.pop();
          numarr.push(parseInt(num2 / num1));
        } else {
          numarr.push(parseInt(tokens[i]));
        }
      }
      return numarr.pop();
    };
    ```

18. 小行星碰撞

19. 每日温度

20. 值和下标之差都在给定的范围内 - 桶排序

    ```js
    /**
     * @param {number[]} nums
     * @param {number} k
     * @param {number} t
     * @return {boolean}
     */
    var containsNearbyAlmostDuplicate = function (nums, k, t) {
      for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
          let number = Math.abs(nums[i] - nums[j]);
          let index = Math.abs(i - j);
          if (number <= t && index <= k) {
            return true;
          }
        }
      }
      return false;
    };
    ```

21. 出现频率最高的 k 个数字

    ```js
    /**
     * @param {number[]} nums
     * @param {number} k
     * @return {number[]}
     */
    var topKFrequent = function (nums, k) {
      let obj = {},
        arr = [];
      for (let i = 0; i < nums.length; i++) {
        if (!obj[nums[i]]) {
          obj[nums[i]] = 1;
        } else {
          obj[nums[i]]++;
        }
      }
      for (let i in obj) {
        arr.push({ key: i, value: obj[i] });
      }
      arr.sort((a, b) => b.value - a.value);
      return arr.splice(0, k).map((item) => {
        return item.key;
      });
    };
    ```

22. 和最小的 k 个数对 - 最好用堆排序

    ```js
    // 双重for循环
    /**
     * @param {number[]} nums1
     * @param {number[]} nums2
     * @param {number} k
     * @return {number[][]}
     */
    var kSmallestPairs = function (nums1, nums2, k) {
      arr = [];
      for (let i = 0; i < nums1.length; i++) {
        for (let j = 0; j < nums2.length; j++) {
          let sum = nums1[i] + nums2[j];
          arr.push({ u: nums1[i], v: nums2[j], sum: sum });
        }
      }
      arr.sort((a, b) => a.sum - b.sum);
      return arr.splice(0, k).map((item) => {
        return [item.u, item.v];
      });
    };
    ```

23. 狒狒吃香蕉

24. 合并区间

    ```js
    /**
     * @param {number[][]} intervals
     * @return {number[][]}
     */
    var merge = function (intervals) {
      intervals.sort((a, b) => a[0] - b[0]);
      let prevArr = intervals[0];
      let res = [];
      for (let i = 1; i < intervals.length; i++) {
        let curArr = intervals[i];
        if (curArr[0] > prevArr[1]) {
          res.push(prevArr);
          prevArr = curArr;
        } else {
          // 考虑[1,9], [3,7]的情况
          prevArr[1] = Math.max(curArr[1], prevArr[1]);
        }
      }
      res.push(prevArr);
      return res;
    };
    ```

25. 数组中的第 k 大的数字

26. 翻转字符

    ```js
    /**
     * @param {string} s
     * @return {number}
     */
    var minFlipsMonoIncr = function (s) {
      // 记录1的个数
      let countOf1 = s[0] === "0" ? 0 : 1;
      let dp = new Array(s.length).fill(0);
      for (let i = 1; i < s.length; i++) {
        if (s[i] === "0") {
          // s[i] 为0, 有两种选择
          // 1) 将自己的0翻转为1
          // 2) 将前面的所有1翻转为0
          dp[i] = Math.min(dp[i - 1] + 1, countOf1);
        } else {
          // 若为1, 与前面相同
          dp[i] = dp[i - 1];
          // 记录1的个数
          countOf1++;
        }
      }
      return dp[s.length - 1];
    };
    ```

# 面试题

1. 翻转单词顺序

   ```js
   //翻转单词顺序
   var reverseWords = function (s) {
     //将两个单词多余的空格减少到一个
     s = s.replace(/ +/g, " ");
     return s.split(" ").reverse().join(" ").trim();
   };
   ```

2. 和为 s 的连续正数序列

   ```javascript
   /**
    * @param {number} target
    * @return {number[][]}
    */
   // 利用滑动窗口
   var findContinuousSequence = function (target) {
     let result = [];

     let i = 1,
       j = 1,
       sum = 0; // i表示左指针，j表示右指针
     while (i <= Math.floor(target / 2)) {
       if (sum < target) {
         sum += j;
         j++;
       } else if (sum > target) {
         sum -= i;
         i++;
       } else {
         const arr = [];
         for (let k = i; k < j; k++) {
           arr.push(k);
         }
         result.push(arr);
         sum -= i;
         i++;
       }
     }
     return result;
   };
   ```

3. 最长回文子串

   ```javascript
   var longestPalindrome = function (s) {
     if (s.length < 2) return s;

     let res = "";
     for (let i = 0; i < s.length; i++) {
       helper(i, i);
       helper(i, i + 1);
     }

     function helper(m, n) {
       while (m >= 0 && n < s.length && s[n] === s[m]) {
         m--;
         n++;
       }

       if (n - m - 1 > res.length) {
         res = s.slice(m + 1, n);
       }
     }
     return res;
   };
   ```

4. 最长公共前缀

   ```js
   /**
    * @param {string[]} strs
    * @return {string}
    */
   var longestCommonPrefix = function (strs) {
     if (strs.length === 0) return "";
     let res = strs[0];
     for (let i = 1; i < strs.length; i++) {
       let j = 0;
       for (; j < strs[0].length && j < strs[i].length; j++) {
         if (res[j] !== strs[i][j]) {
           break;
         }
       }
       res = res.substr(0, j);
     }
     return res;
   };
   ```

5. 有效的括号

   ```js
   var isValid = function (s) {
     let stack = [];
     for (let val of s) {
       if (val === "(" || val === "[" || val === "{") {
         stack.push(val);
       } else {
         if (stack.length === 0) return false;
         if (val === ")" && stack.pop() !== "(") return false;
         if (val === "]" && stack.pop() !== "[") return false;
         if (val === "}" && stack.pop() !== "{") return false;
       }
     }
     return !stack.length;
   };
   ```

6. 顺时针打印矩阵

```

```
